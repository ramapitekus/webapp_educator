{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyCollection, PropertyId, ResultReason, SpeechSynthesisBookmarkEventArgs, SpeechSynthesisEventArgs, SpeechSynthesisResult, SpeechSynthesisVisemeEventArgs, SpeechSynthesisWordBoundaryEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, CancellationErrorCodePropertyName, MetadataType, SynthesisAudioMetadata, SynthesisContext, SynthesisTurn } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class SynthesisAdapterBase {\n  constructor(authentication, connectionFactory, synthesizerConfig, speechSynthesizer, audioDestination) {\n    this.speakOverride = undefined;\n    this.receiveMessageOverride = undefined;\n    this.connectImplOverride = undefined;\n    this.configConnectionOverride = undefined;\n\n    this.sendSynthesisContext = connection => {\n      const synthesisContextJson = this.synthesisContext.toJSON();\n\n      if (synthesisContextJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"synthesis.context\", this.privSynthesisTurn.requestId, \"application/json\", synthesisContextJson));\n      }\n\n      return;\n    };\n\n    this.sendSpeechServiceConfig = (connection, SpeechServiceConfigJson) => {\n      if (SpeechServiceConfigJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", this.privSynthesisTurn.requestId, \"application/json\", SpeechServiceConfigJson));\n      }\n    };\n\n    this.sendSsmlMessage = (connection, ssml, requestId) => {\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"ssml\", requestId, \"application/ssml+xml\", ssml));\n    };\n\n    if (!authentication) {\n      throw new ArgumentNullError(\"authentication\");\n    }\n\n    if (!connectionFactory) {\n      throw new ArgumentNullError(\"connectionFactory\");\n    }\n\n    if (!synthesizerConfig) {\n      throw new ArgumentNullError(\"synthesizerConfig\");\n    }\n\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privSynthesizerConfig = synthesizerConfig;\n    this.privIsDisposed = false;\n    this.privSpeechSynthesizer = speechSynthesizer;\n    this.privSessionAudioDestination = audioDestination;\n    this.privSynthesisTurn = new SynthesisTurn();\n    this.privConnectionEvents = new EventSource();\n    this.privServiceEvents = new EventSource();\n    this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\n    this.privAgentConfig = new AgentConfig();\n    this.connectionEvents.attach(connectionEvent => {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n\n        if (connectionClosedEvent.statusCode !== 1000) {\n          this.cancelSynthesisLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\n        }\n      }\n    });\n  }\n\n  get synthesisContext() {\n    return this.privSynthesisContext;\n  }\n\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n    this.privSynthesisTurn.audioOutputFormat = format;\n\n    if (this.privSessionAudioDestination !== undefined) {\n      this.privSessionAudioDestination.format = format;\n    }\n\n    if (this.synthesisContext !== undefined) {\n      this.synthesisContext.audioOutputFormat = format;\n    }\n  }\n\n  static addHeader(audio, format) {\n    if (!format.hasHeader) {\n      return audio;\n    }\n\n    format.updateHeader(audio.byteLength);\n    const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\n    tmp.set(new Uint8Array(format.header), 0);\n    tmp.set(new Uint8Array(audio), format.header.byteLength);\n    return tmp.buffer;\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n\n      if (this.privSessionAudioDestination !== undefined) {\n        this.privSessionAudioDestination.close();\n      }\n\n      if (this.privConnectionConfigurationPromise) {\n        const connection = yield this.privConnectionConfigurationPromise;\n        yield connection.dispose(reason);\n      }\n    });\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n    });\n  }\n\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\n    });\n  }\n\n  Speak(text, isSSML, requestId, successCallback, errorCallBack, audioDestination) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let ssml;\n\n      if (isSSML) {\n        ssml = text;\n      } else {\n        ssml = this.privSpeechSynthesizer.buildSsml(text);\n      }\n\n      if (this.speakOverride !== undefined) {\n        return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\n      }\n\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\n\n      try {\n        yield this.connectImpl();\n        const connection = yield this.fetchConnection();\n        yield this.sendSynthesisContext(connection);\n        yield this.sendSsmlMessage(connection, ssml, requestId);\n        const synthesisStartEventArgs = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(requestId, ResultReason.SynthesizingAudioStarted));\n\n        if (!!this.privSpeechSynthesizer.synthesisStarted) {\n          this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\n        }\n\n        const messageRetrievalPromise = this.receiveMessage();\n      } catch (e) {\n        this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\n        return Promise.reject(e);\n      }\n    });\n  } // Cancels synthesis.\n\n\n  cancelSynthesis(requestId, cancellationReason, errorCode, error) {\n    const properties = new PropertyCollection();\n    properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n    const result = new SpeechSynthesisResult(requestId, ResultReason.Canceled, undefined, error, properties);\n\n    if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\n      const cancelEvent = new SpeechSynthesisEventArgs(result);\n\n      try {\n        this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\n        /* tslint:disable:no-empty */\n      } catch (_a) {}\n    }\n\n    if (!!this.privSuccessCallback) {\n      try {\n        this.privSuccessCallback(result);\n        /* tslint:disable:no-empty */\n      } catch (_b) {}\n    }\n  } // Cancels synthesis.\n\n\n  cancelSynthesisLocal(cancellationReason, errorCode, error) {\n    if (!!this.privSynthesisTurn.isSynthesizing) {\n      this.privSynthesisTurn.onStopSynthesizing();\n      this.cancelSynthesis(this.privSynthesisTurn.requestId, cancellationReason, errorCode, error);\n    }\n  }\n\n  processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n    return true;\n  }\n\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        }\n\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        } // indicates we are draining the queue and it came with no message;\n\n\n        if (!message) {\n          if (!this.privSynthesisTurn.isSynthesizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n\n        this.privServiceHasSentMessage = true;\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n        if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privSynthesisTurn.onServiceTurnStartResponse();\n              break;\n\n            case \"response\":\n              this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\n              break;\n\n            case \"audio\":\n              if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase() && !!connectionMessage.binaryBody) {\n                this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\n\n                if (!!this.privSpeechSynthesizer.synthesizing) {\n                  try {\n                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\n                    const ev = new SpeechSynthesisEventArgs(new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudio, audioWithHeader));\n                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\n                  } catch (error) {// Not going to let errors in the event handler\n                    // trip things up.\n                  }\n                }\n\n                if (this.privSessionAudioDestination !== undefined) {\n                  this.privSessionAudioDestination.write(connectionMessage.binaryBody);\n                }\n              }\n\n              break;\n\n            case \"audio.metadata\":\n              const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\n\n              for (const metadata of metadataList) {\n                switch (metadata.Type) {\n                  case MetadataType.WordBoundary:\n                    this.privSynthesisTurn.onWordBoundaryEvent(metadata.Data.text.Text);\n                    const wordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(metadata.Data.Offset, metadata.Data.text.Text, metadata.Data.text.Length, this.privSynthesisTurn.currentTextOffset);\n\n                    if (!!this.privSpeechSynthesizer.wordBoundary) {\n                      try {\n                        this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\n                      } catch (error) {// Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n\n                    break;\n\n                  case MetadataType.Bookmark:\n                    const bookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(metadata.Data.Offset, metadata.Data.Bookmark);\n\n                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\n                      try {\n                        this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\n                      } catch (error) {// Not going to let errors in the event handler\n                        // trip things up.\n                      }\n                    }\n\n                    break;\n\n                  case MetadataType.Viseme:\n                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\n\n                    if (metadata.Data.IsLastAnimation) {\n                      const visemeEventArgs = new SpeechSynthesisVisemeEventArgs(metadata.Data.Offset, metadata.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());\n\n                      if (!!this.privSpeechSynthesizer.visemeReceived) {\n                        try {\n                          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\n                        } catch (error) {// Not going to let errors in the event handler\n                          // trip things up.\n                        }\n                      }\n                    }\n\n                    break;\n                }\n              }\n\n              break;\n\n            case \"turn.end\":\n              this.privSynthesisTurn.onServiceTurnEndResponse();\n              let result;\n\n              try {\n                const audioBuffer = yield this.privSynthesisTurn.getAllReceivedAudioWithHeader();\n                result = new SpeechSynthesisResult(this.privSynthesisTurn.requestId, ResultReason.SynthesizingAudioCompleted, audioBuffer);\n\n                if (!!this.privSuccessCallback) {\n                  this.privSuccessCallback(result);\n                }\n              } catch (error) {\n                if (!!this.privErrorCallback) {\n                  this.privErrorCallback(error);\n                }\n              }\n\n              if (this.privSpeechSynthesizer.synthesisCompleted) {\n                try {\n                  this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new SpeechSynthesisEventArgs(result));\n                } catch (e) {// Not going to let errors in the event handler\n                  // trip things up.\n                }\n              }\n\n              break;\n\n            default:\n              if (!this.processTypeSpecificMessages(connectionMessage)) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n\n          }\n        }\n\n        return this.receiveMessage();\n      } catch (e) {// TODO: What goes here?\n      }\n    });\n  }\n\n  connectImpl() {\n    let isUnAuthorized = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    if (this.privConnectionPromise) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          this.privServiceHasSentMessage = false;\n          return this.connectImpl();\n        }\n\n        return this.privConnectionPromise;\n      }, error => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        this.privServiceHasSentMessage = false;\n        return this.connectImpl();\n      });\n    }\n\n    this.privAuthFetchEventId = createNoDashGuid();\n    this.privConnectionId = createNoDashGuid();\n    this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\n    const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n    this.privConnectionPromise = authPromise.then(result => __awaiter(this, void 0, void 0, function* () {\n      yield this.privSynthesisTurn.onAuthCompleted(false);\n      const connection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n      // it'll stop sending events.\n\n      connection.events.attach(event => {\n        this.connectionEvents.onEvent(event);\n      });\n      const response = yield connection.open();\n\n      if (response.statusCode === 200) {\n        yield this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\n        return Promise.resolve(connection);\n      } else if (response.statusCode === 403 && !isUnAuthorized) {\n        return this.connectImpl(true);\n      } else {\n        yield this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode, response.reason);\n        return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\n      }\n    }), error => __awaiter(this, void 0, void 0, function* () {\n      yield this.privSynthesisTurn.onAuthCompleted(true, error);\n      throw new Error(error);\n    })); // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n\n    this.privConnectionPromise.catch(() => {});\n    return this.privConnectionPromise;\n  }\n\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = null;\n            this.privServiceHasSentMessage = false;\n            return this.fetchConnection();\n          }\n\n          return this.privConnectionConfigurationPromise;\n        }, error => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = null;\n          this.privServiceHasSentMessage = false;\n          return this.fetchConnection();\n        });\n      }\n\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n\n      yield this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\n      return connection;\n    });\n  }\n\n}\nSynthesisAdapterBase.telemetryDataEnabled = true;","map":{"version":3,"mappings":"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","names":["ArgumentNullError","ConnectionState","createNoDashGuid","EventSource","MessageType","ServiceEvent","CancellationErrorCode","CancellationReason","PropertyCollection","PropertyId","ResultReason","SpeechSynthesisBookmarkEventArgs","SpeechSynthesisEventArgs","SpeechSynthesisResult","SpeechSynthesisVisemeEventArgs","SpeechSynthesisWordBoundaryEventArgs","AgentConfig","CancellationErrorCodePropertyName","MetadataType","SynthesisAudioMetadata","SynthesisContext","SynthesisTurn","SpeechConnectionMessage","SynthesisAdapterBase","constructor","authentication","connectionFactory","synthesizerConfig","speechSynthesizer","audioDestination","undefined","connection","synthesisContextJson","synthesisContext","toJSON","send","Text","privSynthesisTurn","requestId","SpeechServiceConfigJson","ssml","privAuthentication","privConnectionFactory","privSynthesizerConfig","privIsDisposed","privSpeechSynthesizer","privSessionAudioDestination","privConnectionEvents","privServiceEvents","privSynthesisContext","privAgentConfig","connectionEvents","attach","connectionEvent","name","connectionClosedEvent","statusCode","cancelSynthesisLocal","Error","BadRequestParameters","ConnectionFailure","reason","agentConfig","serviceEvents","activityTemplate","messagePayload","privActivityTemplate","audioOutputFormat","format","privAudioOutputFormat","addHeader","audio","hasHeader","updateHeader","byteLength","tmp","Uint8Array","header","set","buffer","isDisposed","dispose","close","privConnectionConfigurationPromise","connect","connectImpl","sendNetworkMessage","path","payload","type","Binary","contentType","fetchConnection","Speak","text","isSSML","successCallback","errorCallBack","buildSsml","speakOverride","privSuccessCallback","privErrorCallback","startNewSynthesis","sendSynthesisContext","sendSsmlMessage","synthesisStartEventArgs","SynthesizingAudioStarted","synthesisStarted","messageRetrievalPromise","receiveMessage","e","Promise","reject","cancelSynthesis","cancellationReason","errorCode","error","properties","setProperty","result","Canceled","SynthesisCanceled","cancelEvent","isSynthesizing","onStopSynthesizing","processTypeSpecificMessages","connectionMessage","message","read","receiveMessageOverride","privServiceHasSentMessage","fromConnectionMessage","toLowerCase","onServiceTurnStartResponse","onServiceResponseMessage","textBody","streamId","binaryBody","onAudioChunkReceived","synthesizing","audioWithHeader","ev","SynthesizingAudio","write","metadataList","fromJSON","Metadata","metadata","Type","WordBoundary","onWordBoundaryEvent","Data","wordBoundaryEventArgs","Offset","Length","currentTextOffset","wordBoundary","Bookmark","bookmarkEventArgs","bookmarkReached","Viseme","onVisemeMetadataReceived","IsLastAnimation","visemeEventArgs","VisemeId","getAndClearVisemeAnimation","visemeReceived","onServiceTurnEndResponse","audioBuffer","getAllReceivedAudioWithHeader","SynthesizingAudioCompleted","synthesisCompleted","onEvent","isUnAuthorized","privConnectionPromise","then","state","Disconnected","privConnectionId","privAuthFetchEventId","onPreConnectionStart","authPromise","fetchOnExpiry","fetch","__awaiter","onAuthCompleted","create","events","event","response","open","onConnectionEstablishCompleted","resolve","parameters","getProperty","SpeechServiceConnection_Endpoint","catch","configureConnection","configConnectionOverride","sendSpeechServiceConfig","SpeechServiceConfig","serialize"],"sources":["C:\\Users\\ozgur\\Documents\\VSCodeProjects\\webapp_educator\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\SynthesisAdapterBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioDestination,\r\n    IConnection,\r\n    IDisposable,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    ResultReason,\r\n    SpeechSynthesisBookmarkEventArgs,\r\n    SpeechSynthesisEventArgs,\r\n    SpeechSynthesisResult,\r\n    SpeechSynthesisVisemeEventArgs,\r\n    SpeechSynthesisWordBoundaryEventArgs,\r\n    SpeechSynthesizer,\r\n} from \"../sdk/Exports\";\r\nimport {\r\n    AgentConfig,\r\n    CancellationErrorCodePropertyName,\r\n    ISynthesisConnectionFactory,\r\n    MetadataType,\r\n    SynthesisAudioMetadata,\r\n    SynthesisContext,\r\n    SynthesisTurn,\r\n    SynthesizerConfig\r\n} from \"./Exports\";\r\nimport { AuthInfo, IAuthentication } from \"./IAuthentication\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class SynthesisAdapterBase implements IDisposable {\r\n    protected privSynthesisTurn: SynthesisTurn;\r\n    protected privConnectionId: string;\r\n    protected privSynthesizerConfig: SynthesizerConfig;\r\n    protected privSpeechSynthesizer: SpeechSynthesizer;\r\n    protected privSuccessCallback: (e: SpeechSynthesisResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public get synthesisContext(): SynthesisContext {\r\n        return this.privSynthesisContext;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    protected speakOverride: (ssml: string, requestId: string, sc: (e: SpeechSynthesisResult) => void, ec: (e: string) => void) => any = undefined;\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public set activityTemplate(messagePayload: string) { this.privActivityTemplate = messagePayload; }\r\n    public get activityTemplate(): string { return this.privActivityTemplate; }\r\n\r\n    protected receiveMessageOverride: () => any = undefined;\r\n\r\n    protected connectImplOverride: (isUnAuthorized: boolean) => any = undefined;\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => any = undefined;\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n        this.privSynthesisTurn.audioOutputFormat = format;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.format = format;\r\n        }\r\n        if (this.synthesisContext !== undefined) {\r\n            this.synthesisContext.audioOutputFormat = format;\r\n        }\r\n    }\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: ISynthesisConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privSynthesisContext: SynthesisContext;\r\n    private privAgentConfig: AgentConfig;\r\n    private privServiceHasSentMessage: boolean;\r\n    private privActivityTemplate: string;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privSessionAudioDestination: IAudioDestination;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: ISynthesisConnectionFactory,\r\n        synthesizerConfig: SynthesizerConfig,\r\n        speechSynthesizer: SpeechSynthesizer,\r\n        audioDestination: IAudioDestination) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!synthesizerConfig) {\r\n            throw new ArgumentNullError(\"synthesizerConfig\");\r\n        }\r\n\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privSynthesizerConfig = synthesizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privSpeechSynthesizer = speechSynthesizer;\r\n        this.privSessionAudioDestination = audioDestination;\r\n        this.privSynthesisTurn = new SynthesisTurn();\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privSynthesisContext = new SynthesisContext(this.privSpeechSynthesizer);\r\n        this.privAgentConfig = new AgentConfig();\r\n\r\n        this.connectionEvents.attach((connectionEvent: ConnectionEvent): void => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode !== 1000) {\r\n                    this.cancelSynthesisLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public static addHeader(audio: ArrayBuffer, format: AudioOutputFormatImpl): ArrayBuffer {\r\n        if (!format.hasHeader) {\r\n            return audio;\r\n        }\r\n        format.updateHeader(audio.byteLength);\r\n        const tmp = new Uint8Array(audio.byteLength + format.header.byteLength);\r\n        tmp.set(new Uint8Array(format.header), 0);\r\n        tmp.set(new Uint8Array(audio), format.header.byteLength);\r\n        return tmp.buffer;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privSessionAudioDestination !== undefined) {\r\n            this.privSessionAudioDestination.close();\r\n        }\r\n        if (this.privConnectionConfigurationPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n    }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privSynthesisTurn.requestId, contentType, payload));\r\n    }\r\n\r\n    public async Speak(\r\n        text: string,\r\n        isSSML: boolean,\r\n        requestId: string,\r\n        successCallback: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n        audioDestination: IAudioDestination,\r\n    ): Promise<void> {\r\n\r\n        let ssml: string;\r\n\r\n        if (isSSML) {\r\n            ssml = text;\r\n        } else {\r\n            ssml = this.privSpeechSynthesizer.buildSsml(text);\r\n        }\r\n\r\n        if (this.speakOverride !== undefined) {\r\n            return this.speakOverride(ssml, requestId, successCallback, errorCallBack);\r\n        }\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privSynthesisTurn.startNewSynthesis(requestId, text, isSSML, audioDestination);\r\n\r\n        try {\r\n            await this.connectImpl();\r\n            const connection: IConnection = await this.fetchConnection();\r\n            await this.sendSynthesisContext(connection);\r\n            await this.sendSsmlMessage(connection, ssml, requestId);\r\n            const synthesisStartEventArgs: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                new SpeechSynthesisResult(\r\n                    requestId,\r\n                    ResultReason.SynthesizingAudioStarted,\r\n                )\r\n            );\r\n\r\n            if (!!this.privSpeechSynthesizer.synthesisStarted) {\r\n                this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, synthesisStartEventArgs);\r\n            }\r\n\r\n            const messageRetrievalPromise = this.receiveMessage();\r\n        } catch (e) {\r\n            this.cancelSynthesisLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesis(\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n        const properties: PropertyCollection = new PropertyCollection();\r\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n        const result: SpeechSynthesisResult = new SpeechSynthesisResult(\r\n            requestId,\r\n            ResultReason.Canceled,\r\n            undefined,\r\n            error,\r\n            properties\r\n        );\r\n\r\n        if (!!this.privSpeechSynthesizer.SynthesisCanceled) {\r\n            const cancelEvent: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(result);\r\n            try {\r\n                this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        if (!!this.privSuccessCallback) {\r\n            try {\r\n                this.privSuccessCallback(result);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n    }\r\n\r\n    // Cancels synthesis.\r\n    protected cancelSynthesisLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        if (!!this.privSynthesisTurn.isSynthesizing) {\r\n            this.privSynthesisTurn.onStopSynthesizing();\r\n\r\n            this.cancelSynthesis(\r\n                this.privSynthesisTurn.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    protected processTypeSpecificMessages(\r\n        connectionMessage: SpeechConnectionMessage,\r\n        successCallback?: (e: SpeechSynthesisResult) => void,\r\n        errorCallBack?: (e: string) => void): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConnectionMessage = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privSynthesisTurn.isSynthesizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n            this.privServiceHasSentMessage = true;\r\n\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privSynthesisTurn.onServiceTurnStartResponse();\r\n                        break;\r\n                    case \"response\":\r\n                        this.privSynthesisTurn.onServiceResponseMessage(connectionMessage.textBody);\r\n                        break;\r\n                    case \"audio\":\r\n                        if (this.privSynthesisTurn.streamId.toLowerCase() === connectionMessage.streamId.toLowerCase()\r\n                            && !!connectionMessage.binaryBody) {\r\n                            this.privSynthesisTurn.onAudioChunkReceived(connectionMessage.binaryBody);\r\n                            if (!!this.privSpeechSynthesizer.synthesizing) {\r\n                                try {\r\n                                    const audioWithHeader = SynthesisAdapterBase.addHeader(connectionMessage.binaryBody, this.privSynthesisTurn.audioOutputFormat);\r\n                                    const ev: SpeechSynthesisEventArgs = new SpeechSynthesisEventArgs(\r\n                                        new SpeechSynthesisResult(\r\n                                            this.privSynthesisTurn.requestId,\r\n                                            ResultReason.SynthesizingAudio,\r\n                                            audioWithHeader));\r\n                                    this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, ev);\r\n                                } catch (error) {\r\n                                    // Not going to let errors in the event handler\r\n                                    // trip things up.\r\n                                }\r\n                            }\r\n                            if (this.privSessionAudioDestination !== undefined) {\r\n                                this.privSessionAudioDestination.write(connectionMessage.binaryBody);\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"audio.metadata\":\r\n                        const metadataList = SynthesisAudioMetadata.fromJSON(connectionMessage.textBody).Metadata;\r\n                        for (const metadata of metadataList) {\r\n                            switch (metadata.Type) {\r\n                                case MetadataType.WordBoundary:\r\n                                    this.privSynthesisTurn.onWordBoundaryEvent(metadata.Data.text.Text);\r\n\r\n                                    const wordBoundaryEventArgs: SpeechSynthesisWordBoundaryEventArgs = new SpeechSynthesisWordBoundaryEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.text.Text,\r\n                                        metadata.Data.text.Length,\r\n                                        this.privSynthesisTurn.currentTextOffset);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.wordBoundary) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, wordBoundaryEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Bookmark:\r\n                                    const bookmarkEventArgs: SpeechSynthesisBookmarkEventArgs = new SpeechSynthesisBookmarkEventArgs(\r\n                                        metadata.Data.Offset,\r\n                                        metadata.Data.Bookmark);\r\n\r\n                                    if (!!this.privSpeechSynthesizer.bookmarkReached) {\r\n                                        try {\r\n                                            this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, bookmarkEventArgs);\r\n                                        } catch (error) {\r\n                                            // Not going to let errors in the event handler\r\n                                            // trip things up.\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                                case MetadataType.Viseme:\r\n\r\n                                    this.privSynthesisTurn.onVisemeMetadataReceived(metadata);\r\n\r\n                                    if (metadata.Data.IsLastAnimation) {\r\n                                        const visemeEventArgs: SpeechSynthesisVisemeEventArgs = new SpeechSynthesisVisemeEventArgs(\r\n                                            metadata.Data.Offset,\r\n                                            metadata.Data.VisemeId,\r\n                                            this.privSynthesisTurn.getAndClearVisemeAnimation());\r\n\r\n                                        if (!!this.privSpeechSynthesizer.visemeReceived) {\r\n                                            try {\r\n                                                this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, visemeEventArgs);\r\n                                            } catch (error) {\r\n                                                // Not going to let errors in the event handler\r\n                                                // trip things up.\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                    break;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \"turn.end\":\r\n                        this.privSynthesisTurn.onServiceTurnEndResponse();\r\n                        let result: SpeechSynthesisResult;\r\n                        try {\r\n                            const audioBuffer: ArrayBuffer = await this.privSynthesisTurn.getAllReceivedAudioWithHeader();\r\n                            result = new SpeechSynthesisResult(\r\n                                this.privSynthesisTurn.requestId,\r\n                                ResultReason.SynthesizingAudioCompleted,\r\n                                audioBuffer\r\n                            );\r\n                            if (!!this.privSuccessCallback) {\r\n                                this.privSuccessCallback(result);\r\n                            }\r\n                        } catch (error) {\r\n                            if (!!this.privErrorCallback) {\r\n                                this.privErrorCallback(error);\r\n                            }\r\n                        }\r\n                        if (this.privSpeechSynthesizer.synthesisCompleted) {\r\n                            try {\r\n                                this.privSpeechSynthesizer.synthesisCompleted(\r\n                                    this.privSpeechSynthesizer,\r\n                                    new SpeechSynthesisEventArgs(result)\r\n                                );\r\n                            } catch (e) {\r\n                                // Not going to let errors in the event handler\r\n                                // trip things up.\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n\r\n                }\r\n            }\r\n\r\n            return this.receiveMessage();\r\n\r\n        } catch (e) {\r\n            // TODO: What goes here?\r\n        }\r\n    }\r\n\r\n    protected sendSynthesisContext = (connection: IConnection): Promise<void> => {\r\n        const synthesisContextJson = this.synthesisContext.toJSON();\r\n\r\n        if (synthesisContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"synthesis.context\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                synthesisContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected connectImpl(isUnAuthorized: boolean = false): Promise<IConnection> {\r\n        if (this.privConnectionPromise) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        this.privConnectionId = createNoDashGuid();\r\n\r\n        this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\r\n\r\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n\r\n        this.privConnectionPromise = authPromise.then(async (result: AuthInfo) => {\r\n            await this.privSynthesisTurn.onAuthCompleted(false);\r\n\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privSynthesizerConfig, result, this.privConnectionId);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent) => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n            const response = await connection.open();\r\n            if (response.statusCode === 200) {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 403 && !isUnAuthorized) {\r\n                return this.connectImpl(true);\r\n            } else {\r\n                await this.privSynthesisTurn.onConnectionEstablishCompleted(response.statusCode, response.reason);\r\n                return Promise.reject(`Unable to contact server. StatusCode: ${response.statusCode}, ${this.privSynthesizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${response.reason}`);\r\n            }\r\n        }, async (error: string): Promise<IConnection> => {\r\n            await this.privSynthesisTurn.onAuthCompleted(true, error);\r\n            throw new Error(error);\r\n        });\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        this.privConnectionPromise.catch(() => { });\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n    protected sendSpeechServiceConfig = (connection: IConnection, SpeechServiceConfigJson: string): Promise<void> => {\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                this.privSynthesisTurn.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n    }\r\n\r\n    protected sendSsmlMessage = (connection: IConnection, ssml: string, requestId: string): Promise<void> => {\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"ssml\",\r\n            requestId,\r\n            \"application/ssml+xml\",\r\n            ssml));\r\n    }\r\n\r\n    private async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privSynthesizerConfig.SpeechServiceConfig.serialize());\r\n        return connection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}