{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource } from \"../common/Exports\";\nimport { AudioStreamFormat } from \"../sdk/Audio/AudioStreamFormat\";\nexport class FileAudioSource {\n  constructor(file, filename, audioSourceId) {\n    this.privStreams = {};\n    this.privHeaderEnd = 44;\n\n    this.turnOn = () => {\n      if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\n        const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\n        this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\n        return Promise.reject(errorMsg);\n      }\n\n      this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n\n      this.onEvent(new AudioSourceReadyEvent(this.privId));\n      return;\n    };\n\n    this.id = () => {\n      return this.privId;\n    };\n\n    this.attach = audioNodeId => __awaiter(this, void 0, void 0, function* () {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      const stream = yield this.upload(audioNodeId);\n      this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n      return Promise.resolve({\n        detach: () => __awaiter(this, void 0, void 0, function* () {\n          stream.readEnded();\n          delete this.privStreams[audioNodeId];\n          this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n          yield this.turnOff();\n        }),\n        id: () => {\n          return audioNodeId;\n        },\n        read: () => {\n          return stream.read();\n        }\n      });\n    });\n\n    this.detach = audioNodeId => {\n      if (audioNodeId && this.privStreams[audioNodeId]) {\n        this.privStreams[audioNodeId].close();\n        delete this.privStreams[audioNodeId];\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n      }\n    };\n\n    this.turnOff = () => {\n      for (const streamId in this.privStreams) {\n        if (streamId) {\n          const stream = this.privStreams[streamId];\n\n          if (stream && !stream.isClosed) {\n            stream.close();\n          }\n        }\n      }\n\n      this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n\n      return Promise.resolve();\n    };\n\n    this.onEvent = event => {\n      this.privEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    };\n\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n    this.privSource = file;\n\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\n      this.privFilename = file.name;\n    } else {\n      this.privFilename = filename || \"unknown.wav\";\n    } // Read the header.\n\n\n    this.privAudioFormatPromise = this.readHeader();\n  }\n\n  get format() {\n    return this.privAudioFormatPromise;\n  }\n\n  get blob() {\n    return Promise.resolve(this.privSource);\n  }\n\n  get events() {\n    return this.privEvents;\n  }\n\n  get deviceInfo() {\n    return this.privAudioFormatPromise.then(result => {\n      return Promise.resolve({\n        bitspersample: result.bitsPerSample,\n        channelcount: result.channels,\n        connectivity: connectivity.Unknown,\n        manufacturer: \"Speech SDK\",\n        model: \"File\",\n        samplerate: result.samplesPerSec,\n        type: type.File\n      });\n    });\n  }\n\n  readHeader() {\n    // Read the wave header.\n    const maxHeaderSize = 512;\n    const header = this.privSource.slice(0, maxHeaderSize);\n    const headerResult = new Deferred();\n\n    const processHeader = header => {\n      const view = new DataView(header);\n\n      const getWord = index => {\n        return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\n      }; // RIFF 4 bytes.\n\n\n      if (\"RIFF\" !== getWord(0)) {\n        headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\n        return;\n      } // length, 4 bytes\n      // RIFF Type & fmt 8 bytes\n\n\n      if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\n        headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\n        return;\n      }\n\n      const formatSize = view.getInt32(16, true);\n      const channelCount = view.getUint16(22, true);\n      const sampleRate = view.getUint32(24, true);\n      const bitsPerSample = view.getUint16(34, true); // Confirm if header is 44 bytes long.\n\n      let pos = 36 + Math.max(formatSize - 16, 0);\n\n      for (; getWord(pos) !== \"data\"; pos += 2) {\n        if (pos > maxHeaderSize - 8) {\n          headerResult.reject(\"Invalid WAV header in file, data block was not found\");\n          return;\n        }\n      }\n\n      this.privHeaderEnd = pos + 8;\n      headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount));\n    };\n\n    if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\n      const reader = new FileReader();\n\n      reader.onload = event => {\n        const header = event.target.result;\n        processHeader(header);\n      };\n\n      reader.readAsArrayBuffer(header);\n    } else {\n      const h = header;\n      processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\n    }\n\n    return headerResult.promise;\n  }\n\n  upload(audioNodeId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const onerror = error => {\n        const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\n        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\n        throw new Error(errorMsg);\n      };\n\n      try {\n        yield this.turnOn();\n        const format = yield this.privAudioFormatPromise;\n        const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\n        this.privStreams[audioNodeId] = stream;\n        const chunk = this.privSource.slice(this.privHeaderEnd);\n\n        const processFile = buff => {\n          if (stream.isClosed) {\n            return; // output stream was closed (somebody called TurnOff). We're done here.\n          }\n\n          stream.writeStreamChunk({\n            buffer: buff,\n            isEnd: false,\n            timeReceived: Date.now()\n          });\n          stream.close();\n        };\n\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\n          const reader = new FileReader();\n\n          reader.onerror = ev => {\n            onerror(ev.toString());\n          };\n\n          reader.onload = event => {\n            const fileBuffer = event.target.result;\n            processFile(fileBuffer);\n          };\n\n          reader.readAsArrayBuffer(chunk);\n        } else {\n          const c = chunk;\n          processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\n        }\n\n        return stream;\n      } catch (e) {\n        onerror(e);\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["connectivity","type","AudioSourceErrorEvent","AudioSourceInitializingEvent","AudioSourceOffEvent","AudioSourceReadyEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ChunkedArrayBufferStream","createNoDashGuid","Deferred","Events","EventSource","AudioStreamFormat","FileAudioSource","constructor","file","filename","audioSourceId","privFilename","lastIndexOf","length","errorMsg","onEvent","Promise","reject","privId","audioNodeId","__awaiter","stream","upload","resolve","detach","readEnded","privStreams","turnOff","id","read","close","streamId","isClosed","event","privEvents","instance","privSource","window","Blob","name","privAudioFormatPromise","readHeader","format","blob","events","deviceInfo","then","result","bitspersample","bitsPerSample","channelcount","channels","Unknown","manufacturer","model","samplerate","samplesPerSec","File","maxHeaderSize","header","slice","headerResult","processHeader","view","DataView","getWord","index","String","fromCharCode","getUint8","formatSize","getInt32","channelCount","getUint16","sampleRate","getUint32","pos","Math","max","privHeaderEnd","getWaveFormatPCM","reader","FileReader","onload","target","readAsArrayBuffer","h","buffer","byteOffset","byteLength","promise","onerror","error","Error","turnOn","avgBytesPerSec","chunk","processFile","buff","writeStreamChunk","isEnd","timeReceived","Date","now","ev","toString","fileBuffer","c","e"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.browser\\src\\common.browser\\FileAudioSource.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStreamChunk,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    private privAudioFormatPromise: Promise<AudioStreamFormatImpl>;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privSource: Blob | Buffer;\r\n\r\n    private privFilename: string;\r\n\r\n    private privHeaderEnd: number = 44;\r\n\r\n    public constructor(file: File | Buffer, filename?: string, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privSource = file;\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && this.privSource instanceof Blob) {\r\n            this.privFilename = (file as File).name;\r\n        } else {\r\n            this.privFilename = filename || \"unknown.wav\";\r\n        }\r\n\r\n        // Read the header.\r\n        this.privAudioFormatPromise = this.readHeader();\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return this.privAudioFormatPromise;\r\n    }\r\n\r\n    public get blob(): Promise<Blob | Buffer> {\r\n        return Promise.resolve(this.privSource);\r\n    }\r\n\r\n    public turnOn = (): Promise<void> => {\r\n        if (this.privFilename.lastIndexOf(\".wav\") !== this.privFilename.length - 4) {\r\n            const errorMsg = this.privFilename + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return Promise.reject(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = async (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        const stream: Stream<ArrayBuffer> = await this.upload(audioNodeId);\r\n\r\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n        return Promise.resolve({\r\n            detach: async (): Promise<void> => {\r\n                stream.readEnded();\r\n                delete this.privStreams[audioNodeId];\r\n                this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                await this.turnOff();\r\n            },\r\n            id: () => {\r\n                return audioNodeId;\r\n            },\r\n            read: (): Promise<IStreamChunk<ArrayBuffer>> => {\r\n                return stream.read();\r\n            },\r\n        });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<void> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.privAudioFormatPromise.then<ISpeechConfigAudioDevice>((result: AudioStreamFormatImpl) => {\r\n            return Promise.resolve({\r\n                bitspersample: result.bitsPerSample,\r\n                channelcount: result.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: \"File\",\r\n                samplerate: result.samplesPerSec,\r\n                type: type.File,\r\n            });\r\n        });\r\n    }\r\n\r\n    private readHeader(): Promise<AudioStreamFormatImpl> {\r\n        // Read the wave header.\r\n        const maxHeaderSize: number = 512;\r\n        const header: Blob | Buffer = this.privSource.slice(0, maxHeaderSize);\r\n\r\n        const headerResult: Deferred<AudioStreamFormatImpl> = new Deferred<AudioStreamFormatImpl>();\r\n\r\n        const processHeader = (header: ArrayBuffer): void => {\r\n            const view: DataView = new DataView(header);\r\n\r\n            const getWord = (index: number): string => {\r\n                return String.fromCharCode(view.getUint8(index), view.getUint8(index + 1), view.getUint8(index + 2), view.getUint8(index + 3));\r\n            };\r\n\r\n            // RIFF 4 bytes.\r\n            if (\"RIFF\" !== getWord(0)) {\r\n                headerResult.reject(\"Invalid WAV header in file, RIFF was not found\");\r\n                return;\r\n            }\r\n\r\n            // length, 4 bytes\r\n            // RIFF Type & fmt 8 bytes\r\n            if (\"WAVE\" !== getWord(8) || \"fmt \" !== getWord(12)) {\r\n                headerResult.reject(\"Invalid WAV header in file, WAVEfmt was not found\");\r\n                return;\r\n            }\r\n\r\n            const formatSize: number = view.getInt32(16, true);\r\n            const channelCount: number = view.getUint16(22, true);\r\n            const sampleRate: number = view.getUint32(24, true);\r\n            const bitsPerSample: number = view.getUint16(34, true);\r\n            // Confirm if header is 44 bytes long.\r\n            let pos: number = 36 + Math.max(formatSize - 16, 0);\r\n            for (; getWord(pos) !== \"data\"; pos += 2) {\r\n                if (pos > maxHeaderSize - 8) {\r\n                    headerResult.reject(\"Invalid WAV header in file, data block was not found\");\r\n                    return;\r\n                }\r\n            }\r\n            this.privHeaderEnd = pos + 8;\r\n            headerResult.resolve(AudioStreamFormat.getWaveFormatPCM(sampleRate, bitsPerSample, channelCount) as AudioStreamFormatImpl);\r\n        };\r\n\r\n        if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && header instanceof Blob) {\r\n            const reader: FileReader = new FileReader();\r\n\r\n            reader.onload = (event: Event) => {\r\n                const header: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                processHeader(header);\r\n            };\r\n\r\n            reader.readAsArrayBuffer(header);\r\n        } else {\r\n            const h: Buffer = header as Buffer;\r\n            processHeader(h.buffer.slice(h.byteOffset, h.byteOffset + h.byteLength));\r\n        }\r\n        return headerResult.promise;\r\n    }\r\n\r\n    private async upload(audioNodeId: string): Promise<Stream<ArrayBuffer>> {\r\n        const onerror = (error: string) => {\r\n            const errorMsg = `Error occurred while processing '${this.privFilename}'. ${error}`;\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n            throw new Error(errorMsg);\r\n        };\r\n\r\n        try {\r\n            await this.turnOn();\r\n\r\n            const format: AudioStreamFormatImpl = await this.privAudioFormatPromise;\r\n            const stream = new ChunkedArrayBufferStream(format.avgBytesPerSec / 10, audioNodeId);\r\n\r\n            this.privStreams[audioNodeId] = stream;\r\n            const chunk: Blob | Buffer = this.privSource.slice(this.privHeaderEnd);\r\n\r\n            const processFile = (buff: ArrayBuffer): void => {\r\n                if (stream.isClosed) {\r\n                    return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                }\r\n\r\n                stream.writeStreamChunk({\r\n                    buffer: buff,\r\n                    isEnd: false,\r\n                    timeReceived: Date.now(),\r\n                });\r\n                stream.close();\r\n            };\r\n\r\n            if (typeof window !== \"undefined\" && typeof Blob !== \"undefined\" && chunk instanceof Blob) {\r\n                const reader: FileReader = new FileReader();\r\n                reader.onerror = (ev: ProgressEvent<FileReader>) => { onerror(ev.toString()); };\r\n\r\n                reader.onload = (event: Event) => {\r\n                    const fileBuffer: ArrayBuffer = (event.target as FileReader).result as ArrayBuffer;\r\n                    processFile(fileBuffer);\r\n                };\r\n\r\n                reader.readAsArrayBuffer(chunk);\r\n            } else {\r\n                const c: Buffer = chunk as Buffer;\r\n                processFile(c.buffer.slice(c.byteOffset, c.byteOffset + c.byteLength));\r\n            }\r\n\r\n            return stream;\r\n        } catch (e) {\r\n            onerror(e);\r\n        }\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}