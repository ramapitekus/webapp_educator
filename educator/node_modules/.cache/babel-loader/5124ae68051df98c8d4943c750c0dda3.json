{"ast":null,"code":"//\n// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\n//\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { MessageType } from \"../common/Exports\";\nimport { PropertyCollection } from \"./PropertyCollection\";\nimport { PropertyId } from \"./PropertyId\";\n/**\n * ConnectionMessage represents implementation specific messages sent to and received from\n * the speech service. These messages are provided for debugging purposes and should not\n * be used for production use cases with the Azure Cognitive Services Speech Service.\n * Messages sent to and received from the Speech Service are subject to change without\n * notice. This includes message contents, headers, payloads, ordering, etc.\n * Added in version 1.11.0.\n */\n\nexport class ConnectionMessage {} // tslint:disable-next-line:max-classes-per-file\n\nexport class ConnectionMessageImpl {\n  constructor(message) {\n    this.privConnectionMessage = message;\n    this.privProperties = new PropertyCollection();\n\n    if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\n      this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\n    }\n\n    Object.keys(this.privConnectionMessage.headers).forEach((header, index, array) => {\n      this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\n    });\n  }\n  /**\n   * The message path.\n   */\n\n\n  get path() {\n    return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find(key => key.toLowerCase() === \"path\".toLowerCase())];\n  }\n  /**\n   * Checks to see if the ConnectionMessage is a text message.\n   * See also IsBinaryMessage().\n   */\n\n\n  get isTextMessage() {\n    return this.privConnectionMessage.messageType === MessageType.Text;\n  }\n  /**\n   * Checks to see if the ConnectionMessage is a binary message.\n   * See also GetBinaryMessage().\n   */\n\n\n  get isBinaryMessage() {\n    return this.privConnectionMessage.messageType === MessageType.Binary;\n  }\n  /**\n   * Gets the text message payload. Typically the text message content-type is\n   * application/json. To determine other content-types use\n   * Properties.GetProperty(\"Content-Type\").\n   */\n\n\n  get TextMessage() {\n    return this.privConnectionMessage.textBody;\n  }\n  /**\n   * Gets the binary message payload.\n   */\n\n\n  get binaryMessage() {\n    return this.privConnectionMessage.binaryBody;\n  }\n  /**\n   * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\n   * Message headers can be accessed via this collection (e.g. \"Content-Type\").\n   */\n\n\n  get properties() {\n    return this.privProperties;\n  }\n  /**\n   * Returns a string that represents the connection message.\n   */\n\n\n  toString() {\n    return \"\";\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;AACA;AACA;AAEA,SAASA,WAAT,QAA4B,8BAA5B;AACA,SAEIC,WAFJ,QAGO,mBAHP;AAIA,SACIC,kBADJ,QAEO,sBAFP;AAGA,SAASC,UAAT,QAA2B,cAA3B;AAEA;;;;;;;;;AAQA,OAAM,MAAgBC,iBAAhB,CAAiC,E,CA0CvC;;AACA,OAAM,MAAOC,qBAAP,CAA4B;AAK9BC,cAAYC,OAAZ,EAAyC;AACrC,SAAKC,qBAAL,GAA6BD,OAA7B;AACA,SAAKE,cAAL,GAAsB,IAAIP,kBAAJ,EAAtB;;AACA,QAAI,CAAC,CAAC,KAAKM,qBAAL,CAA2BE,OAA3B,CAAmCV,WAAW,CAACW,YAA/C,CAAN,EAAoE;AAChE,WAAKF,cAAL,CAAoBG,WAApB,CAAgCT,UAAU,CAACU,gBAA3C,EAA6D,KAAKL,qBAAL,CAA2BE,OAA3B,CAAmCV,WAAW,CAACW,YAA/C,CAA7D;AACH;;AAEDG,UAAM,CAACC,IAAP,CAAY,KAAKP,qBAAL,CAA2BE,OAAvC,EAAgDM,OAAhD,CAAwD,CAACC,MAAD,EAAiBC,KAAjB,EAAgCC,KAAhC,KAAyD;AAC7G,WAAKV,cAAL,CAAoBG,WAApB,CAAgCK,MAAhC,EAAwC,KAAKT,qBAAL,CAA2BE,OAA3B,CAAmCO,MAAnC,CAAxC;AACH,KAFD;AAGH;AAED;;;;;AAGe,MAAJG,IAAI;AACX,WAAO,KAAKZ,qBAAL,CAA2BE,OAA3B,CAAmCI,MAAM,CAACC,IAAP,CAAY,KAAKP,qBAAL,CAA2BE,OAAvC,EAAgDW,IAAhD,CAAsDC,GAAD,IAAiBA,GAAG,CAACC,WAAJ,OAAsB,OAAOA,WAAP,EAA5F,CAAnC,CAAP;AACH;AAED;;;;;;AAIwB,MAAbC,aAAa;AACpB,WAAO,KAAKhB,qBAAL,CAA2BiB,WAA3B,KAA2CxB,WAAW,CAACyB,IAA9D;AACH;AAED;;;;;;AAI0B,MAAfC,eAAe;AACtB,WAAO,KAAKnB,qBAAL,CAA2BiB,WAA3B,KAA2CxB,WAAW,CAAC2B,MAA9D;AACH;AAED;;;;;;;AAKsB,MAAXC,WAAW;AAClB,WAAO,KAAKrB,qBAAL,CAA2BsB,QAAlC;AACH;AAED;;;;;AAGwB,MAAbC,aAAa;AACpB,WAAO,KAAKvB,qBAAL,CAA2BwB,UAAlC;AACH;AAED;;;;;;AAIqB,MAAVC,UAAU;AACjB,WAAO,KAAKxB,cAAZ;AACH;AAED;;;;;AAGOyB,UAAQ;AACX,WAAO,EAAP;AACH;;AArE6B","names":["HeaderNames","MessageType","PropertyCollection","PropertyId","ConnectionMessage","ConnectionMessageImpl","constructor","message","privConnectionMessage","privProperties","headers","ConnectionId","setProperty","Speech_SessionId","Object","keys","forEach","header","index","array","path","find","key","toLowerCase","isTextMessage","messageType","Text","isBinaryMessage","Binary","TextMessage","textBody","binaryMessage","binaryBody","properties","toString"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\sdk\\src\\sdk\\ConnectionMessage.ts"],"sourcesContent":["//\r\n// Copyright (c) Microsoft. All rights reserved.\r\n// Licensed under the MIT license. See LICENSE.md file in the project root for full license information.\r\n//\r\n\r\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\r\nimport {\r\n    ConnectionMessage as IntConnectionMessage,\r\n    MessageType\r\n} from \"../common/Exports\";\r\nimport {\r\n    PropertyCollection\r\n} from \"./PropertyCollection\";\r\nimport { PropertyId } from \"./PropertyId\";\r\n\r\n/**\r\n * ConnectionMessage represents implementation specific messages sent to and received from\r\n * the speech service. These messages are provided for debugging purposes and should not\r\n * be used for production use cases with the Azure Cognitive Services Speech Service.\r\n * Messages sent to and received from the Speech Service are subject to change without\r\n * notice. This includes message contents, headers, payloads, ordering, etc.\r\n * Added in version 1.11.0.\r\n */\r\nexport abstract class ConnectionMessage {\r\n    /**\r\n     * The message path.\r\n     */\r\n    public abstract get path(): string;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public abstract get isTextMessage(): boolean;\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public abstract get isBinaryMessage(): boolean;\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public abstract get TextMessage(): string;\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public abstract get binaryMessage(): ArrayBuffer;\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public abstract get properties(): PropertyCollection;\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public abstract toString(): string;\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class ConnectionMessageImpl {\r\n\r\n    private privConnectionMessage: IntConnectionMessage;\r\n    private privProperties: PropertyCollection;\r\n\r\n    constructor(message: IntConnectionMessage) {\r\n        this.privConnectionMessage = message;\r\n        this.privProperties = new PropertyCollection();\r\n        if (!!this.privConnectionMessage.headers[HeaderNames.ConnectionId]) {\r\n            this.privProperties.setProperty(PropertyId.Speech_SessionId, this.privConnectionMessage.headers[HeaderNames.ConnectionId]);\r\n        }\r\n\r\n        Object.keys(this.privConnectionMessage.headers).forEach((header: string, index: number, array: string[]): void => {\r\n            this.privProperties.setProperty(header, this.privConnectionMessage.headers[header]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The message path.\r\n     */\r\n    public get path(): string {\r\n        return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((key: string) => key.toLowerCase() === \"path\".toLowerCase())];\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a text message.\r\n     * See also IsBinaryMessage().\r\n     */\r\n    public get isTextMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Text;\r\n    }\r\n\r\n    /**\r\n     * Checks to see if the ConnectionMessage is a binary message.\r\n     * See also GetBinaryMessage().\r\n     */\r\n    public get isBinaryMessage(): boolean {\r\n        return this.privConnectionMessage.messageType === MessageType.Binary;\r\n    }\r\n\r\n    /**\r\n     * Gets the text message payload. Typically the text message content-type is\r\n     * application/json. To determine other content-types use\r\n     * Properties.GetProperty(\"Content-Type\").\r\n     */\r\n    public get TextMessage(): string {\r\n        return this.privConnectionMessage.textBody;\r\n    }\r\n\r\n    /**\r\n     * Gets the binary message payload.\r\n     */\r\n    public get binaryMessage(): ArrayBuffer {\r\n        return this.privConnectionMessage.binaryBody;\r\n    }\r\n\r\n    /**\r\n     * A collection of properties and their values defined for this <see cref=\"ConnectionMessage\"/>.\r\n     * Message headers can be accessed via this collection (e.g. \"Content-Type\").\r\n     */\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    /**\r\n     * Returns a string that represents the connection message.\r\n     */\r\n    public toString(): string {\r\n        return \"\";\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}