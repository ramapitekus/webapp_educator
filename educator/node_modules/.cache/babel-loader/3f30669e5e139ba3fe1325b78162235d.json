{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\nimport { List } from \"./List\";\nimport { Deferred } from \"./Promise\";\nvar SubscriberType;\n\n(function (SubscriberType) {\n  SubscriberType[SubscriberType[\"Dequeue\"] = 0] = \"Dequeue\";\n  SubscriberType[SubscriberType[\"Peek\"] = 1] = \"Peek\";\n})(SubscriberType || (SubscriberType = {}));\n\nexport class Queue {\n  constructor(list) {\n    this.privPromiseStore = new List();\n    this.privIsDrainInProgress = false;\n    this.privIsDisposing = false;\n    this.privDisposeReason = null;\n\n    this.enqueue = item => {\n      this.throwIfDispose();\n      this.enqueueFromPromise(new Promise((resolve, reject) => {\n        resolve(item);\n      }));\n    };\n\n    this.enqueueFromPromise = promise => {\n      this.throwIfDispose();\n      promise.then(val => {\n        this.privList.add(val);\n        /* tslint:disable:no-empty */\n      }, error => {});\n    };\n\n    this.dequeue = () => {\n      this.throwIfDispose();\n      const deferredSubscriber = new Deferred();\n\n      if (this.privSubscribers) {\n        this.privSubscribers.add({\n          deferral: deferredSubscriber,\n          type: SubscriberType.Dequeue\n        });\n        this.drain();\n      }\n\n      return deferredSubscriber.promise;\n    };\n\n    this.peek = () => {\n      this.throwIfDispose();\n      const deferredSubscriber = new Deferred();\n      const subs = this.privSubscribers;\n\n      if (subs) {\n        this.privSubscribers.add({\n          deferral: deferredSubscriber,\n          type: SubscriberType.Peek\n        });\n        this.drain();\n      }\n\n      return deferredSubscriber.promise;\n    };\n\n    this.length = () => {\n      this.throwIfDispose();\n      return this.privList.length();\n    };\n\n    this.isDisposed = () => {\n      return this.privSubscribers == null;\n    };\n\n    this.drain = () => {\n      if (!this.privIsDrainInProgress && !this.privIsDisposing) {\n        this.privIsDrainInProgress = true;\n        const subs = this.privSubscribers;\n        const lists = this.privList;\n\n        if (subs && lists) {\n          while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\n            const subscriber = subs.removeFirst();\n\n            if (subscriber.type === SubscriberType.Peek) {\n              subscriber.deferral.resolve(lists.first());\n            } else {\n              const dequeuedItem = lists.removeFirst();\n              subscriber.deferral.resolve(dequeuedItem);\n            }\n          } // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n\n\n          if (this.privSubscribers === subs) {\n            this.privSubscribers = subs;\n          } // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n\n\n          if (this.privList === lists) {\n            this.privList = lists;\n          }\n        }\n\n        this.privIsDrainInProgress = false;\n      }\n    };\n\n    this.throwIfDispose = () => {\n      if (this.isDisposed()) {\n        if (this.privDisposeReason) {\n          throw new InvalidOperationError(this.privDisposeReason);\n        }\n\n        throw new ObjectDisposedError(\"Queue\");\n      } else if (this.privIsDisposing) {\n        throw new InvalidOperationError(\"Queue disposing\");\n      }\n    };\n\n    this.privList = list ? list : new List();\n    this.privDetachables = [];\n    this.privSubscribers = new List();\n    this.privDetachables.push(this.privList.onAdded(this.drain));\n  }\n\n  drainAndDispose(pendingItemProcessor, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isDisposed() && !this.privIsDisposing) {\n        this.privDisposeReason = reason;\n        this.privIsDisposing = true;\n        const subs = this.privSubscribers;\n\n        if (subs) {\n          while (subs.length() > 0) {\n            const subscriber = subs.removeFirst(); // TODO: this needs work (Resolve(null) instead?).\n\n            subscriber.deferral.resolve(undefined); // subscriber.deferral.reject(\"Disposed\");\n          } // note: this block assumes cooperative multitasking, i.e.,\n          // between the if-statement and the assignment there are no\n          // thread switches.\n          // Reason is that between the initial const = this.; and this\n          // point there is the derral.resolve() operation that might have\n          // caused recursive calls to the Queue, especially, calling\n          // Dispose() on the queue alredy (which would reset the var\n          // here to null!).\n          // That should generally hold true for javascript...\n\n\n          if (this.privSubscribers === subs) {\n            this.privSubscribers = subs;\n          }\n        }\n\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n\n        if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\n          const promiseArray = [];\n          this.privPromiseStore.toArray().forEach(wrapper => {\n            promiseArray.push(wrapper);\n          });\n          return Promise.all(promiseArray).finally(() => {\n            this.privSubscribers = null;\n            this.privList.forEach((item, index) => {\n              pendingItemProcessor(item);\n            });\n            this.privList = null;\n            return;\n          }).then();\n        } else {\n          this.privSubscribers = null;\n          this.privList = null;\n        }\n      }\n    });\n  }\n\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.drainAndDispose(null, reason);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["InvalidOperationError","ObjectDisposedError","List","Deferred","SubscriberType","Queue","constructor","list","item","throwIfDispose","enqueueFromPromise","Promise","resolve","reject","promise","then","val","privList","add","error","deferredSubscriber","privSubscribers","deferral","type","Dequeue","drain","subs","Peek","length","privIsDrainInProgress","privIsDisposing","lists","subscriber","removeFirst","first","dequeuedItem","isDisposed","privDisposeReason","privDetachables","push","onAdded","drainAndDispose","pendingItemProcessor","reason","undefined","detachable","detach","privPromiseStore","promiseArray","toArray","forEach","wrapper","all","finally","index","dispose"],"sources":["C:\\Users\\ozgur\\Documents\\VSCodeProjects\\webapp_educator\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common\\src\\common\\Queue.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError, ObjectDisposedError } from \"./Error\";\r\nimport { IDetachable } from \"./IDetachable\";\r\nimport { IDisposable } from \"./IDisposable\";\r\nimport { List } from \"./List\";\r\nimport {\r\n    Deferred,\r\n} from \"./Promise\";\r\nexport interface IQueue<TItem> extends IDisposable {\r\n    enqueue(item: TItem): void;\r\n    enqueueFromPromise(promise: Promise<TItem>): void;\r\n    dequeue(): Promise<TItem>;\r\n    peek(): Promise<TItem>;\r\n    length(): number;\r\n}\r\n\r\nenum SubscriberType {\r\n    Dequeue,\r\n    Peek,\r\n}\r\n\r\nexport class Queue<TItem> implements IQueue<TItem> {\r\n    private privPromiseStore: List<Promise<TItem>> = new List<Promise<TItem>>();\r\n    private privList: List<TItem>;\r\n    private privDetachables: IDetachable[];\r\n    private privSubscribers: List<{ type: SubscriberType, deferral: Deferred<TItem> }>;\r\n    private privIsDrainInProgress: boolean = false;\r\n    private privIsDisposing: boolean = false;\r\n    private privDisposeReason: string = null;\r\n\r\n    public constructor(list?: List<TItem>) {\r\n        this.privList = list ? list : new List<TItem>();\r\n        this.privDetachables = [];\r\n        this.privSubscribers = new List<{ type: SubscriberType, deferral: Deferred<TItem> }>();\r\n        this.privDetachables.push(this.privList.onAdded(this.drain));\r\n    }\r\n\r\n    public enqueue = (item: TItem): void => {\r\n        this.throwIfDispose();\r\n        this.enqueueFromPromise(new Promise<TItem>((resolve: (value: TItem) => void, reject: (reason: any) => void) => { resolve(item); }));\r\n    }\r\n\r\n    public enqueueFromPromise = (promise: Promise<TItem>): void => {\r\n        this.throwIfDispose();\r\n        promise.then((val: TItem): void => {\r\n            this.privList.add(val);\r\n             /* tslint:disable:no-empty */\r\n        }, (error: string): void => { });\r\n    }\r\n\r\n    public dequeue = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        if (this.privSubscribers) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Dequeue });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public peek = (): Promise<TItem> => {\r\n        this.throwIfDispose();\r\n        const deferredSubscriber = new Deferred<TItem>();\r\n\r\n        const subs = this.privSubscribers;\r\n        if (subs) {\r\n            this.privSubscribers.add({ deferral: deferredSubscriber, type: SubscriberType.Peek });\r\n            this.drain();\r\n        }\r\n\r\n        return deferredSubscriber.promise;\r\n    }\r\n\r\n    public length = (): number => {\r\n        this.throwIfDispose();\r\n        return this.privList.length();\r\n    }\r\n\r\n    public isDisposed = (): boolean => {\r\n        return this.privSubscribers == null;\r\n    }\r\n\r\n    public async drainAndDispose(pendingItemProcessor: (pendingItemInQueue: TItem) => void, reason?: string): Promise<void> {\r\n        if (!this.isDisposed() && !this.privIsDisposing) {\r\n            this.privDisposeReason = reason;\r\n            this.privIsDisposing = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            if (subs) {\r\n                while (subs.length() > 0) {\r\n                    const subscriber = subs.removeFirst();\r\n                    // TODO: this needs work (Resolve(null) instead?).\r\n                    subscriber.deferral.resolve(undefined);\r\n                    // subscriber.deferral.reject(\"Disposed\");\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n            }\r\n\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            if (this.privPromiseStore.length() > 0 && pendingItemProcessor) {\r\n                const promiseArray: Promise<TItem>[] = [];\r\n\r\n                this.privPromiseStore.toArray().forEach((wrapper: Promise<TItem>) => {\r\n                    promiseArray.push(wrapper);\r\n                });\r\n                return Promise.all(promiseArray).finally(() => {\r\n                    this.privSubscribers = null;\r\n                    this.privList.forEach((item: TItem, index: number): void => {\r\n                        pendingItemProcessor(item);\r\n                    });\r\n                    this.privList = null;\r\n                    return;\r\n                }).then<void>();\r\n            } else {\r\n                this.privSubscribers = null;\r\n                this.privList = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        await this.drainAndDispose(null, reason);\r\n    }\r\n\r\n    private drain = (): void => {\r\n        if (!this.privIsDrainInProgress && !this.privIsDisposing) {\r\n            this.privIsDrainInProgress = true;\r\n\r\n            const subs = this.privSubscribers;\r\n            const lists = this.privList;\r\n            if (subs && lists) {\r\n                while (lists.length() > 0 && subs.length() > 0 && !this.privIsDisposing) {\r\n                    const subscriber = subs.removeFirst();\r\n                    if (subscriber.type === SubscriberType.Peek) {\r\n                        subscriber.deferral.resolve(lists.first());\r\n                    } else {\r\n                        const dequeuedItem = lists.removeFirst();\r\n                        subscriber.deferral.resolve(dequeuedItem);\r\n                    }\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privSubscribers === subs) {\r\n                    this.privSubscribers = subs;\r\n                }\r\n\r\n                // note: this block assumes cooperative multitasking, i.e.,\r\n                // between the if-statement and the assignment there are no\r\n                // thread switches.\r\n                // Reason is that between the initial const = this.; and this\r\n                // point there is the derral.resolve() operation that might have\r\n                // caused recursive calls to the Queue, especially, calling\r\n                // Dispose() on the queue alredy (which would reset the var\r\n                // here to null!).\r\n                // That should generally hold true for javascript...\r\n                if (this.privList === lists) {\r\n                    this.privList = lists;\r\n                }\r\n            }\r\n\r\n            this.privIsDrainInProgress = false;\r\n        }\r\n    }\r\n\r\n    private throwIfDispose = (): void => {\r\n        if (this.isDisposed()) {\r\n            if (this.privDisposeReason) {\r\n                throw new InvalidOperationError(this.privDisposeReason);\r\n            }\r\n\r\n            throw new ObjectDisposedError(\"Queue\");\r\n        } else if (this.privIsDisposing) {\r\n            throw new InvalidOperationError(\"Queue disposing\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}