{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { ArgumentNullError, ConnectionMessage } from \"../common/Exports\";\nimport { HeaderNames } from \"./HeaderNames\";\nexport class SpeechConnectionMessage extends ConnectionMessage {\n  constructor(messageType, path, requestId, contentType, body, streamId, additionalHeaders, id) {\n    if (!path) {\n      throw new ArgumentNullError(\"path\");\n    }\n\n    if (!requestId) {\n      throw new ArgumentNullError(\"requestId\");\n    }\n\n    const headers = {};\n    headers[HeaderNames.Path] = path;\n    headers[HeaderNames.RequestId] = requestId;\n    headers[HeaderNames.RequestTimestamp] = new Date().toISOString();\n\n    if (contentType) {\n      headers[HeaderNames.ContentType] = contentType;\n    }\n\n    if (streamId) {\n      headers[HeaderNames.RequestStreamId] = streamId;\n    }\n\n    if (additionalHeaders) {\n      for (const headerName in additionalHeaders) {\n        if (headerName) {\n          headers[headerName] = additionalHeaders[headerName];\n        }\n      }\n    }\n\n    if (id) {\n      super(messageType, body, headers, id);\n    } else {\n      super(messageType, body, headers);\n    }\n\n    this.privPath = path;\n    this.privRequestId = requestId;\n    this.privContentType = contentType;\n    this.privStreamId = streamId;\n    this.privAdditionalHeaders = additionalHeaders;\n  }\n\n  get path() {\n    return this.privPath;\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get contentType() {\n    return this.privContentType;\n  }\n\n  get streamId() {\n    return this.privStreamId;\n  }\n\n  get additionalHeaders() {\n    return this.privAdditionalHeaders;\n  }\n\n}\n\nSpeechConnectionMessage.fromConnectionMessage = message => {\n  let path = null;\n  let requestId = null;\n  let contentType = null;\n  let requestTimestamp = null;\n  let streamId = null;\n  const additionalHeaders = {};\n\n  if (message.headers) {\n    for (const headerName in message.headers) {\n      if (headerName) {\n        if (headerName.toLowerCase() === HeaderNames.Path.toLowerCase()) {\n          path = message.headers[headerName];\n        } else if (headerName.toLowerCase() === HeaderNames.RequestId.toLowerCase()) {\n          requestId = message.headers[headerName];\n        } else if (headerName.toLowerCase() === HeaderNames.RequestTimestamp.toLowerCase()) {\n          requestTimestamp = message.headers[headerName];\n        } else if (headerName.toLowerCase() === HeaderNames.ContentType.toLowerCase()) {\n          contentType = message.headers[headerName];\n        } else if (headerName.toLowerCase() === HeaderNames.RequestStreamId.toLowerCase()) {\n          streamId = message.headers[headerName];\n        } else {\n          additionalHeaders[headerName] = message.headers[headerName];\n        }\n      }\n    }\n  }\n\n  return new SpeechConnectionMessage(message.messageType, path, requestId, contentType, message.body, streamId, additionalHeaders, message.id);\n};","map":{"version":3,"mappings":"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","names":["ArgumentNullError","ConnectionMessage","HeaderNames","SpeechConnectionMessage","constructor","messageType","path","requestId","contentType","body","streamId","additionalHeaders","id","headers","Path","RequestId","RequestTimestamp","Date","toISOString","ContentType","RequestStreamId","headerName","privPath","privRequestId","privContentType","privStreamId","privAdditionalHeaders","message","requestTimestamp","toLowerCase"],"sources":["C:\\Users\\ozgur\\Documents\\VSCodeProjects\\webapp_educator\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\SpeechConnectionMessage.Internal.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ArgumentNullError, ConnectionMessage, IStringDictionary, MessageType } from \"../common/Exports\";\r\nimport { HeaderNames } from \"./HeaderNames\";\r\n\r\nexport class SpeechConnectionMessage extends ConnectionMessage {\r\n\r\n    private privPath: string;\r\n    private privRequestId: string;\r\n    private privContentType: string;\r\n    private privStreamId: string;\r\n    private privAdditionalHeaders: IStringDictionary<string>;\r\n\r\n    public constructor(\r\n        messageType: MessageType,\r\n        path: string,\r\n        requestId: string,\r\n        contentType: string,\r\n        body: any,\r\n        streamId?: string,\r\n        additionalHeaders?: IStringDictionary<string>,\r\n        id?: string) {\r\n\r\n        if (!path) {\r\n            throw new ArgumentNullError(\"path\");\r\n        }\r\n\r\n        if (!requestId) {\r\n            throw new ArgumentNullError(\"requestId\");\r\n        }\r\n\r\n        const headers: IStringDictionary<string> = {};\r\n        headers[HeaderNames.Path] = path;\r\n        headers[HeaderNames.RequestId] = requestId;\r\n        headers[HeaderNames.RequestTimestamp] = new Date().toISOString();\r\n        if (contentType) {\r\n            headers[HeaderNames.ContentType] = contentType;\r\n        }\r\n\r\n        if (streamId) {\r\n            headers[HeaderNames.RequestStreamId] = streamId;\r\n        }\r\n\r\n        if (additionalHeaders) {\r\n            for (const headerName in additionalHeaders) {\r\n                if (headerName) {\r\n                    headers[headerName] = additionalHeaders[headerName];\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        if (id) {\r\n            super(messageType, body, headers, id);\r\n        } else {\r\n            super(messageType, body, headers);\r\n        }\r\n\r\n        this.privPath = path;\r\n        this.privRequestId = requestId;\r\n        this.privContentType = contentType;\r\n        this.privStreamId = streamId;\r\n        this.privAdditionalHeaders = additionalHeaders;\r\n    }\r\n\r\n    public get path(): string {\r\n        return this.privPath;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get contentType(): string {\r\n        return this.privContentType;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public get additionalHeaders(): IStringDictionary<string> {\r\n        return this.privAdditionalHeaders;\r\n    }\r\n\r\n    public static fromConnectionMessage = (message: ConnectionMessage): SpeechConnectionMessage => {\r\n        let path = null;\r\n        let requestId = null;\r\n        let contentType = null;\r\n        let requestTimestamp = null;\r\n        let streamId = null;\r\n        const additionalHeaders: IStringDictionary<string> = {};\r\n\r\n        if (message.headers) {\r\n            for (const headerName in message.headers) {\r\n                if (headerName) {\r\n                    if (headerName.toLowerCase() === HeaderNames.Path.toLowerCase()) {\r\n                        path = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestId.toLowerCase()) {\r\n                        requestId = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestTimestamp.toLowerCase()) {\r\n                        requestTimestamp = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.ContentType.toLowerCase()) {\r\n                        contentType = message.headers[headerName];\r\n                    } else if (headerName.toLowerCase() === HeaderNames.RequestStreamId.toLowerCase()) {\r\n                        streamId = message.headers[headerName];\r\n                    } else {\r\n                        additionalHeaders[headerName] = message.headers[headerName];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return new SpeechConnectionMessage(\r\n            message.messageType,\r\n            path,\r\n            requestId,\r\n            contentType,\r\n            message.body,\r\n            streamId,\r\n            additionalHeaders,\r\n            message.id);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}