{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ConversationConnectionConfig, ConversationManager, ConversationRecognizerFactory, ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes, InternalParticipants } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { ConversationParticipantsChangedEventArgs, ConversationTranslationEventArgs, Participant, ParticipantChangedReason, ProfanityOption, PropertyCollection, PropertyId } from \"../Exports\";\nexport class Conversation {\n  constructor() {}\n  /**\r\n   * Create a conversation\r\n   * @param speechConfig\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  static createConversationAsync(speechConfig, arg2, arg3, arg4) {\n    Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\n    Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\n\n    if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\n      Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\n    }\n\n    let conversationImpl;\n    let cb;\n    let err;\n\n    if (typeof arg2 === \"string\") {\n      conversationImpl = new ConversationImpl(speechConfig, arg2);\n      cb = arg3;\n      err = arg4;\n    } else {\n      conversationImpl = new ConversationImpl(speechConfig);\n      cb = arg2;\n      err = arg3;\n    }\n\n    conversationImpl.createConversationAsync(() => {\n      if (!!cb) {\n        cb();\n      }\n    }, error => {\n      if (!!err) {\n        err(error);\n      }\n    });\n    return conversationImpl;\n  }\n\n} // tslint:disable-next-line:max-classes-per-file\n\nexport class ConversationImpl extends Conversation {\n  /**\r\n   * Create a conversation impl\r\n   * @param speechConfig\r\n   * @param {string} id - optional conversationId\r\n   */\n  constructor(speechConfig, id) {\n    super();\n    this.privIsDisposed = false;\n    this.privIsConnected = false;\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privConversationId = \"\";\n    /** websocket callbacks */\n\n    this.onConnected = e => {\n      var _a, _b;\n\n      this.privIsConnected = true;\n\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStarted)) {\n          this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\n        }\n\n        if (!!((_b = this.privTranscriberRecognizer) === null || _b === void 0 ? void 0 : _b.conversationStarted)) {\n          this.privTranscriberRecognizer.conversationStarted(this.privTranscriberRecognizer, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onDisconnected = e => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.sessionStopped)) {\n          this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\n        }\n\n        if (!!((_b = this.privTranscriberRecognizer) === null || _b === void 0 ? void 0 : _b.conversationStopped)) {\n          this.privTranscriberRecognizer.conversationStopped(this.privTranscriberRecognizer, e);\n        }\n      } catch (e) {//\n      } finally {\n        yield this.close(false);\n      }\n    });\n\n    this.onCanceled = (r, e) => __awaiter(this, void 0, void 0, function* () {\n      var _c, _d;\n\n      try {\n        if (!!((_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.canceled)) {\n          this.privConversationTranslator.canceled(this.privConversationTranslator, e);\n        }\n\n        if (!!((_d = this.privTranscriberRecognizer) === null || _d === void 0 ? void 0 : _d.conversationCanceled)) {\n          this.privTranscriberRecognizer.conversationCanceled(this.privTranscriberRecognizer, e);\n        }\n      } catch (e) {//\n      }\n    });\n\n    this.onParticipantUpdateCommandReceived = (r, e) => {\n      var _a, _b;\n\n      try {\n        const updatedParticipant = this.privParticipants.getParticipant(e.id);\n\n        if (updatedParticipant !== undefined) {\n          switch (e.key) {\n            case ConversationTranslatorCommandTypes.changeNickname:\n              updatedParticipant.displayName = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setUseTTS:\n              updatedParticipant.useTts = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setProfanityFiltering:\n              updatedParticipant.profanity = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setMute:\n              updatedParticipant.isMuted = e.value;\n              break;\n\n            case ConversationTranslatorCommandTypes.setTranslateToLanguages:\n              updatedParticipant.translateToLanguages = e.value;\n              break;\n          }\n\n          this.privParticipants.addOrUpdateParticipant(updatedParticipant);\n\n          if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, [this.toParticipant(updatedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onLockRoomCommandReceived = (r, e) => {// TODO\n    };\n\n    this.onMuteAllCommandReceived = (r, e) => {\n      var _a, _b;\n\n      try {\n        this.privParticipants.participants.forEach(p => p.isMuted = p.isHost ? false : e.isMuted);\n\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n          (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated, this.toParticipants(false), e.sessionId));\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onParticipantJoinCommandReceived = (r, e) => {\n      var _a, _b;\n\n      try {\n        const newParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\n\n        if (newParticipant !== undefined) {\n          if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, [this.toParticipant(newParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onParticipantLeaveCommandReceived = (r, e) => {\n      var _a, _b;\n\n      try {\n        const ejectedParticipant = this.privParticipants.getParticipant(e.participant.id);\n\n        if (ejectedParticipant !== undefined) {\n          // remove the participant from the internal participants list\n          this.privParticipants.deleteParticipant(e.participant.id);\n\n          if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n            // notify subscribers that the participant has left the conversation\n            (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation, [this.toParticipant(ejectedParticipant)], e.sessionId));\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onTranslationReceived = (r, e) => {\n      var _a, _b, _c, _d, _e, _f;\n\n      try {\n        switch (e.command) {\n          case ConversationTranslatorMessageTypes.final:\n            if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.transcribed)) {\n              (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.transcribed(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n\n          case ConversationTranslatorMessageTypes.partial:\n            if (!!((_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.transcribing)) {\n              (_d = this.privConversationTranslator) === null || _d === void 0 ? void 0 : _d.transcribing(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n\n          case ConversationTranslatorMessageTypes.instantMessage:\n            if (!!((_e = this.privConversationTranslator) === null || _e === void 0 ? void 0 : _e.textMessageReceived)) {\n              (_f = this.privConversationTranslator) === null || _f === void 0 ? void 0 : _f.textMessageReceived(this.privConversationTranslator, new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\n            }\n\n            break;\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onParticipantsListReceived = (r, e) => {\n      var _a, _b, _c;\n\n      try {\n        // check if the session token needs to be updated\n        if (e.sessionToken !== undefined && e.sessionToken !== null) {\n          this.privRoom.token = e.sessionToken;\n        } // save the participants\n\n\n        this.privParticipants.participants = [...e.participants]; // enable the conversation\n\n        if (this.privParticipants.me !== undefined) {\n          this.privIsReady = true;\n        }\n\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.participantsChanged)) {\n          (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.participantsChanged(this.privConversationTranslator, new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\n        } // if this is the host, update the nickname if needed\n\n\n        if (this.me.isHost) {\n          const nickname = (_c = this.privConversationTranslator) === null || _c === void 0 ? void 0 : _c.properties.getProperty(PropertyId.ConversationTranslator_Name);\n\n          if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\n            // issue a change nickname request\n            this.changeNicknameAsync(nickname);\n          }\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.onConversationExpiration = (r, e) => {\n      var _a, _b;\n\n      try {\n        if (!!((_a = this.privConversationTranslator) === null || _a === void 0 ? void 0 : _a.conversationExpiration)) {\n          (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.conversationExpiration(this.privConversationTranslator, e);\n        }\n      } catch (e) {//\n      }\n    };\n\n    this.privProperties = new PropertyCollection();\n    this.privManager = new ConversationManager(); // check the speech language\n\n    const language = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n\n    if (!language) {\n      speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\n    }\n\n    this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\n\n    if (!id) {\n      // check the target language(s)\n      if (speechConfig.targetLanguages.length === 0) {\n        speechConfig.addTargetLanguage(this.privLanguage);\n      } // check the profanity setting: speech and conversationTranslator should be in sync\n\n\n      const profanity = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\n\n      if (!profanity) {\n        speechConfig.setProfanity(ProfanityOption.Masked);\n      } // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\n      // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\n      // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\n\n\n      let hostNickname = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\n\n      if (hostNickname === undefined || hostNickname === null || hostNickname.length <= 1 || hostNickname.length > 50) {\n        hostNickname = \"Host\";\n      }\n\n      speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\n    } else {\n      this.privConversationId = id;\n    } // save the speech config for future usage\n\n\n    this.privConfig = speechConfig; // save the config properties\n\n    const configImpl = speechConfig;\n    Contracts.throwIfNull(configImpl, \"speechConfig\");\n    this.privProperties = configImpl.properties.clone();\n    this.privIsConnected = false;\n    this.privParticipants = new InternalParticipants();\n    this.privIsReady = false;\n    this.privTextMessageMaxLength = 1000;\n  }\n\n  set conversationTranslator(conversationTranslator) {\n    this.privConversationTranslator = conversationTranslator;\n  } // get the internal data about a conversation\n\n\n  get room() {\n    return this.privRoom;\n  } // get the wrapper for connecting to the websockets\n\n\n  get connection() {\n    return this.privConversationRecognizer; // this.privConnection;\n  } // get / set the speech auth token\n\n\n  get authorizationToken() {\n    return this.privToken;\n  }\n\n  set authorizationToken(value) {\n    Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\n    this.privToken = value;\n  } // get the config\n\n\n  get config() {\n    return this.privConfig;\n  } // get the conversation Id\n\n\n  get conversationId() {\n    return this.privRoom ? this.privRoom.roomId : this.privConversationId;\n  } // get the properties\n\n\n  get properties() {\n    return this.privProperties;\n  } // get the speech language\n\n\n  get speechRecognitionLanguage() {\n    return this.privLanguage;\n  }\n\n  get isMutedByHost() {\n    var _a, _b;\n\n    return ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost) ? false : (_b = this.privParticipants.me) === null || _b === void 0 ? void 0 : _b.isMuted;\n  }\n\n  get isConnected() {\n    return this.privIsConnected && this.privIsReady;\n  }\n\n  get participants() {\n    return this.toParticipants(true);\n  }\n\n  get me() {\n    return this.toParticipant(this.privParticipants.me);\n  }\n\n  get host() {\n    return this.toParticipant(this.privParticipants.host);\n  }\n  /**\r\n   * Create a new conversation as Host\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  createConversationAsync(cb, err) {\n    try {\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      }\n\n      this.privManager.createOrJoin(this.privProperties, undefined, room => {\n        if (!room) {\n          this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\n        }\n\n        this.privRoom = room;\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Starts a new conversation as host.\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  startConversationAsync(cb, err) {\n    try {\n      // check if there is already a recognizer\n      if (!!this.privConversationRecognizer) {\n        this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\n      } // check if there is conversation data available\n\n\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect); // connect to the conversation websocket\n\n      this.privParticipants.meId = this.privRoom.participantId;\n      this.privConversationRecognizer = ConversationRecognizerFactory.fromConfig(this, this.privConfig); // Because ConversationTranslator manually sets up and manages the connection, Conversation\n      // has to forward serviceRecognizer connection events that usually get passed automatically\n\n      this.privConversationRecognizer.connected = this.onConnected;\n      this.privConversationRecognizer.disconnected = this.onDisconnected;\n      this.privConversationRecognizer.canceled = this.onCanceled;\n      this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\n      this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\n      this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\n      this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\n      this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\n      this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\n      this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\n      this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\n      this.privConversationRecognizer.connect(this.privRoom.token, () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Join a conversation as a participant.\r\n   * @param { IParticipant } participant - participant to add\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  addParticipantAsync(participant, cb, err) {\n    Contracts.throwIfNullOrUndefined(participant, \"Participant\");\n    marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\n  }\n  /**\r\n   * Join a conversation as a participant.\r\n   * @param conversation\r\n   * @param nickname\r\n   * @param lang\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  joinConversationAsync(conversationId, nickname, lang, cb, err) {\n    try {\n      // TODO\n      // if (!!this.privConversationRecognizer) {\n      //     throw new Error(this.privErrors.permissionDeniedStart);\n      // }\n      Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\n      Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\")); // join the conversation\n\n      this.privManager.createOrJoin(this.privProperties, conversationId, room => {\n        Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\n        this.privRoom = room;\n        this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken; // join callback\n\n        if (!!cb) {\n          cb(room.cognitiveSpeechAuthToken);\n        }\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Deletes a conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  deleteConversationAsync(cb, err) {\n    marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);\n  }\n\n  deleteConversationImplAsync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\n      Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\n      yield this.privManager.leave(this.privProperties, this.privRoom.token);\n      this.dispose();\n    });\n  }\n  /**\r\n   * Issues a request to close the client websockets\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  endConversationAsync(cb, err) {\n    marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);\n  }\n\n  endConversationImplAsync() {\n    return this.close(true);\n  }\n  /**\r\n   * Issues a request to lock the conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  lockConversationAsync(cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getLockCommand(true), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to mute the conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  muteAllParticipantsAsync(cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the user's permissions\n\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteAllCommand(true), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to mute a participant in the conversation\r\n   * @param userId\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  muteParticipantAsync(userId, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the connection is open (host + participant can perform the mute command)\n\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      } // if not host, check the participant is not muting another participant\n\n\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      } // check the user exists\n\n\n      const exists = this.privParticipants.getParticipantIndex(userId);\n\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteCommand(userId, true), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to remove a participant from the conversation\r\n   * @param userId\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  removeParticipantAsync(userId, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n\n      if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\n        // Assume this is a transcription participant\n        marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId), cb, err);\n      } else {\n        Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n        Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSendAsHost) {\n          this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\n        }\n\n        let participantId = \"\";\n\n        if (typeof userId === \"string\") {\n          participantId = userId;\n        } else if (userId.hasOwnProperty(\"id\")) {\n          const participant = userId;\n          participantId = participant.id;\n        } else if (userId.hasOwnProperty(\"userId\")) {\n          const user = userId;\n          participantId = user.userId;\n        }\n\n        Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\")); // check the participant exists\n\n        const index = this.participants.findIndex(p => p.id === participantId);\n\n        if (index === -1) {\n          this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n        }\n\n        (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getEjectCommand(participantId), () => {\n          this.handleCallback(cb, err);\n        }, error => {\n          this.handleError(error, err);\n        });\n      }\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to unlock the conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  unlockConversationAsync(cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getLockCommand(false), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to unmute all participants in the conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  unmuteAllParticipantsAsync(cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n      if (!this.canSendAsHost) {\n        this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteAllCommand(false), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Issues a request to unmute a participant in the conversation\r\n   * @param userId\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  unmuteParticipantAsync(userId, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend); // check the connection is open (host + participant can perform the mute command)\n\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      } // if not host, check the participant is not muting another participant\n\n\n      if (!this.me.isHost && this.me.id !== userId) {\n        this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\n      } // check the user exists\n\n\n      const exists = this.privParticipants.getParticipantIndex(userId);\n\n      if (exists === -1) {\n        this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMuteCommand(userId, false), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Send a text message\r\n   * @param message\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  sendTextMessageAsync(message, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      } // TODO: is a max length check required?\n\n\n      if (message.length > this.privTextMessageMaxLength) {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getMessageCommand(message), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Change nickname\r\n   * @param message\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  changeNicknameAsync(nickname, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfDisposed(this.privIsDisposed);\n      Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\n      Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n      Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\n\n      if (!this.canSend) {\n        this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n      }\n\n      (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.sendRequest(this.getChangeNicknameCommand(nickname), () => {\n        this.handleCallback(cb, err);\n      }, error => {\n        this.handleError(error, err);\n      });\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason) {\n    var _a;\n\n    if (this.isDisposed) {\n      return;\n    }\n\n    this.privIsDisposed = true;\n    (_a = this.config) === null || _a === void 0 ? void 0 : _a.close();\n    this.privConfig = undefined;\n    this.privLanguage = undefined;\n    this.privProperties = undefined;\n    this.privRoom = undefined;\n    this.privToken = undefined;\n    this.privManager = undefined;\n    this.privIsConnected = false;\n    this.privIsReady = false;\n    this.privParticipants = undefined;\n  }\n\n  get transcriberRecognizer() {\n    return this.privTranscriberRecognizer;\n  }\n\n  connectTranscriberRecognizer(recognizer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privTranscriberRecognizer) {\n        yield this.privTranscriberRecognizer.close();\n      }\n\n      this.privTranscriberRecognizer = recognizer;\n      this.privTranscriberRecognizer.conversation = this;\n    });\n  }\n\n  get conversationInfo() {\n    const convId = this.conversationId;\n    const p = this.participants.map(part => {\n      return {\n        id: part.id,\n        preferredLanguage: part.preferredLanguage,\n        voice: part.voice\n      };\n    });\n    const props = {};\n\n    for (const key of ConversationConnectionConfig.transcriptionEventKeys) {\n      const val = this.properties.getProperty(key, \"\");\n\n      if (val !== \"\") {\n        props[key] = val;\n      }\n    }\n\n    const info = {\n      id: convId,\n      participants: p,\n      conversationProperties: props\n    };\n    return info;\n  }\n\n  getKeepAlive() {\n    const nickname = !!this.me ? this.me.displayName : \"default_nickname\";\n    return JSON.stringify({\n      // tslint:disable-next-line: object-literal-shorthand\n      id: \"0\",\n      nickname,\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.keepAlive\n    });\n  }\n\n  addParticipantImplAsync(participant) {\n    const newParticipant = this.privParticipants.addOrUpdateParticipant(participant);\n\n    if (newParticipant !== undefined) {\n      if (!!this.privTranscriberRecognizer) {\n        const conversationInfo = this.conversationInfo;\n        conversationInfo.participants = [participant];\n        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"join\");\n      }\n    }\n  }\n\n  removeParticipantImplAsync(participant) {\n    this.privParticipants.deleteParticipant(participant.id);\n    const conversationInfo = this.conversationInfo;\n    conversationInfo.participants = [participant];\n    return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"leave\");\n  }\n\n  close(dispose) {\n    var _a, _b;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsConnected = false;\n        yield (_a = this.privConversationRecognizer) === null || _a === void 0 ? void 0 : _a.close();\n        this.privConversationRecognizer = undefined;\n        (_b = this.privConversationTranslator) === null || _b === void 0 ? void 0 : _b.dispose();\n      } catch (e) {\n        // ignore error\n        throw e;\n      }\n\n      if (dispose) {\n        this.dispose();\n      }\n    });\n  }\n  /** Helpers */\n\n\n  get canSend() {\n    var _a;\n\n    return this.privIsConnected && !((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isMuted);\n  }\n\n  get canSendAsHost() {\n    var _a;\n\n    return this.privIsConnected && ((_a = this.privParticipants.me) === null || _a === void 0 ? void 0 : _a.isHost);\n  }\n\n  handleCallback(cb, err) {\n    if (!!cb) {\n      try {\n        cb();\n      } catch (e) {\n        if (!!err) {\n          err(e);\n        }\n      }\n\n      cb = undefined;\n    }\n  }\n\n  handleError(error, err) {\n    if (!!err) {\n      if (error instanceof Error) {\n        const typedError = error;\n        err(typedError.name + \": \" + typedError.message);\n      } else {\n        err(error);\n      }\n    }\n  }\n  /** Participant Helpers */\n\n\n  toParticipants(includeHost) {\n    const participants = this.privParticipants.participants.map(p => {\n      return this.toParticipant(p);\n    });\n\n    if (!includeHost) {\n      return participants.filter(p => p.isHost === false);\n    } else {\n      return participants;\n    }\n  }\n\n  toParticipant(p) {\n    return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\n  }\n\n  getMuteAllCommand(isMuted) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setMuteAll,\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n\n  getMuteCommand(participantId, isMuted) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setMute,\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isMuted\n    });\n  }\n\n  getLockCommand(isLocked) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.setLockState,\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: isLocked\n    });\n  }\n\n  getEjectCommand(participantId) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.ejectParticipant,\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand\n    });\n  }\n\n  getChangeNicknameCommand(nickname) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    return JSON.stringify({\n      command: ConversationTranslatorCommandTypes.changeNickname,\n      nickname,\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: this.privRoom.participantId,\n      roomid: this.privRoom.roomId,\n      type: ConversationTranslatorMessageTypes.participantCommand,\n      value: nickname\n    });\n  }\n\n  getMessageCommand(message) {\n    Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\n    Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\n    Contracts.throwIfNullOrWhitespace(message, \"message\");\n    return JSON.stringify({\n      // tslint:disable-next-line: object-literal-shorthand\n      participantId: this.privRoom.participantId,\n      roomId: this.privRoom.roomId,\n      text: message,\n      type: ConversationTranslatorMessageTypes.instantMessage\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ConversationConnectionConfig","ConversationManager","ConversationRecognizerFactory","ConversationTranslatorCommandTypes","ConversationTranslatorMessageTypes","InternalParticipants","marshalPromiseToCallbacks","Contracts","ConversationParticipantsChangedEventArgs","ConversationTranslationEventArgs","Participant","ParticipantChangedReason","ProfanityOption","PropertyCollection","PropertyId","Conversation","constructor","createConversationAsync","speechConfig","arg2","arg3","arg4","throwIfNullOrUndefined","restErrors","invalidArgs","replace","region","subscriptionKey","getProperty","SpeechServiceAuthorization_Token","conversationImpl","cb","err","ConversationImpl","error","id","e","privIsConnected","privConversationTranslator","_a","sessionStarted","privTranscriberRecognizer","_b","conversationStarted","__awaiter","sessionStopped","conversationStopped","close","r","_c","canceled","_d","conversationCanceled","updatedParticipant","privParticipants","getParticipant","undefined","key","changeNickname","displayName","value","setUseTTS","useTts","setProfanityFiltering","profanity","setMute","isMuted","setTranslateToLanguages","translateToLanguages","addOrUpdateParticipant","participantsChanged","Updated","toParticipant","sessionId","participants","forEach","p","isHost","toParticipants","newParticipant","participant","JoinedConversation","ejectedParticipant","deleteParticipant","LeftConversation","command","final","transcribed","payload","partial","transcribing","instantMessage","_e","textMessageReceived","_f","sessionToken","privRoom","token","me","privIsReady","nickname","properties","ConversationTranslator_Name","length","changeNicknameAsync","conversationExpiration","privProperties","privManager","language","SpeechServiceConnection_RecoLanguage","setProperty","defaultLanguageCode","privLanguage","targetLanguages","addTargetLanguage","SpeechServiceResponse_ProfanityOption","setProfanity","Masked","hostNickname","privConversationId","privConfig","configImpl","throwIfNull","clone","privTextMessageMaxLength","conversationTranslator","room","connection","privConversationRecognizer","authorizationToken","privToken","throwIfNullOrWhitespace","config","conversationId","roomId","speechRecognitionLanguage","isMutedByHost","isConnected","host","handleError","Error","privErrors","permissionDeniedStart","createOrJoin","permissionDeniedConnect","handleCallback","startConversationAsync","meId","participantId","fromConfig","connected","onConnected","disconnected","onDisconnected","onCanceled","participantUpdateCommandReceived","onParticipantUpdateCommandReceived","lockRoomCommandReceived","onLockRoomCommandReceived","muteAllCommandReceived","onMuteAllCommandReceived","participantJoinCommandReceived","onParticipantJoinCommandReceived","participantLeaveCommandReceived","onParticipantLeaveCommandReceived","translationReceived","onTranslationReceived","participantsListReceived","onParticipantsListReceived","onConversationExpiration","connect","addParticipantAsync","addParticipantImplAsync","joinConversationAsync","lang","cognitiveSpeechAuthToken","deleteConversationAsync","deleteConversationImplAsync","leave","dispose","endConversationAsync","endConversationImplAsync","lockConversationAsync","throwIfDisposed","privIsDisposed","isDisposed","permissionDeniedSend","canSendAsHost","permissionDeniedConversation","sendRequest","getLockCommand","muteAllParticipantsAsync","getMuteAllCommand","muteParticipantAsync","userId","canSend","permissionDeniedParticipant","exists","getParticipantIndex","invalidParticipantRequest","getMuteCommand","removeParticipantAsync","hasOwnProperty","removeParticipantImplAsync","user","index","findIndex","getEjectCommand","unlockConversationAsync","unmuteAllParticipantsAsync","unmuteParticipantAsync","sendTextMessageAsync","message","getMessageCommand","getChangeNicknameCommand","reason","transcriberRecognizer","connectTranscriberRecognizer","recognizer","conversation","conversationInfo","convId","map","part","preferredLanguage","voice","props","transcriptionEventKeys","val","info","conversationProperties","getKeepAlive","JSON","stringify","type","keepAlive","pushConversationEvent","typedError","name","includeHost","filter","avatar","isUsingTts","setMuteAll","roomid","participantCommand","isLocked","setLockState","ejectParticipant","text"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\sdk\\Transcription\\src\\sdk\\Transcription\\Conversation.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\nimport {\r\n    ConversationConnectionConfig,\r\n    ConversationManager,\r\n    ConversationReceivedTranslationEventArgs,\r\n    ConversationRecognizer,\r\n    ConversationRecognizerFactory,\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalConversation,\r\n    IInternalParticipant,\r\n    InternalParticipants,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs,\r\n    TranscriberRecognizer\r\n} from \"../../common.speech/Exports\";\r\nimport {\r\n    IDisposable,\r\n    IErrorMessages,\r\n    marshalPromiseToCallbacks\r\n} from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    Connection,\r\n    ConnectionEventArgs,\r\n    ConversationExpirationEventArgs,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    ConversationTranslator,\r\n    Participant,\r\n    ParticipantChangedReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SpeechTranslationConfig,\r\n} from \"../Exports\";\r\nimport { SpeechTranslationConfigImpl } from \"../SpeechTranslationConfig\";\r\nimport { Callback, ConversationInfo, IConversation } from \"./IConversation\";\r\nimport { IParticipant, IUser, TranscriptionParticipant } from \"./IParticipant\";\r\n\r\nexport abstract class Conversation implements IConversation {\r\n\r\n    public abstract get authorizationToken(): string;\r\n    public abstract set authorizationToken(value: string);\r\n\r\n    public abstract get config(): SpeechTranslationConfig;\r\n\r\n    public abstract get conversationId(): string;\r\n    public abstract get conversationInfo(): ConversationInfo;\r\n    public abstract get properties(): PropertyCollection;\r\n    public abstract get speechRecognitionLanguage(): string;\r\n    public abstract get participants(): Participant[];\r\n    public abstract get isConnected(): boolean;\r\n\r\n    protected constructor() { }\r\n\r\n    /**\r\n     * Create a conversation\r\n     * @param speechConfig\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public static createConversationAsync(speechConfig: SpeechTranslationConfig, arg2?: string | Callback, arg3?: Callback, arg4?: Callback): Conversation {\r\n        Contracts.throwIfNullOrUndefined(speechConfig, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"config\"));\r\n        Contracts.throwIfNullOrUndefined(speechConfig.region, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Region\"));\r\n        if (!speechConfig.subscriptionKey && !speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceAuthorization_Token])) {\r\n            Contracts.throwIfNullOrUndefined(speechConfig.subscriptionKey, ConversationConnectionConfig.restErrors.invalidArgs.replace(\"{arg}\", \"SpeechServiceConnection_Key\"));\r\n        }\r\n        let conversationImpl: ConversationImpl;\r\n        let cb: Callback;\r\n        let err: Callback;\r\n        if (typeof arg2 === \"string\") {\r\n            conversationImpl = new ConversationImpl(speechConfig, arg2);\r\n            cb = arg3;\r\n            err = arg4;\r\n        } else {\r\n            conversationImpl = new ConversationImpl(speechConfig);\r\n            cb = arg2;\r\n            err = arg3;\r\n        }\r\n        conversationImpl.createConversationAsync(\r\n            (() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }),\r\n            (error: any) => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        return conversationImpl;\r\n\r\n    }\r\n\r\n    /** Start a conversation. */\r\n    public abstract startConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Delete a conversation. After this no one will be able to join the conversation. */\r\n    public abstract deleteConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** End a conversation. */\r\n    public abstract endConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Lock a conversation. This will prevent new participants from joining. */\r\n    public abstract lockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Add Participant to Conversation. */\r\n    public abstract addParticipantAsync(participant: IParticipant, cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute all other participants in the conversation. After this no other participants will\r\n     * have their speech recognitions broadcast, nor be able to send text messages.\r\n     */\r\n    public abstract muteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Mute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Remove a participant from a conversation using the user id, Participant or User object\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unlocks a conversation. */\r\n    public abstract unlockConversationAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /** Unmute all other participants in the conversation. */\r\n    public abstract unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void;\r\n\r\n    /**\r\n     * Unmute a participant.\r\n     * @param userId A user identifier\r\n     */\r\n    public abstract unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void;\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class ConversationImpl extends Conversation implements IDisposable {\r\n\r\n    private privConfig: SpeechTranslationConfig;\r\n    private privProperties: PropertyCollection;\r\n    private privLanguage: string;\r\n    private privToken: string;\r\n    private privIsDisposed: boolean = false;\r\n    private privRoom: IInternalConversation;\r\n    private privManager: ConversationManager;\r\n    private privConversationRecognizer: ConversationRecognizer;\r\n    private privIsConnected: boolean = false;\r\n    private privParticipants: InternalParticipants;\r\n    private privIsReady: boolean;\r\n    private privConversationTranslator: ConversationTranslator;\r\n    private privTranscriberRecognizer: TranscriberRecognizer;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privConversationId: string = \"\";\r\n    private readonly privTextMessageMaxLength: number;\r\n\r\n    public set conversationTranslator(conversationTranslator: ConversationTranslator) {\r\n        this.privConversationTranslator = conversationTranslator;\r\n    }\r\n\r\n    // get the internal data about a conversation\r\n    public get room(): IInternalConversation {\r\n        return this.privRoom;\r\n    }\r\n\r\n    // get the wrapper for connecting to the websockets\r\n    public get connection(): ConversationRecognizer {\r\n        return this.privConversationRecognizer; // this.privConnection;\r\n    }\r\n\r\n    // get / set the speech auth token\r\n    public get authorizationToken(): string {\r\n        return this.privToken;\r\n    }\r\n\r\n    public set authorizationToken(value: string) {\r\n        Contracts.throwIfNullOrWhitespace(value, \"authorizationToken\");\r\n        this.privToken = value;\r\n    }\r\n\r\n    // get the config\r\n    public get config(): SpeechTranslationConfig {\r\n        return this.privConfig;\r\n    }\r\n\r\n    // get the conversation Id\r\n    public get conversationId(): string {\r\n        return this.privRoom ? this.privRoom.roomId : this.privConversationId;\r\n    }\r\n\r\n    // get the properties\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    // get the speech language\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privLanguage;\r\n    }\r\n\r\n    public get isMutedByHost(): boolean {\r\n        return this.privParticipants.me?.isHost ? false : this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    public get isConnected(): boolean {\r\n        return this.privIsConnected && this.privIsReady;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.toParticipants(true);\r\n    }\r\n\r\n    public get me(): Participant {\r\n        return this.toParticipant(this.privParticipants.me);\r\n    }\r\n\r\n    public get host(): Participant {\r\n        return this.toParticipant(this.privParticipants.host);\r\n    }\r\n\r\n    /**\r\n     * Create a conversation impl\r\n     * @param speechConfig\r\n     * @param {string} id - optional conversationId\r\n     */\r\n    public constructor(speechConfig: SpeechTranslationConfig, id?: string) {\r\n        super();\r\n        this.privProperties = new PropertyCollection();\r\n        this.privManager = new ConversationManager();\r\n\r\n        // check the speech language\r\n        const language: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n        if (!language) {\r\n            speechConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], ConversationConnectionConfig.defaultLanguageCode);\r\n        }\r\n        this.privLanguage = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage]);\r\n\r\n        if (!id) {\r\n            // check the target language(s)\r\n            if (speechConfig.targetLanguages.length === 0) {\r\n                speechConfig.addTargetLanguage(this.privLanguage);\r\n            }\r\n\r\n            // check the profanity setting: speech and conversationTranslator should be in sync\r\n            const profanity: string = speechConfig.getProperty(PropertyId[PropertyId.SpeechServiceResponse_ProfanityOption]);\r\n            if (!profanity) {\r\n                speechConfig.setProfanity(ProfanityOption.Masked);\r\n            }\r\n            // check the nickname: it should pass this regex: ^\\w+([\\s-][\\w\\(\\)]+)*$\"\r\n            // TODO: specify the regex required. Nicknames must be unique or get the duplicate nickname error\r\n            // TODO: check what the max length is and if a truncation is required or if the service handles it without an error\r\n            let hostNickname: string = speechConfig.getProperty(PropertyId[PropertyId.ConversationTranslator_Name]);\r\n            if (hostNickname === undefined || hostNickname === null || hostNickname.length <= 1 || hostNickname.length > 50) {\r\n                hostNickname = \"Host\";\r\n            }\r\n            speechConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], hostNickname);\r\n\r\n        } else {\r\n            this.privConversationId = id;\r\n        }\r\n\r\n        // save the speech config for future usage\r\n        this.privConfig = speechConfig;\r\n\r\n        // save the config properties\r\n        const configImpl = speechConfig as SpeechTranslationConfigImpl;\r\n        Contracts.throwIfNull(configImpl, \"speechConfig\");\r\n        this.privProperties = configImpl.properties.clone();\r\n        this.privIsConnected = false;\r\n        this.privParticipants = new InternalParticipants();\r\n        this.privIsReady = false;\r\n        this.privTextMessageMaxLength = 1000;\r\n    }\r\n\r\n    /**\r\n     * Create a new conversation as Host\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public createConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            this.privManager.createOrJoin(this.privProperties, undefined,\r\n                ((room: IInternalConversation) => {\r\n                    if (!room) {\r\n                        this.handleError(new Error(this.privErrors.permissionDeniedConnect), err);\r\n                    }\r\n                    this.privRoom = room;\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts a new conversation as host.\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // check if there is already a recognizer\r\n            if (!!this.privConversationRecognizer) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedStart), err);\r\n            }\r\n            // check if there is conversation data available\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect);\r\n            // connect to the conversation websocket\r\n            this.privParticipants.meId = this.privRoom.participantId;\r\n            this.privConversationRecognizer = ConversationRecognizerFactory.fromConfig(this, this.privConfig);\r\n\r\n            // Because ConversationTranslator manually sets up and manages the connection, Conversation\r\n            // has to forward serviceRecognizer connection events that usually get passed automatically\r\n            this.privConversationRecognizer.connected = this.onConnected;\r\n            this.privConversationRecognizer.disconnected = this.onDisconnected;\r\n            this.privConversationRecognizer.canceled = this.onCanceled;\r\n\r\n            this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived;\r\n            this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived;\r\n            this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived;\r\n            this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived;\r\n            this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived;\r\n            this.privConversationRecognizer.translationReceived = this.onTranslationReceived;\r\n            this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived;\r\n            this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration;\r\n\r\n            this.privConversationRecognizer.connect(this.privRoom.token,\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Join a conversation as a participant.\r\n     * @param { IParticipant } participant - participant to add\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public addParticipantAsync(participant: IParticipant, cb?: Callback, err?: Callback): void {\r\n        Contracts.throwIfNullOrUndefined(participant, \"Participant\");\r\n        marshalPromiseToCallbacks(this.addParticipantImplAsync(participant), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Join a conversation as a participant.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            // TODO\r\n            // if (!!this.privConversationRecognizer) {\r\n            //     throw new Error(this.privErrors.permissionDeniedStart);\r\n            // }\r\n            Contracts.throwIfNullOrWhitespace(conversationId, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversationId\"));\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrWhitespace(lang, this.privErrors.invalidArgs.replace(\"{arg}\", \"language\"));\r\n            // join the conversation\r\n            this.privManager.createOrJoin(this.privProperties, conversationId,\r\n                ((room: IInternalConversation) => {\r\n                    Contracts.throwIfNullOrUndefined(room, this.privErrors.permissionDeniedConnect);\r\n                    this.privRoom = room;\r\n                    this.privConfig.authorizationToken = room.cognitiveSpeechAuthToken;\r\n                    // join callback\r\n                    if (!!cb) {\r\n                        cb(room.cognitiveSpeechAuthToken);\r\n                    }\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deletes a conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public deleteConversationAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks(this.deleteConversationImplAsync(), cb, err);\r\n    }\r\n\r\n    public async deleteConversationImplAsync(): Promise<void> {\r\n            Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect);\r\n            Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect);\r\n            await this.privManager.leave(this.privProperties, this.privRoom.token);\r\n\r\n            this.dispose();\r\n    }\r\n\r\n    /**\r\n     * Issues a request to close the client websockets\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public endConversationAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks(this.endConversationImplAsync(), cb, err);\r\n    }\r\n\r\n    public endConversationImplAsync(): Promise<void> {\r\n        return this.close(true);\r\n    }\r\n\r\n    /**\r\n     * Issues a request to lock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public lockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"lock\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getLockCommand(true),\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the user's permissions\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getMuteAllCommand(true),\r\n                (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to mute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public muteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getMuteCommand(userId, true), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to remove a participant from the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public removeParticipantAsync(userId: string | IParticipant | IUser, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            if (!!this.privTranscriberRecognizer && userId.hasOwnProperty(\"id\")) {\r\n                // Assume this is a transcription participant\r\n                marshalPromiseToCallbacks(this.removeParticipantImplAsync(userId as IParticipant), cb, err);\r\n            } else {\r\n                Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n                Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n                if (!this.canSendAsHost) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"remove\")), err);\r\n                }\r\n                let participantId: string = \"\";\r\n                if (typeof userId === \"string\") {\r\n                    participantId = userId as string;\r\n                } else if (userId.hasOwnProperty(\"id\")) {\r\n                    const participant: IParticipant = userId as IParticipant;\r\n                    participantId = participant.id;\r\n                } else if (userId.hasOwnProperty(\"userId\")) {\r\n                    const user: IUser = userId as IUser;\r\n                    participantId = user.userId;\r\n                }\r\n                Contracts.throwIfNullOrWhitespace(participantId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n                // check the participant exists\r\n                const index: number = this.participants.findIndex((p: Participant) => p.id === participantId);\r\n                if (index === -1) {\r\n                    this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n                }\r\n                this.privConversationRecognizer?.sendRequest(this.getEjectCommand(participantId), (() => {\r\n                    this.handleCallback(cb, err);\r\n                }),\r\n                    ((error: any) => {\r\n                        this.handleError(error, err);\r\n                    }));\r\n            }\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unlock the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unlockConversationAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unlock\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getLockCommand(false), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute all participants in the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteAllParticipantsAsync(cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSendAsHost) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace(\"{command}\", \"unmute all\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getMuteAllCommand(false), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Issues a request to unmute a participant in the conversation\r\n     * @param userId\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public unmuteParticipantAsync(userId: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(userId, this.privErrors.invalidArgs.replace(\"{arg}\", \"userId\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            // check the connection is open (host + participant can perform the mute command)\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // if not host, check the participant is not muting another participant\r\n            if (!this.me.isHost && this.me.id !== userId) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace(\"{command}\", \"mute\")), err);\r\n            }\r\n            // check the user exists\r\n            const exists: number = this.privParticipants.getParticipantIndex(userId);\r\n            if (exists === -1) {\r\n                this.handleError(new Error(this.privErrors.invalidParticipantRequest), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getMuteCommand(userId, false), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", \"message\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            // TODO: is a max length check required?\r\n            if (message.length > this.privTextMessageMaxLength) {\r\n                this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"message length\")), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getMessageCommand(message), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change nickname\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public changeNicknameAsync(nickname: string, cb?: Callback, err?: Callback): void {\r\n        try {\r\n            Contracts.throwIfDisposed(this.privIsDisposed);\r\n            Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed());\r\n            Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n            Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend);\r\n            if (!this.canSend) {\r\n                this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n            }\r\n            this.privConversationRecognizer?.sendRequest(this.getChangeNicknameCommand(nickname), (() => {\r\n                this.handleCallback(cb, err);\r\n            }),\r\n                ((error: any) => {\r\n                    this.handleError(error, err);\r\n                }));\r\n        } catch (error) {\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string): void {\r\n        if (this.isDisposed) {\r\n            return;\r\n        }\r\n        this.privIsDisposed = true;\r\n        this.config?.close();\r\n        this.privConfig = undefined;\r\n        this.privLanguage = undefined;\r\n        this.privProperties = undefined;\r\n        this.privRoom = undefined;\r\n        this.privToken = undefined;\r\n        this.privManager = undefined;\r\n        this.privIsConnected = false;\r\n        this.privIsReady = false;\r\n        this.privParticipants = undefined;\r\n    }\r\n\r\n    public get transcriberRecognizer(): TranscriberRecognizer {\r\n        return this.privTranscriberRecognizer;\r\n    }\r\n\r\n    public async connectTranscriberRecognizer(recognizer: TranscriberRecognizer): Promise<void> {\r\n        if (!!this.privTranscriberRecognizer) {\r\n            await this.privTranscriberRecognizer.close();\r\n        }\r\n        this.privTranscriberRecognizer = recognizer;\r\n        this.privTranscriberRecognizer.conversation = this;\r\n    }\r\n\r\n    public get conversationInfo(): ConversationInfo {\r\n        const convId: string = this.conversationId;\r\n        const p: TranscriptionParticipant[] = this.participants.map((part: Participant) => {\r\n            return {\r\n                id: part.id,\r\n                preferredLanguage: part.preferredLanguage,\r\n                voice: part.voice\r\n            };\r\n        });\r\n        const props: { [id: string]: string } = {};\r\n        for (const key of ConversationConnectionConfig.transcriptionEventKeys) {\r\n            const val: string = this.properties.getProperty(key, \"\");\r\n            if (val !== \"\") {\r\n                props[key] = val;\r\n            }\r\n        }\r\n        const info: ConversationInfo = { id: convId, participants: p, conversationProperties: props };\r\n        return info;\r\n    }\r\n\r\n    public getKeepAlive(): string {\r\n        const nickname: string = (!!this.me) ? this.me.displayName : \"default_nickname\";\r\n        return JSON.stringify({\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            id: \"0\",\r\n            nickname,\r\n            participantId: this.privRoom.participantId,\r\n            roomId: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.keepAlive\r\n        });\r\n    }\r\n\r\n    /** websocket callbacks */\r\n    private onConnected = (e: ConnectionEventArgs): void => {\r\n        this.privIsConnected = true;\r\n        try {\r\n            if (!!this.privConversationTranslator?.sessionStarted) {\r\n                this.privConversationTranslator.sessionStarted(this.privConversationTranslator, e);\r\n            }\r\n            if (!!this.privTranscriberRecognizer?.conversationStarted) {\r\n                this.privTranscriberRecognizer.conversationStarted(this.privTranscriberRecognizer, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onDisconnected = async (e: ConnectionEventArgs): Promise<void> => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.sessionStopped) {\r\n                this.privConversationTranslator.sessionStopped(this.privConversationTranslator, e);\r\n            }\r\n            if (!!this.privTranscriberRecognizer?.conversationStopped) {\r\n                this.privTranscriberRecognizer.conversationStopped(this.privTranscriberRecognizer, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        } finally {\r\n            await this.close(false);\r\n        }\r\n    }\r\n\r\n    private onCanceled = async (r: ConversationRecognizer, e: ConversationTranslationCanceledEventArgs): Promise<void> => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.canceled) {\r\n                this.privConversationTranslator.canceled(this.privConversationTranslator, e);\r\n            }\r\n            if (!!this.privTranscriberRecognizer?.conversationCanceled) {\r\n                this.privTranscriberRecognizer.conversationCanceled(this.privTranscriberRecognizer, e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantUpdateCommandReceived = (r: ConversationRecognizer, e: ParticipantAttributeEventArgs): void => {\r\n        try {\r\n            const updatedParticipant: any = this.privParticipants.getParticipant(e.id);\r\n            if (updatedParticipant !== undefined) {\r\n\r\n                switch (e.key) {\r\n                    case ConversationTranslatorCommandTypes.changeNickname:\r\n                        updatedParticipant.displayName = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setUseTTS:\r\n                        updatedParticipant.useTts = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setProfanityFiltering:\r\n                        updatedParticipant.profanity = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setMute:\r\n                        updatedParticipant.isMuted = e.value;\r\n                        break;\r\n                    case ConversationTranslatorCommandTypes.setTranslateToLanguages:\r\n                        updatedParticipant.translateToLanguages = e.value;\r\n                        break;\r\n                }\r\n                this.privParticipants.addOrUpdateParticipant(updatedParticipant);\r\n\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                            [this.toParticipant(updatedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onLockRoomCommandReceived = (r: ConversationRecognizer, e: LockRoomEventArgs): void => {\r\n        // TODO\r\n    }\r\n\r\n    private onMuteAllCommandReceived = (r: ConversationRecognizer, e: MuteAllEventArgs): void => {\r\n        try {\r\n            this.privParticipants.participants.forEach((p: IInternalParticipant) => p.isMuted = (p.isHost ? false : e.isMuted));\r\n            if (!!this.privConversationTranslator?.participantsChanged) {\r\n                this.privConversationTranslator?.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.Updated,\r\n                        this.toParticipants(false), e.sessionId));\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantJoinCommandReceived = (r: ConversationRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const newParticipant: IInternalParticipant = this.privParticipants.addOrUpdateParticipant(e.participant);\r\n            if (newParticipant !== undefined) {\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation,\r\n                            [this.toParticipant(newParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantLeaveCommandReceived = (r: ConversationRecognizer, e: ParticipantEventArgs): void => {\r\n        try {\r\n            const ejectedParticipant: IInternalParticipant = this.privParticipants.getParticipant(e.participant.id);\r\n            if (ejectedParticipant !== undefined) {\r\n                // remove the participant from the internal participants list\r\n                this.privParticipants.deleteParticipant(e.participant.id);\r\n                if (!!this.privConversationTranslator?.participantsChanged) {\r\n                    // notify subscribers that the participant has left the conversation\r\n                    this.privConversationTranslator?.participantsChanged(\r\n                        this.privConversationTranslator,\r\n                        new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.LeftConversation,\r\n                            [this.toParticipant(ejectedParticipant)], e.sessionId));\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onTranslationReceived = (r: ConversationRecognizer, e: ConversationReceivedTranslationEventArgs): void => {\r\n        try {\r\n            switch (e.command) {\r\n                case ConversationTranslatorMessageTypes.final:\r\n                    if (!!this.privConversationTranslator?.transcribed) {\r\n                        this.privConversationTranslator?.transcribed(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.partial:\r\n                    if (!!this.privConversationTranslator?.transcribing) {\r\n                        this.privConversationTranslator?.transcribing(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n                case ConversationTranslatorMessageTypes.instantMessage:\r\n                    if (!!this.privConversationTranslator?.textMessageReceived) {\r\n                        this.privConversationTranslator?.textMessageReceived(\r\n                            this.privConversationTranslator,\r\n                            new ConversationTranslationEventArgs(e.payload, undefined, e.sessionId));\r\n                    }\r\n                    break;\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onParticipantsListReceived = (r: ConversationRecognizer, e: ParticipantsListEventArgs): void => {\r\n        try {\r\n            // check if the session token needs to be updated\r\n            if (e.sessionToken !== undefined && e.sessionToken !== null) {\r\n                this.privRoom.token = e.sessionToken;\r\n            }\r\n            // save the participants\r\n            this.privParticipants.participants = [...e.participants];\r\n            // enable the conversation\r\n            if (this.privParticipants.me !== undefined) {\r\n                this.privIsReady = true;\r\n            }\r\n            if (!!this.privConversationTranslator?.participantsChanged) {\r\n                this.privConversationTranslator?.participantsChanged(\r\n                    this.privConversationTranslator,\r\n                    new ConversationParticipantsChangedEventArgs(ParticipantChangedReason.JoinedConversation, this.toParticipants(true), e.sessionId));\r\n            }\r\n            // if this is the host, update the nickname if needed\r\n            if (this.me.isHost) {\r\n                const nickname: string = this.privConversationTranslator?.properties.getProperty(PropertyId.ConversationTranslator_Name);\r\n                if (nickname !== undefined && nickname.length > 0 && nickname !== this.me.displayName) {\r\n                    // issue a change nickname request\r\n                    this.changeNicknameAsync(nickname);\r\n                }\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private onConversationExpiration = (r: ConversationRecognizer, e: ConversationExpirationEventArgs): void => {\r\n        try {\r\n            if (!!this.privConversationTranslator?.conversationExpiration) {\r\n                this.privConversationTranslator?.conversationExpiration(\r\n                    this.privConversationTranslator,\r\n                    e);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private addParticipantImplAsync(participant: IParticipant): Promise<void> {\r\n        const newParticipant: IInternalParticipant = this.privParticipants.addOrUpdateParticipant(participant);\r\n        if (newParticipant !== undefined) {\r\n            if (!!this.privTranscriberRecognizer) {\r\n                const conversationInfo = this.conversationInfo;\r\n                conversationInfo.participants = [participant];\r\n                return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"join\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeParticipantImplAsync(participant: IParticipant): Promise<void> {\r\n        this.privParticipants.deleteParticipant(participant.id);\r\n        const conversationInfo = this.conversationInfo;\r\n        conversationInfo.participants = [participant];\r\n        return this.privTranscriberRecognizer.pushConversationEvent(conversationInfo, \"leave\");\r\n    }\r\n\r\n    private async close(dispose: boolean): Promise<void> {\r\n        try {\r\n            this.privIsConnected = false;\r\n            await this.privConversationRecognizer?.close();\r\n            this.privConversationRecognizer = undefined;\r\n            this.privConversationTranslator?.dispose();\r\n        } catch (e) {\r\n            // ignore error\r\n            throw e;\r\n        }\r\n        if (dispose) {\r\n            this.dispose();\r\n        }\r\n    }\r\n\r\n    /** Helpers */\r\n    private get canSend(): boolean {\r\n        return this.privIsConnected && !this.privParticipants.me?.isMuted;\r\n    }\r\n\r\n    private get canSendAsHost(): boolean {\r\n        return this.privIsConnected && this.privParticipants.me?.isHost;\r\n    }\r\n\r\n    private handleCallback(cb: any, err: any): void {\r\n        if (!!cb) {\r\n            try {\r\n                cb();\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(e);\r\n                }\r\n            }\r\n            cb = undefined;\r\n        }\r\n    }\r\n\r\n    private handleError(error: any, err: any): void {\r\n        if (!!err) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                err(typedError.name + \": \" + typedError.message);\r\n\r\n            } else {\r\n                err(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Participant Helpers */\r\n    private toParticipants(includeHost: boolean): Participant[] {\r\n\r\n        const participants: Participant[] = this.privParticipants.participants.map((p: IInternalParticipant) => {\r\n            return this.toParticipant(p);\r\n        });\r\n        if (!includeHost) {\r\n            return participants.filter((p: Participant) => p.isHost === false);\r\n        } else {\r\n            return participants;\r\n        }\r\n    }\r\n\r\n    private toParticipant(p: IInternalParticipant): Participant {\r\n        return new Participant(p.id, p.avatar, p.displayName, p.isHost, p.isMuted, p.isUsingTts, p.preferredLanguage, p.voice);\r\n    }\r\n\r\n    private getMuteAllCommand(isMuted: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setMuteAll,\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: this.privRoom.participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isMuted\r\n        });\r\n    }\r\n\r\n    private getMuteCommand(participantId: string, isMuted: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setMute,\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isMuted\r\n        });\r\n    }\r\n\r\n    private getLockCommand(isLocked: boolean): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.setLockState,\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: this.privRoom.participantId,\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: isLocked\r\n        });\r\n    }\r\n\r\n    private getEjectCommand(participantId: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.ejectParticipant,\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: participantId,\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n        });\r\n    }\r\n\r\n    private getChangeNicknameCommand(nickname: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(nickname, \"nickname\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n\r\n        return JSON.stringify({\r\n            command: ConversationTranslatorCommandTypes.changeNickname,\r\n            nickname,\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: this.privRoom.participantId, // the id of the host\r\n            roomid: this.privRoom.roomId,\r\n            type: ConversationTranslatorMessageTypes.participantCommand,\r\n            value: nickname\r\n        });\r\n    }\r\n\r\n    private getMessageCommand(message: string): string {\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, \"conversationId\");\r\n        Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, \"participantId\");\r\n        Contracts.throwIfNullOrWhitespace(message, \"message\");\r\n\r\n        return JSON.stringify({\r\n            // tslint:disable-next-line: object-literal-shorthand\r\n            participantId: this.privRoom.participantId,\r\n            roomId: this.privRoom.roomId,\r\n            text: message,\r\n            type: ConversationTranslatorMessageTypes.instantMessage\r\n        });\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}