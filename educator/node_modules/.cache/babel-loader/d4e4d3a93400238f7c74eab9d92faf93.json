{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { InvalidOperationError } from \"./Error\";\nimport { createNoDashGuid } from \"./Guid\";\nimport { Queue } from \"./Queue\";\nexport class Stream {\n  constructor(streamId) {\n    this.privIsWriteEnded = false;\n    this.privIsReadEnded = false;\n\n    this.read = () => {\n      if (this.privIsReadEnded) {\n        throw new InvalidOperationError(\"Stream read has already finished\");\n      }\n\n      return this.privReaderQueue.dequeue().then(streamChunk => __awaiter(this, void 0, void 0, function* () {\n        if (streamChunk === undefined || streamChunk.isEnd) {\n          yield this.privReaderQueue.dispose(\"End of stream reached\");\n        }\n\n        return streamChunk;\n      }));\n    };\n\n    this.readEnded = () => {\n      if (!this.privIsReadEnded) {\n        this.privIsReadEnded = true;\n        this.privReaderQueue = new Queue();\n      }\n    };\n\n    this.throwIfClosed = () => {\n      if (this.privIsWriteEnded) {\n        throw new InvalidOperationError(\"Stream closed\");\n      }\n    };\n\n    this.privId = streamId ? streamId : createNoDashGuid();\n    this.privReaderQueue = new Queue();\n  }\n\n  get isClosed() {\n    return this.privIsWriteEnded;\n  }\n\n  get isReadEnded() {\n    return this.privIsReadEnded;\n  }\n\n  get id() {\n    return this.privId;\n  }\n\n  close() {\n    if (!this.privIsWriteEnded) {\n      this.writeStreamChunk({\n        buffer: null,\n        isEnd: true,\n        timeReceived: Date.now()\n      });\n      this.privIsWriteEnded = true;\n    }\n  }\n\n  writeStreamChunk(streamChunk) {\n    this.throwIfClosed();\n\n    if (!this.privReaderQueue.isDisposed()) {\n      try {\n        this.privReaderQueue.enqueue(streamChunk);\n      } catch (e) {// Do nothing\n      }\n    }\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAASA,qBAAT,QAAsC,SAAtC;AACA,SAASC,gBAAT,QAAiC,QAAjC;AACA,SAASC,KAAT,QAAsB,SAAtB;AAQA,OAAM,MAAOC,MAAP,CAAa;AAMfC,cAAmBC,QAAnB,EAAoC;AAJ5B,4BAA4B,KAA5B;AACA,2BAA2B,KAA3B;;AA0CD,gBAAO,MAAqC;AAC/C,UAAI,KAAKC,eAAT,EAA0B;AACtB,cAAM,IAAIN,qBAAJ,CAA0B,kCAA1B,CAAN;AACH;;AAED,aAAO,KAAKO,eAAL,CACFC,OADE,GAEFC,IAFE,CAEUC,WAAP,IAA6CC;AAC/C,YAAID,WAAW,KAAKE,SAAhB,IAA6BF,WAAW,CAACG,KAA7C,EAAoD;AAChD,gBAAM,KAAKN,eAAL,CAAqBO,OAArB,CAA6B,uBAA7B,CAAN;AACH;;AAED,eAAOJ,WAAP;AACH,OANkD,CAFhD,CAAP;AASH,KAdM;;AAeA,qBAAY,MAAW;AAC1B,UAAI,CAAC,KAAKJ,eAAV,EAA2B;AACvB,aAAKA,eAAL,GAAuB,IAAvB;AACA,aAAKC,eAAL,GAAuB,IAAIL,KAAJ,EAAvB;AACH;AACJ,KALM;;AAOC,yBAAgB,MAAW;AAC/B,UAAI,KAAKa,gBAAT,EAA2B;AACvB,cAAM,IAAIf,qBAAJ,CAA0B,eAA1B,CAAN;AACH;AACJ,KAJO;;AA5DJ,SAAKgB,MAAL,GAAcX,QAAQ,GAAGA,QAAH,GAAcJ,gBAAgB,EAApD;AACA,SAAKM,eAAL,GAAuB,IAAIL,KAAJ,EAAvB;AACH;;AAEkB,MAARe,QAAQ;AACf,WAAO,KAAKF,gBAAZ;AACH;;AAEqB,MAAXG,WAAW;AAClB,WAAO,KAAKZ,eAAZ;AACH;;AAEY,MAAFa,EAAE;AACT,WAAO,KAAKH,MAAZ;AACH;;AAEMI,OAAK;AACR,QAAI,CAAC,KAAKL,gBAAV,EAA4B;AACxB,WAAKM,gBAAL,CAAsB;AAClBC,cAAM,EAAE,IADU;AAElBT,aAAK,EAAE,IAFW;AAGlBU,oBAAY,EAAEC,IAAI,CAACC,GAAL;AAHI,OAAtB;AAKA,WAAKV,gBAAL,GAAwB,IAAxB;AACH;AACJ;;AAEMM,kBAAgB,CAACX,WAAD,EAAmC;AACtD,SAAKgB,aAAL;;AACA,QAAI,CAAC,KAAKnB,eAAL,CAAqBoB,UAArB,EAAL,EAAwC;AACpC,UAAI;AACA,aAAKpB,eAAL,CAAqBqB,OAArB,CAA6BlB,WAA7B;AACH,OAFD,CAEE,OAAOmB,CAAP,EAAU,CACR;AACH;AACJ;AACJ;;AA3Cc","names":["InvalidOperationError","createNoDashGuid","Queue","Stream","constructor","streamId","privIsReadEnded","privReaderQueue","dequeue","then","streamChunk","__awaiter","undefined","isEnd","dispose","privIsWriteEnded","privId","isClosed","isReadEnded","id","close","writeStreamChunk","buffer","timeReceived","Date","now","throwIfClosed","isDisposed","enqueue","e"],"sources":["C:\\Users\\ozgur\\Documents\\VSCodeProjects\\webapp_educator\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common\\src\\common\\Stream.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error\";\r\nimport { createNoDashGuid } from \"./Guid\";\r\nimport { Queue } from \"./Queue\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privIsWriteEnded: boolean = false;\r\n    private privIsReadEnded: boolean = false;\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsWriteEnded;\r\n    }\r\n\r\n    public get isReadEnded(): boolean {\r\n        return this.privIsReadEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsWriteEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsWriteEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        if (!this.privReaderQueue.isDisposed()) {\r\n            try {\r\n                this.privReaderQueue.enqueue(streamChunk);\r\n            } catch (e) {\r\n                // Do nothing\r\n            }\r\n        }\r\n    }\r\n\r\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.privIsReadEnded) {\r\n            throw new InvalidOperationError(\"Stream read has already finished\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .then(async (streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk === undefined || streamChunk.isEnd) {\r\n                    await this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n    public readEnded = (): void => {\r\n        if (!this.privIsReadEnded) {\r\n            this.privIsReadEnded = true;\r\n            this.privReaderQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        }\r\n    }\r\n\r\n    private throwIfClosed = (): void => {\r\n        if (this.privIsWriteEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}