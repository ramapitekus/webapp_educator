{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { RiffPcmEncoder } from \"../common/Exports\";\nexport class PcmRecorder {\n  constructor(stopInputOnRelease) {\n    this.record = (context, mediaStream, outputStream) => {\n      const desiredSampleRate = 16000;\n      const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\n      let needHeader = true;\n      const micInput = context.createMediaStreamSource(mediaStream);\n\n      if (!this.privSpeechProcessorScript) {\n        const workletScript = `class SP extends AudioWorkletProcessor {\n                constructor(options) {\n                  super(options);\n                }\n                process(inputs, outputs) {\n                  const input = inputs[0];\n                  const output = [];\n                  for (let channel = 0; channel < input.length; channel += 1) {\n                    output[channel] = input[channel];\n                  }\n                  this.port.postMessage(output[0]);\n                  return true;\n                }\n              }\n              registerProcessor('speech-processor', SP);`; // tslint:disable-line:max-line-length\n\n        const blob = new Blob([workletScript], {\n          type: \"application/javascript; charset=utf-8\"\n        });\n        this.privSpeechProcessorScript = URL.createObjectURL(blob);\n      }\n\n      const attachScriptProcessor = () => {\n        const scriptNode = (() => {\n          let bufferSize = 0;\n\n          try {\n            return context.createScriptProcessor(bufferSize, 1, 1);\n          } catch (error) {\n            // Webkit (<= version 31) requires a valid bufferSize.\n            bufferSize = 2048;\n            let audioSampleRate = context.sampleRate;\n\n            while (bufferSize < 16384 && audioSampleRate >= 2 * desiredSampleRate) {\n              bufferSize <<= 1;\n              audioSampleRate >>= 1;\n            }\n\n            return context.createScriptProcessor(bufferSize, 1, 1);\n          }\n        })();\n\n        scriptNode.onaudioprocess = event => {\n          const inputFrame = event.inputBuffer.getChannelData(0);\n\n          if (outputStream && !outputStream.isClosed) {\n            const waveFrame = waveStreamEncoder.encode(inputFrame);\n\n            if (!!waveFrame) {\n              outputStream.writeStreamChunk({\n                buffer: waveFrame,\n                isEnd: false,\n                timeReceived: Date.now()\n              });\n              needHeader = false;\n            }\n          }\n        };\n\n        micInput.connect(scriptNode);\n        scriptNode.connect(context.destination);\n        this.privMediaResources = {\n          scriptProcessorNode: scriptNode,\n          source: micInput,\n          stream: mediaStream\n        };\n      }; // https://webaudio.github.io/web-audio-api/#audioworklet\n      // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\n\n\n      if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\n        context.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {\n          const workletNode = new AudioWorkletNode(context, \"speech-processor\");\n\n          workletNode.port.onmessage = ev => {\n            const inputFrame = ev.data;\n\n            if (outputStream && !outputStream.isClosed) {\n              const waveFrame = waveStreamEncoder.encode(inputFrame);\n\n              if (!!waveFrame) {\n                outputStream.writeStreamChunk({\n                  buffer: waveFrame,\n                  isEnd: false,\n                  timeReceived: Date.now()\n                });\n                needHeader = false;\n              }\n            }\n          };\n\n          micInput.connect(workletNode);\n          workletNode.connect(context.destination);\n          this.privMediaResources = {\n            scriptProcessorNode: workletNode,\n            source: micInput,\n            stream: mediaStream\n          };\n        }).catch(() => {\n          attachScriptProcessor();\n        });\n      } else {\n        try {\n          attachScriptProcessor();\n        } catch (err) {\n          throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);\n        }\n      }\n    };\n\n    this.releaseMediaResources = context => {\n      if (this.privMediaResources) {\n        if (this.privMediaResources.scriptProcessorNode) {\n          this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\n          this.privMediaResources.scriptProcessorNode = null;\n        }\n\n        if (this.privMediaResources.source) {\n          this.privMediaResources.source.disconnect();\n\n          if (this.privStopInputOnRelease) {\n            this.privMediaResources.stream.getTracks().forEach(track => track.stop());\n          }\n\n          this.privMediaResources.source = null;\n        }\n      }\n    };\n\n    this.privStopInputOnRelease = stopInputOnRelease;\n  }\n\n  setWorkletUrl(url) {\n    this.privSpeechProcessorScript = url;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["RiffPcmEncoder","PcmRecorder","constructor","stopInputOnRelease","context","mediaStream","outputStream","desiredSampleRate","waveStreamEncoder","sampleRate","needHeader","micInput","createMediaStreamSource","privSpeechProcessorScript","workletScript","blob","Blob","type","URL","createObjectURL","attachScriptProcessor","scriptNode","bufferSize","createScriptProcessor","error","audioSampleRate","onaudioprocess","event","inputFrame","inputBuffer","getChannelData","isClosed","waveFrame","encode","writeStreamChunk","buffer","isEnd","timeReceived","Date","now","connect","destination","privMediaResources","scriptProcessorNode","source","stream","audioWorklet","addModule","then","workletNode","AudioWorkletNode","port","onmessage","ev","data","catch","err","Error","disconnect","privStopInputOnRelease","getTracks","forEach","track","stop","setWorkletUrl","url"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.browser\\src\\common.browser\\PCMRecorder.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { RiffPcmEncoder, Stream } from \"../common/Exports\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\nexport class PcmRecorder implements IRecorder {\r\n    private privMediaResources: IMediaResources;\r\n    private privSpeechProcessorScript: string; // speech-processor.js Url\r\n    private privStopInputOnRelease: boolean;\r\n\r\n    public constructor(stopInputOnRelease: boolean) {\r\n        this.privStopInputOnRelease = stopInputOnRelease;\r\n    }\r\n\r\n    public record = (context: AudioContext, mediaStream: MediaStream, outputStream: Stream<ArrayBuffer>): void => {\r\n        const desiredSampleRate = 16000;\r\n\r\n        const waveStreamEncoder = new RiffPcmEncoder(context.sampleRate, desiredSampleRate);\r\n        let needHeader: boolean = true;\r\n\r\n        const micInput = context.createMediaStreamSource(mediaStream);\r\n        if (!this.privSpeechProcessorScript) {\r\n            const workletScript = `class SP extends AudioWorkletProcessor {\r\n                constructor(options) {\r\n                  super(options);\r\n                }\r\n                process(inputs, outputs) {\r\n                  const input = inputs[0];\r\n                  const output = [];\r\n                  for (let channel = 0; channel < input.length; channel += 1) {\r\n                    output[channel] = input[channel];\r\n                  }\r\n                  this.port.postMessage(output[0]);\r\n                  return true;\r\n                }\r\n              }\r\n              registerProcessor('speech-processor', SP);`; // tslint:disable-line:max-line-length\r\n            const blob = new Blob([workletScript], { type: \"application/javascript; charset=utf-8\" });\r\n            this.privSpeechProcessorScript = URL.createObjectURL(blob);\r\n        }\r\n\r\n        const attachScriptProcessor = () => {\r\n            const scriptNode = (() => {\r\n                let bufferSize = 0;\r\n                try {\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                } catch (error) {\r\n                    // Webkit (<= version 31) requires a valid bufferSize.\r\n                    bufferSize = 2048;\r\n                    let audioSampleRate = context.sampleRate;\r\n                    while (bufferSize < 16384 && audioSampleRate >= (2 * desiredSampleRate)) {\r\n                        bufferSize <<= 1;\r\n                        audioSampleRate >>= 1;\r\n                    }\r\n                    return context.createScriptProcessor(bufferSize, 1, 1);\r\n                }\r\n            })();\r\n            scriptNode.onaudioprocess = (event: AudioProcessingEvent) => {\r\n                const inputFrame = event.inputBuffer.getChannelData(0);\r\n\r\n                if (outputStream && !outputStream.isClosed) {\r\n                    const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                    if (!!waveFrame) {\r\n                        outputStream.writeStreamChunk({\r\n                            buffer: waveFrame,\r\n                            isEnd: false,\r\n                            timeReceived: Date.now(),\r\n                        });\r\n                        needHeader = false;\r\n                    }\r\n                }\r\n            };\r\n            micInput.connect(scriptNode);\r\n            scriptNode.connect(context.destination);\r\n            this.privMediaResources = {\r\n                scriptProcessorNode: scriptNode,\r\n                source: micInput,\r\n                stream: mediaStream,\r\n            };\r\n        };\r\n\r\n        // https://webaudio.github.io/web-audio-api/#audioworklet\r\n        // Using AudioWorklet to improve audio quality and avoid audio glitches due to blocking the UI thread\r\n\r\n        if (!!this.privSpeechProcessorScript && !!context.audioWorklet) {\r\n            context.audioWorklet\r\n                .addModule(this.privSpeechProcessorScript)\r\n                .then(() => {\r\n                    const workletNode = new AudioWorkletNode(context, \"speech-processor\");\r\n                    workletNode.port.onmessage = (ev: MessageEvent) => {\r\n                        const inputFrame: Float32Array = ev.data as Float32Array;\r\n\r\n                        if (outputStream && !outputStream.isClosed) {\r\n                            const waveFrame = waveStreamEncoder.encode(inputFrame);\r\n                            if (!!waveFrame) {\r\n                                outputStream.writeStreamChunk({\r\n                                    buffer: waveFrame,\r\n                                    isEnd: false,\r\n                                    timeReceived: Date.now(),\r\n                                });\r\n                                needHeader = false;\r\n                            }\r\n                        }\r\n                    };\r\n                    micInput.connect(workletNode);\r\n                    workletNode.connect(context.destination);\r\n                    this.privMediaResources = {\r\n                        scriptProcessorNode: workletNode,\r\n                        source: micInput,\r\n                        stream: mediaStream,\r\n                    };\r\n                })\r\n                .catch(() => {\r\n                    attachScriptProcessor();\r\n                });\r\n        } else {\r\n            try {\r\n                attachScriptProcessor();\r\n            } catch (err) {\r\n                throw new Error(`Unable to start audio worklet node for PCMRecorder: ${err}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    public releaseMediaResources = (context: AudioContext): void => {\r\n        if (this.privMediaResources) {\r\n            if (this.privMediaResources.scriptProcessorNode) {\r\n                this.privMediaResources.scriptProcessorNode.disconnect(context.destination);\r\n                this.privMediaResources.scriptProcessorNode = null;\r\n            }\r\n            if (this.privMediaResources.source) {\r\n                this.privMediaResources.source.disconnect();\r\n                if (this.privStopInputOnRelease) {\r\n                    this.privMediaResources.stream.getTracks().forEach((track: any) => track.stop());\r\n                }\r\n                this.privMediaResources.source = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setWorkletUrl(url: string): void {\r\n        this.privSpeechProcessorScript = url;\r\n    }\r\n}\r\n\r\ninterface IMediaResources {\r\n    source: MediaStreamAudioSourceNode;\r\n    scriptProcessorNode: ScriptProcessorNode | AudioWorkletNode;\r\n    stream: MediaStream;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}