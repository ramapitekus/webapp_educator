{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ConnectionState, createNoDashGuid, Deferred, MessageType } from \"../../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, ConversationExpirationEventArgs, ConversationTranslationCanceledEventArgs, ConversationTranslationResult, Translations } from \"../../sdk/Exports\";\nimport { CognitiveTokenAuthentication, ServiceRecognizerBase } from \"../Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\nimport { ConversationReceivedTranslationEventArgs, LockRoomEventArgs, MuteAllEventArgs, ParticipantAttributeEventArgs, ParticipantEventArgs, ParticipantsListEventArgs } from \"./ConversationTranslatorEventArgs\";\nimport { ConversationTranslatorCommandTypes, ConversationTranslatorMessageTypes } from \"./ConversationTranslatorInterfaces\";\nimport { CommandResponsePayload, ParticipantPayloadResponse, ParticipantsListPayloadResponse, SpeechResponsePayload, TextResponsePayload } from \"./ServiceMessages/Exports\";\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\n\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\n    this.privLastPartialUtteranceId = \"\";\n\n    this.noOp = () => {// operation not supported\n    };\n\n    this.privConversationServiceConnector = conversationServiceConnector;\n    this.privConversationAuthentication = authentication;\n    this.receiveMessageOverride = this.receiveConversationMessageOverride;\n    this.recognizeOverride = this.noOp;\n    this.postConnectImplOverride = this.conversationConnectImpl;\n    this.configConnectionOverride = this.configConnection;\n    this.disconnectOverride = this.privDisconnect;\n    this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\n    this.privConversationConnectionFactory = connectionFactory;\n    this.privConversationIsDisposed = false;\n  }\n\n  isDisposed() {\n    return super.isDisposed() || this.privConversationIsDisposed;\n  }\n\n  dispose(reason) {\n    const _super = Object.create(null, {\n      dispose: {\n        get: () => super.dispose\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConversationIsDisposed = true;\n\n      if (this.privConnectionConfigPromise) {\n        const connection = yield this.privConnectionConfigPromise;\n        yield connection.dispose(reason);\n      }\n\n      yield _super.dispose.call(this, reason);\n    });\n  }\n\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      return connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  sendMessageAsync(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const sink = new Deferred();\n      const connection = yield this.fetchConnection();\n      yield connection.send(new ConversationConnectionMessage(MessageType.Text, message));\n    });\n  }\n\n  privDisconnect() {\n    if (this.terminateMessageLoop) {\n      return;\n    }\n\n    this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n    this.terminateMessageLoop = true;\n    return Promise.resolve();\n  }\n\n  processTypeSpecificMessages(connectionMessage, successCallback, errorCallBack) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return true;\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    this.terminateMessageLoop = true;\n    const cancelEvent = new ConversationTranslationCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n    try {\n      if (!!this.privConversationServiceConnector.canceled) {\n        this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\n      }\n    } catch (_a) {// continue on error\n    }\n  }\n  /**\r\n   * Establishes a websocket connection to the end point.\r\n   */\n\n\n  conversationConnectImpl(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privConnectionLoop = this.startMessageLoop();\n      return connection;\n    });\n  }\n  /**\r\n   * Process incoming websocket messages\r\n   */\n\n\n  receiveConversationMessageOverride() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed() || this.terminateMessageLoop) {\n        return Promise.resolve();\n      } // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n\n\n      const communicationCustodian = new Deferred();\n\n      try {\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.isDisposed() || this.terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve();\n          return Promise.resolve();\n        }\n\n        if (!message) {\n          return this.receiveConversationMessageOverride();\n        }\n\n        const sessionId = this.privConversationRequestSession.sessionId;\n        let sendFinal = false;\n\n        try {\n          switch (message.conversationMessageType.toLowerCase()) {\n            case \"info\":\n            case \"participant_command\":\n            case \"command\":\n              const commandPayload = CommandResponsePayload.fromJSON(message.textBody);\n\n              switch (commandPayload.command.toLowerCase()) {\n                /**\r\n                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                 * The consuming client must wait for this message to arrive\r\n                 * before starting to send their own data.\r\n                 */\n                case \"participantlist\":\n                  const participantsPayload = ParticipantsListPayloadResponse.fromJSON(message.textBody);\n                  const participantsResult = participantsPayload.participants.map(p => {\n                    const participant = {\n                      avatar: p.avatar,\n                      displayName: p.nickname,\n                      id: p.participantId,\n                      isHost: p.ishost,\n                      isMuted: p.ismuted,\n                      isUsingTts: p.usetts,\n                      preferredLanguage: p.locale\n                    };\n                    return participant;\n                  });\n\n                  if (!!this.privConversationServiceConnector.participantsListReceived) {\n                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token, participantsPayload.translateTo, participantsPayload.profanityFilter, participantsPayload.roomProfanityFilter, participantsPayload.roomLocked, participantsPayload.muteAll, participantsResult, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                 * This is sent at the start of the Conversation\r\n                 */\n\n                case \"settranslatetolanguages\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setTranslateToLanguages, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                 * If sent by the participant the setting will effect only their own profanity level.\r\n                 * If sent by the host, the setting will effect all participants including the host.\r\n                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                 */\n\n                case \"setprofanityfiltering\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setProfanityFiltering, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetMute' is sent if the participant has been muted by the host.\r\n                 * Check the 'participantId' to determine if the current user has been muted.\r\n                 */\n\n                case \"setmute\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setMute, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                 */\n\n                case \"setmuteall\":\n                  if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\n                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new MuteAllEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                 */\n\n                case \"roomexpirationwarning\":\n                  if (!!this.privConversationServiceConnector.conversationExpiration) {\n                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new ConversationExpirationEventArgs(commandPayload.value, this.privConversationRequestSession.sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                 */\n\n                case \"setusetts\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.setUseTTS, commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                 */\n\n                case \"setlockstate\":\n                  if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\n                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new LockRoomEventArgs(commandPayload.value, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'ChangeNickname' is received if a user changes their display name.\r\n                 * Any cached particpiants list should be updated to reflect the display name.\r\n                 */\n\n                case \"changenickname\":\n                  if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\n                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new ParticipantAttributeEventArgs(commandPayload.participantId, ConversationTranslatorCommandTypes.changeNickname, commandPayload.nickname, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'JoinSession' is sent when a user joins the Conversation.\r\n                 */\n\n                case \"joinsession\":\n                  const joinParticipantPayload = ParticipantPayloadResponse.fromJSON(message.textBody);\n                  const joiningParticipant = {\n                    avatar: joinParticipantPayload.avatar,\n                    displayName: joinParticipantPayload.nickname,\n                    id: joinParticipantPayload.participantId,\n                    isHost: joinParticipantPayload.ishost,\n                    isMuted: joinParticipantPayload.ismuted,\n                    isUsingTts: joinParticipantPayload.usetts,\n                    preferredLanguage: joinParticipantPayload.locale\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\n                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(joiningParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                 */\n\n                case \"leavesession\":\n                  const leavingParticipant = {\n                    id: commandPayload.participantId\n                  };\n\n                  if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\n                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new ParticipantEventArgs(leavingParticipant, sessionId));\n                  }\n\n                  break;\n\n                /**\r\n                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                 * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                 */\n\n                case \"disconnectsession\":\n                  const disconnectParticipant = {\n                    id: commandPayload.participantId\n                  };\n                  break;\n\n                case \"token\":\n                  const token = new CognitiveTokenAuthentication(authFetchEventId => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  }, authFetchEventId => {\n                    const authorizationToken = commandPayload.token;\n                    return Promise.resolve(authorizationToken);\n                  });\n                  this.authentication = token;\n                  break;\n\n                /**\r\n                 * Message not recognized.\r\n                 */\n\n                default:\n                  break;\n              }\n\n              break;\n\n            /**\r\n             * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n             */\n\n            case \"partial\":\n            /**\r\n             * 'final' (or 'phrase') represents a finalized speech message.\r\n             */\n\n            case \"final\":\n              const speechPayload = SpeechResponsePayload.fromJSON(message.textBody);\n              const speechResult = new ConversationTranslationResult(speechPayload.participantId, this.getTranslations(speechPayload.translations), speechPayload.language, undefined, undefined, speechPayload.recognition, undefined, undefined, message.textBody, undefined);\n\n              if (speechPayload.isFinal) {\n                // check the length, sometimes empty finals are returned\n                if (speechResult.text !== undefined && speechResult.text.length > 0) {\n                  sendFinal = true;\n                } else if (speechPayload.id === this.privLastPartialUtteranceId) {\n                  // send final as normal. We had a non-empty partial for this same utterance\n                  // so sending the empty final is important\n                  sendFinal = true;\n                } else {// suppress unneeded final\n                }\n\n                if (sendFinal) {\n                  if (!!this.privConversationServiceConnector.translationReceived) {\n                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\n                  }\n                }\n              } else if (speechResult.text !== undefined) {\n                this.privLastPartialUtteranceId = speechPayload.id;\n\n                if (!!this.privConversationServiceConnector.translationReceived) {\n                  this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\n                }\n              }\n\n              break;\n\n            /**\r\n             * \"translated_message\" is a text message or instant message (IM).\r\n             */\n\n            case \"translated_message\":\n              const textPayload = TextResponsePayload.fromJSON(message.textBody);\n              const textResult = new ConversationTranslationResult(textPayload.participantId, this.getTranslations(textPayload.translations), textPayload.language, undefined, undefined, textPayload.originalText, undefined, undefined, undefined, message.textBody, undefined);\n\n              if (!!this.privConversationServiceConnector.translationReceived) {\n                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\n              }\n\n              break;\n\n            default:\n              // ignore any unsupported message types\n              break;\n          }\n        } catch (e) {// continue\n        }\n\n        return this.receiveConversationMessageOverride();\n      } catch (e) {\n        this.terminateMessageLoop = true;\n      }\n\n      return communicationCustodian.promise;\n    });\n  }\n\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDisposed()) {\n        return Promise.resolve();\n      }\n\n      this.terminateMessageLoop = false;\n      const messageRetrievalPromise = this.receiveConversationMessageOverride();\n\n      try {\n        const r = yield messageRetrievalPromise;\n        return r;\n      } catch (error) {\n        this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n        return null;\n      }\n    });\n  } // Takes an established websocket connection to the endpoint\n\n\n  configConnection() {\n    if (this.isDisposed()) {\n      return Promise.resolve(undefined);\n    }\n\n    if (this.privConnectionConfigPromise) {\n      return this.privConnectionConfigPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionConfigPromise = null;\n          return this.configConnection();\n        }\n\n        return this.privConnectionConfigPromise;\n      }, error => {\n        this.privConnectionId = null;\n        this.privConnectionConfigPromise = null;\n        return this.configConnection();\n      });\n    }\n\n    if (this.terminateMessageLoop) {\n      return Promise.resolve(undefined);\n    }\n\n    this.privConnectionConfigPromise = this.connectImpl().then(connection => {\n      return connection;\n    });\n    return this.privConnectionConfigPromise;\n  }\n\n  getTranslations(serviceResultTranslations) {\n    let translations;\n\n    if (undefined !== serviceResultTranslations) {\n      translations = new Translations();\n\n      for (const translation of serviceResultTranslations) {\n        translations.set(translation.lang, translation.translation);\n      }\n    }\n\n    return translations;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ConnectionState","createNoDashGuid","Deferred","MessageType","CancellationErrorCode","CancellationReason","ConversationExpirationEventArgs","ConversationTranslationCanceledEventArgs","ConversationTranslationResult","Translations","CognitiveTokenAuthentication","ServiceRecognizerBase","ConversationConnectionMessage","ConversationRequestSession","ConversationReceivedTranslationEventArgs","LockRoomEventArgs","MuteAllEventArgs","ParticipantAttributeEventArgs","ParticipantEventArgs","ParticipantsListEventArgs","ConversationTranslatorCommandTypes","ConversationTranslatorMessageTypes","CommandResponsePayload","ParticipantPayloadResponse","ParticipantsListPayloadResponse","SpeechResponsePayload","TextResponsePayload","ConversationServiceAdapter","constructor","authentication","connectionFactory","audioSource","recognizerConfig","conversationServiceConnector","privConversationServiceConnector","privConversationAuthentication","receiveMessageOverride","receiveConversationMessageOverride","recognizeOverride","noOp","postConnectImplOverride","conversationConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privConversationRequestSession","privConversationConnectionFactory","privConversationIsDisposed","isDisposed","dispose","reason","privConnectionConfigPromise","connection","_super","call","sendMessage","message","fetchConnection","send","Text","sendMessageAsync","sink","terminateMessageLoop","cancelRecognition","sessionId","requestId","Error","NoError","Promise","resolve","processTypeSpecificMessages","connectionMessage","successCallback","errorCallBack","cancellationReason","errorCode","error","cancelEvent","undefined","canceled","privConnectionLoop","startMessageLoop","communicationCustodian","read","sendFinal","conversationMessageType","toLowerCase","commandPayload","fromJSON","textBody","command","participantsPayload","participantsResult","participants","map","p","participant","avatar","displayName","nickname","id","participantId","isHost","ishost","isMuted","ismuted","isUsingTts","usetts","preferredLanguage","locale","participantsListReceived","roomid","token","translateTo","profanityFilter","roomProfanityFilter","roomLocked","muteAll","participantUpdateCommandReceived","setTranslateToLanguages","value","setProfanityFiltering","setMute","muteAllCommandReceived","conversationExpiration","setUseTTS","lockRoomCommandReceived","changeNickname","joinParticipantPayload","joiningParticipant","participantJoinCommandReceived","leavingParticipant","participantLeaveCommandReceived","disconnectParticipant","authFetchEventId","authorizationToken","speechPayload","speechResult","getTranslations","translations","language","recognition","isFinal","text","length","privLastPartialUtteranceId","translationReceived","final","partial","textPayload","textResult","originalText","instantMessage","e","promise","messageRetrievalPromise","r","privRequestSession","RuntimeError","then","state","Disconnected","privConnectionId","connectImpl","serviceResultTranslations","translation","set","lang"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\Transcription\\src\\common.speech\\Transcription\\ConversationServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IAudioSource,\r\n    IConnection,\r\n    MessageType,\r\n} from \"../../common/Exports\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ConversationExpirationEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationResult,\r\n    Translations\r\n} from \"../../sdk/Exports\";\r\nimport {\r\n    CognitiveTokenAuthentication,\r\n    IAuthentication,\r\n    IConnectionFactory,\r\n    RecognizerConfig,\r\n    ServiceRecognizerBase\r\n} from \"../Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\nimport { ConversationRequestSession } from \"./ConversationRequestSession\";\r\nimport {\r\n    ConversationReceivedTranslationEventArgs,\r\n    LockRoomEventArgs,\r\n    MuteAllEventArgs,\r\n    ParticipantAttributeEventArgs,\r\n    ParticipantEventArgs,\r\n    ParticipantsListEventArgs\r\n} from \"./ConversationTranslatorEventArgs\";\r\nimport {\r\n    ConversationTranslatorCommandTypes,\r\n    ConversationTranslatorMessageTypes,\r\n    IInternalParticipant\r\n} from \"./ConversationTranslatorInterfaces\";\r\nimport { ConversationTranslatorRecognizer } from \"./ConversationTranslatorRecognizer\";\r\nimport {\r\n    CommandResponsePayload,\r\n    IParticipantPayloadResponse,\r\n    IParticipantsListPayloadResponse,\r\n    ITranslationResponsePayload,\r\n    ParticipantPayloadResponse,\r\n    ParticipantsListPayloadResponse,\r\n    SpeechResponsePayload,\r\n    TextResponsePayload\r\n} from \"./ServiceMessages/Exports\";\r\n\r\n/***\r\n * The service adapter handles sending and receiving messages to the Conversation Translator websocket.\r\n */\r\nexport class ConversationServiceAdapter extends ServiceRecognizerBase {\r\n    private privConversationServiceConnector: ConversationTranslatorRecognizer;\r\n    private privConversationConnectionFactory: IConnectionFactory;\r\n    private privConversationAuthFetchEventId: string;\r\n    private privConversationAuthentication: IAuthentication;\r\n    private privConversationRequestSession: ConversationRequestSession;\r\n    private privConnectionConfigPromise: Promise<IConnection>;\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private privLastPartialUtteranceId: string = \"\";\r\n    private privConversationIsDisposed: boolean;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        conversationServiceConnector: ConversationTranslatorRecognizer) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, conversationServiceConnector);\r\n\r\n        this.privConversationServiceConnector = conversationServiceConnector;\r\n        this.privConversationAuthentication = authentication;\r\n        this.receiveMessageOverride = this.receiveConversationMessageOverride;\r\n        this.recognizeOverride = this.noOp;\r\n        this.postConnectImplOverride = this.conversationConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privConversationRequestSession = new ConversationRequestSession(createNoDashGuid());\r\n        this.privConversationConnectionFactory = connectionFactory;\r\n        this.privConversationIsDisposed = false;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return super.isDisposed() || this.privConversationIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privConversationIsDisposed = true;\r\n        if (this.privConnectionConfigPromise) {\r\n            const connection: IConnection = await this.privConnectionConfigPromise;\r\n            await connection.dispose(reason);\r\n        }\r\n        await super.dispose(reason);\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new ConversationConnectionMessage(\r\n            MessageType.Text,\r\n            message));\r\n    }\r\n\r\n    public async sendMessageAsync(message: string): Promise<void> {\r\n        const sink: Deferred<void> = new Deferred<void>();\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n\r\n        await connection.send(new ConversationConnectionMessage(MessageType.Text, message));\r\n    }\r\n\r\n    protected privDisconnect(): Promise<void> {\r\n        if (this.terminateMessageLoop) {\r\n            return;\r\n        }\r\n        this.cancelRecognition(this.privConversationRequestSession.sessionId,\r\n            this.privConversationRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        return Promise.resolve();\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(\r\n        connectionMessage: ConnectionMessage,\r\n        successCallback?: (e: any) => void,\r\n        errorCallBack?: (e: string) => void): Promise<boolean> {\r\n        return true;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n            cancellationReason,\r\n            error,\r\n            errorCode,\r\n            undefined,\r\n            sessionId);\r\n\r\n        try {\r\n            if (!!this.privConversationServiceConnector.canceled) {\r\n                this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, cancelEvent);\r\n            }\r\n        } catch {\r\n            // continue on error\r\n        }\r\n    }\r\n\r\n    protected noOp = (): any => {\r\n        // operation not supported\r\n    }\r\n\r\n    /**\r\n     * Establishes a websocket connection to the end point.\r\n     */\r\n    protected async conversationConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    /**\r\n     * Process incoming websocket messages\r\n     */\r\n    private async receiveConversationMessageOverride(): Promise<void> {\r\n        if (this.isDisposed() || this.terminateMessageLoop) {\r\n            return Promise.resolve();\r\n        }\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        try {\r\n            const connection: IConnection = await this.fetchConnection();\r\n            const message: ConversationConnectionMessage = await connection.read() as ConversationConnectionMessage;\r\n            if (this.isDisposed() || this.terminateMessageLoop) {\r\n                // We're done.\r\n                communicationCustodian.resolve();\r\n                return Promise.resolve();\r\n            }\r\n\r\n            if (!message) {\r\n                return this.receiveConversationMessageOverride();\r\n            }\r\n\r\n            const sessionId: string = this.privConversationRequestSession.sessionId;\r\n            let sendFinal: boolean = false;\r\n\r\n            try {\r\n                switch (message.conversationMessageType.toLowerCase()) {\r\n                    case \"info\":\r\n                    case \"participant_command\":\r\n                    case \"command\":\r\n                        const commandPayload: CommandResponsePayload = CommandResponsePayload.fromJSON(message.textBody);\r\n                        switch (commandPayload.command.toLowerCase()) {\r\n\r\n                            /**\r\n                             * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.\r\n                             * The consuming client must wait for this message to arrive\r\n                             * before starting to send their own data.\r\n                             */\r\n                            case \"participantlist\":\r\n\r\n                                const participantsPayload: IParticipantsListPayloadResponse = ParticipantsListPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const participantsResult: IInternalParticipant[] = participantsPayload.participants.map((p: IParticipantPayloadResponse) => {\r\n                                    const participant: IInternalParticipant = {\r\n                                        avatar: p.avatar,\r\n                                        displayName: p.nickname,\r\n                                        id: p.participantId,\r\n                                        isHost: p.ishost,\r\n                                        isMuted: p.ismuted,\r\n                                        isUsingTts: p.usetts,\r\n                                        preferredLanguage: p.locale\r\n                                    };\r\n                                    return participant;\r\n                                });\r\n\r\n                                if (!!this.privConversationServiceConnector.participantsListReceived) {\r\n                                    this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantsListEventArgs(participantsPayload.roomid, participantsPayload.token,\r\n                                            participantsPayload.translateTo, participantsPayload.profanityFilter,\r\n                                            participantsPayload.roomProfanityFilter, participantsPayload.roomLocked,\r\n                                            participantsPayload.muteAll, participantsResult, sessionId));\r\n                                }\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).\r\n                             * This is sent at the start of the Conversation\r\n                             */\r\n                            case \"settranslatetolanguages\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setTranslateToLanguages,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetProfanityFiltering' lets the client set the level of profanity filtering.\r\n                             * If sent by the participant the setting will effect only their own profanity level.\r\n                             * If sent by the host, the setting will effect all participants including the host.\r\n                             * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'\r\n                             */\r\n                            case \"setprofanityfiltering\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setProfanityFiltering,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMute' is sent if the participant has been muted by the host.\r\n                             * Check the 'participantId' to determine if the current user has been muted.\r\n                             */\r\n                            case \"setmute\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setMute,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetMuteAll' is sent if the Conversation has been muted by the host.\r\n                             */\r\n                            case \"setmuteall\":\r\n\r\n                                if (!!this.privConversationServiceConnector.muteAllCommandReceived) {\r\n                                    this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector,\r\n                                        new MuteAllEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.\r\n                             */\r\n                            case \"roomexpirationwarning\":\r\n\r\n                                if (!!this.privConversationServiceConnector.conversationExpiration) {\r\n                                    this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector,\r\n                                        new ConversationExpirationEventArgs(commandPayload.value as number, this.privConversationRequestSession.sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.\r\n                             */\r\n                            case \"setusetts\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.setUseTTS,\r\n                                            commandPayload.value, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'SetLockState' is set if the host has locked or unlocked the Conversation.\r\n                             */\r\n                            case \"setlockstate\":\r\n\r\n                                if (!!this.privConversationServiceConnector.lockRoomCommandReceived) {\r\n                                    this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector,\r\n                                        new LockRoomEventArgs(commandPayload.value as boolean, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'ChangeNickname' is received if a user changes their display name.\r\n                             * Any cached particpiants list should be updated to reflect the display name.\r\n                             */\r\n                            case \"changenickname\":\r\n\r\n                                if (!!this.privConversationServiceConnector.participantUpdateCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantAttributeEventArgs(commandPayload.participantId,\r\n                                            ConversationTranslatorCommandTypes.changeNickname,\r\n                                            commandPayload.nickname, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'JoinSession' is sent when a user joins the Conversation.\r\n                             */\r\n                            case \"joinsession\":\r\n\r\n                                const joinParticipantPayload: ParticipantPayloadResponse = ParticipantPayloadResponse.fromJSON(message.textBody);\r\n\r\n                                const joiningParticipant: IInternalParticipant = {\r\n                                    avatar: joinParticipantPayload.avatar,\r\n                                    displayName: joinParticipantPayload.nickname,\r\n                                    id: joinParticipantPayload.participantId,\r\n                                    isHost: joinParticipantPayload.ishost,\r\n                                    isMuted: joinParticipantPayload.ismuted,\r\n                                    isUsingTts: joinParticipantPayload.usetts,\r\n                                    preferredLanguage: joinParticipantPayload.locale,\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantJoinCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(\r\n                                            joiningParticipant,\r\n                                            sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'LeaveSession' is sent when a user leaves the Conversation'.\r\n                             */\r\n                            case \"leavesession\":\r\n\r\n                                const leavingParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                if (!!this.privConversationServiceConnector.participantLeaveCommandReceived) {\r\n                                    this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector,\r\n                                        new ParticipantEventArgs(leavingParticipant, sessionId));\r\n                                }\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).\r\n                             * Check the 'ParticipantId' to check whether the message is for the current user.\r\n                             */\r\n                            case \"disconnectsession\":\r\n\r\n                                const disconnectParticipant: IInternalParticipant = {\r\n                                    id: commandPayload.participantId\r\n                                };\r\n\r\n                                break;\r\n\r\n                            case \"token\":\r\n                                const token = new CognitiveTokenAuthentication(\r\n                                    (authFetchEventId: string): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    },\r\n                                    (authFetchEventId: string): Promise<string> => {\r\n                                        const authorizationToken = commandPayload.token;\r\n                                        return Promise.resolve(authorizationToken);\r\n                                    });\r\n                                this.authentication = token;\r\n\r\n                                break;\r\n\r\n                            /**\r\n                             * Message not recognized.\r\n                             */\r\n                            default:\r\n                                break;\r\n                        }\r\n                        break;\r\n\r\n                    /**\r\n                     * 'partial' (or 'hypothesis') represents a unfinalized speech message.\r\n                     */\r\n                    case \"partial\":\r\n\r\n                    /**\r\n                     * 'final' (or 'phrase') represents a finalized speech message.\r\n                     */\r\n                    case \"final\":\r\n\r\n                        const speechPayload: SpeechResponsePayload = SpeechResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const speechResult: ConversationTranslationResult = new ConversationTranslationResult(speechPayload.participantId,\r\n                            this.getTranslations(speechPayload.translations),\r\n                            speechPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            speechPayload.recognition,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (speechPayload.isFinal) {\r\n                            // check the length, sometimes empty finals are returned\r\n                            if (speechResult.text !== undefined && speechResult.text.length > 0) {\r\n                                sendFinal = true;\r\n                            } else if (speechPayload.id === this.privLastPartialUtteranceId) {\r\n                                // send final as normal. We had a non-empty partial for this same utterance\r\n                                // so sending the empty final is important\r\n                                sendFinal = true;\r\n                            } else {\r\n                                // suppress unneeded final\r\n                            }\r\n\r\n                            if (sendFinal) {\r\n                                if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                    this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                        new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.final, speechResult, sessionId));\r\n                                }\r\n                            }\r\n                        } else if (speechResult.text !== undefined) {\r\n                            this.privLastPartialUtteranceId = speechPayload.id;\r\n                            if (!!this.privConversationServiceConnector.translationReceived) {\r\n                                this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                    new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.partial, speechResult, sessionId));\r\n                            }\r\n                        }\r\n\r\n                        break;\r\n\r\n                    /**\r\n                     * \"translated_message\" is a text message or instant message (IM).\r\n                     */\r\n                    case \"translated_message\":\r\n\r\n                        const textPayload: TextResponsePayload = TextResponsePayload.fromJSON(message.textBody);\r\n\r\n                        const textResult: ConversationTranslationResult = new ConversationTranslationResult(textPayload.participantId,\r\n                            this.getTranslations(textPayload.translations),\r\n                            textPayload.language,\r\n                            undefined,\r\n                            undefined,\r\n                            textPayload.originalText,\r\n                            undefined,\r\n                            undefined,\r\n                            undefined,\r\n                            message.textBody,\r\n                            undefined);\r\n\r\n                        if (!!this.privConversationServiceConnector.translationReceived) {\r\n                            this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector,\r\n                                new ConversationReceivedTranslationEventArgs(ConversationTranslatorMessageTypes.instantMessage, textResult, sessionId));\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        // ignore any unsupported message types\r\n                        break;\r\n                }\r\n            } catch (e) {\r\n                // continue\r\n            }\r\n            return this.receiveConversationMessageOverride();\r\n        } catch (e) {\r\n            this.terminateMessageLoop = true;\r\n        }\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve();\r\n        }\r\n        this.terminateMessageLoop = false;\r\n\r\n        const messageRetrievalPromise = this.receiveConversationMessageOverride();\r\n\r\n        try {\r\n            const r = await messageRetrievalPromise;\r\n            return r;\r\n        } catch (error) {\r\n            this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : \"\", this.privRequestSession ? this.privRequestSession.requestId : \"\", CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint\r\n    private configConnection(): Promise<IConnection> {\r\n        if (this.isDisposed()) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n        if (this.privConnectionConfigPromise) {\r\n            return this.privConnectionConfigPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigPromise = null;\r\n                    return this.configConnection();\r\n                }\r\n                return this.privConnectionConfigPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigPromise = null;\r\n                return this.configConnection();\r\n            });\r\n        }\r\n        if (this.terminateMessageLoop) {\r\n            return Promise.resolve<IConnection>(undefined);\r\n        }\r\n\r\n        this.privConnectionConfigPromise = this.connectImpl().then((connection: IConnection): any => {\r\n            return connection;\r\n        });\r\n\r\n        return this.privConnectionConfigPromise;\r\n    }\r\n\r\n    private getTranslations(serviceResultTranslations: ITranslationResponsePayload[]): Translations {\r\n        let translations: Translations;\r\n\r\n        if (undefined !== serviceResultTranslations) {\r\n            translations = new Translations();\r\n            for (const translation of serviceResultTranslations) {\r\n                translations.set(translation.lang, translation.translation);\r\n            }\r\n        }\r\n\r\n        return translations;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}