{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\nimport { BackgroundEvent, createNoDashGuid, Events } from \"../../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\nconst MediaDurationPlaceholderSeconds = 60 * 30;\nconst AudioFormatToMimeType = {\n  [AudioFormatTag.PCM]: \"audio/wav\",\n  [AudioFormatTag.MuLaw]: \"audio/x-wav\",\n  [AudioFormatTag.MP3]: \"audio/mpeg\",\n  [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\n  [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\n  [AudioFormatTag.ALaw]: \"audio/x-wav\",\n  [AudioFormatTag.FLAC]: \"audio/flac\"\n};\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.17.0\r\n */\n\nexport class SpeakerAudioDestination {\n  constructor(audioDestinationId) {\n    this.privPlaybackStarted = false;\n    this.privAppendingToBuffer = false;\n    this.privMediaSourceOpened = false;\n    this.privBytesReceived = 0;\n    this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\n    this.privIsPaused = false;\n    this.privIsClosed = false;\n  }\n\n  id() {\n    return this.privId;\n  }\n\n  write(buffer, cb, err) {\n    if (this.privAudioBuffer !== undefined) {\n      this.privAudioBuffer.push(buffer);\n      this.updateSourceBuffer().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined) {\n      this.privAudioOutputStream.write(buffer);\n      this.privBytesReceived += buffer.byteLength;\n    }\n  }\n\n  close(cb, err) {\n    this.privIsClosed = true;\n\n    if (this.privSourceBuffer !== undefined) {\n      this.handleSourceBufferUpdateEnd().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n    } else if (this.privAudioOutputStream !== undefined) {\n      if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\n        // tslint:disable-next-line:no-console\n        console.warn(`Play back is not supported for raw PCM, mulaw or alaw format without header.`);\n\n        if (!!this.onAudioEnd) {\n          this.onAudioEnd(this);\n        }\n      } else {\n        let receivedAudio = new ArrayBuffer(this.privBytesReceived);\n        this.privAudioOutputStream.read(receivedAudio).then(_ => {\n          receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\n          const audioBlob = new Blob([receivedAudio], {\n            type: AudioFormatToMimeType[this.privFormat.formatTag]\n          });\n          this.privAudio.src = window.URL.createObjectURL(audioBlob);\n          this.notifyPlayback().then(() => {\n            if (!!cb) {\n              cb();\n            }\n          }, error => {\n            if (!!err) {\n              err(error);\n            }\n          });\n        }, error => {\n          if (!!err) {\n            err(error);\n          }\n        });\n      }\n    } else {\n      // unsupported format, call onAudioEnd directly.\n      if (!!this.onAudioEnd) {\n        this.onAudioEnd(this);\n      }\n    }\n  }\n\n  set format(format) {\n    if (typeof AudioContext !== \"undefined\" || typeof window.webkitAudioContext !== \"undefined\") {\n      this.privFormat = format;\n      const mimeType = AudioFormatToMimeType[this.privFormat.formatTag];\n\n      if (mimeType === undefined) {\n        // tslint:disable-next-line:no-console\n        console.warn(`Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\n      } else if (typeof MediaSource !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\n        this.privAudio = new Audio();\n        this.privAudioBuffer = [];\n        this.privMediaSource = new MediaSource();\n        this.privAudio.src = URL.createObjectURL(this.privMediaSource);\n        this.privAudio.load();\n\n        this.privMediaSource.onsourceopen = event => {\n          this.privMediaSourceOpened = true;\n          this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\n          this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\n\n          this.privSourceBuffer.onupdate = _ => {\n            this.updateSourceBuffer().catch(reason => {\n              Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n          };\n\n          this.privSourceBuffer.onupdateend = _ => {\n            this.handleSourceBufferUpdateEnd().catch(reason => {\n              Events.instance.onEvent(new BackgroundEvent(reason));\n            });\n          };\n\n          this.privSourceBuffer.onupdatestart = _ => {\n            this.privAppendingToBuffer = false;\n          };\n        };\n\n        this.updateSourceBuffer().catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      } else {\n        // tslint:disable-next-line:no-console\n        console.warn(`Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n        this.privAudioOutputStream.format = this.privFormat;\n        this.privAudio = new Audio();\n      }\n    }\n  }\n\n  get volume() {\n    return this.privAudio.volume;\n  }\n\n  set volume(volume) {\n    this.privAudio.volume = volume;\n  }\n\n  mute() {\n    this.privAudio.muted = true;\n  }\n\n  unmute() {\n    this.privAudio.muted = false;\n  }\n\n  get isClosed() {\n    return this.privIsClosed;\n  }\n\n  get currentTime() {\n    if (this.privAudio !== undefined) {\n      return this.privAudio.currentTime;\n    }\n\n    return -1;\n  }\n\n  pause() {\n    if (!this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.pause();\n      this.privIsPaused = true;\n    }\n  }\n\n  resume(cb, err) {\n    if (this.privIsPaused && this.privAudio !== undefined) {\n      this.privAudio.play().then(() => {\n        if (!!cb) {\n          cb();\n        }\n      }, error => {\n        if (!!err) {\n          err(error);\n        }\n      });\n      this.privIsPaused = false;\n    }\n  }\n\n  get internalAudio() {\n    return this.privAudio;\n  }\n\n  updateSourceBuffer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privAudioBuffer !== undefined && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {\n        this.privAppendingToBuffer = true;\n        const binary = this.privAudioBuffer.shift();\n\n        try {\n          this.privSourceBuffer.appendBuffer(binary);\n        } catch (error) {\n          this.privAudioBuffer.unshift(binary); // tslint:disable-next-line:no-console\n\n          console.log(\"buffer filled, pausing addition of binaries until space is made\");\n          return;\n        }\n\n        yield this.notifyPlayback();\n      } else if (this.canEndStream()) {\n        yield this.handleSourceBufferUpdateEnd();\n      }\n    });\n  }\n\n  handleSourceBufferUpdateEnd() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.canEndStream() && this.sourceBufferAvailable()) {\n        this.privMediaSource.endOfStream();\n        yield this.notifyPlayback();\n      }\n    });\n  }\n\n  notifyPlayback() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privPlaybackStarted && this.privAudio !== undefined) {\n        this.privPlaybackStarted = true;\n\n        if (!!this.onAudioStart) {\n          this.onAudioStart(this);\n        }\n\n        this.privAudio.onended = () => {\n          if (!!this.onAudioEnd) {\n            this.onAudioEnd(this);\n          }\n        };\n\n        if (!this.privIsPaused) {\n          yield this.privAudio.play();\n        }\n      }\n    });\n  }\n\n  canEndStream() {\n    return this.isClosed && this.privSourceBuffer !== undefined && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\";\n  }\n\n  sourceBufferAvailable() {\n    return this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["SynthesisAdapterBase","BackgroundEvent","createNoDashGuid","Events","PullAudioOutputStreamImpl","AudioFormatTag","MediaDurationPlaceholderSeconds","AudioFormatToMimeType","PCM","MuLaw","MP3","OGG_OPUS","WEBM_OPUS","ALaw","FLAC","SpeakerAudioDestination","constructor","audioDestinationId","privId","privIsPaused","privIsClosed","id","write","buffer","cb","err","privAudioBuffer","undefined","push","updateSourceBuffer","then","error","privAudioOutputStream","privBytesReceived","byteLength","close","privSourceBuffer","handleSourceBufferUpdateEnd","privFormat","formatTag","hasHeader","console","warn","onAudioEnd","receivedAudio","ArrayBuffer","read","_","addHeader","audioBlob","Blob","type","privAudio","src","window","URL","createObjectURL","notifyPlayback","format","AudioContext","webkitAudioContext","mimeType","MediaSource","isTypeSupported","Audio","privMediaSource","load","onsourceopen","event","privMediaSourceOpened","duration","addSourceBuffer","onupdate","catch","reason","instance","onEvent","onupdateend","onupdatestart","privAppendingToBuffer","volume","mute","muted","unmute","isClosed","currentTime","pause","resume","play","internalAudio","length","sourceBufferAvailable","binary","shift","appendBuffer","unshift","log","canEndStream","endOfStream","privPlaybackStarted","onAudioStart","onended","readyState","updating"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\sdk\\Audio\\src\\sdk\\Audio\\SpeakerAudioDestination.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { SynthesisAdapterBase } from \"../../common.speech/Exports\";\r\nimport {\r\n    BackgroundEvent,\r\n    createNoDashGuid,\r\n    Events,\r\n    IAudioDestination,\r\n    INumberDictionary\r\n} from \"../../common/Exports\";\r\nimport { AudioStreamFormat, IPlayer } from \"../Exports\";\r\nimport { AudioOutputFormatImpl } from \"./AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"./AudioOutputStream\";\r\nimport { AudioFormatTag } from \"./AudioStreamFormat\";\r\n\r\nconst MediaDurationPlaceholderSeconds = 60 * 30;\r\n\r\nconst AudioFormatToMimeType: INumberDictionary<string> = {\r\n    [AudioFormatTag.PCM]: \"audio/wav\",\r\n    [AudioFormatTag.MuLaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.MP3]: \"audio/mpeg\",\r\n    [AudioFormatTag.OGG_OPUS]: \"audio/ogg\",\r\n    [AudioFormatTag.WEBM_OPUS]: \"audio/webm; codecs=opus\",\r\n    [AudioFormatTag.ALaw]: \"audio/x-wav\",\r\n    [AudioFormatTag.FLAC]: \"audio/flac\",\r\n};\r\n\r\n/**\r\n * Represents the speaker playback audio destination, which only works in browser.\r\n * Note: the SDK will try to use <a href=\"https://www.w3.org/TR/media-source/\">Media Source Extensions</a> to play audio.\r\n * Mp3 format has better supports on Microsoft Edge, Chrome and Safari (desktop), so, it's better to specify mp3 format for playback.\r\n * @class SpeakerAudioDestination\r\n * Updated in version 1.17.0\r\n */\r\nexport class SpeakerAudioDestination implements IAudioDestination, IPlayer {\r\n    private readonly privId: string;\r\n    private privFormat: AudioOutputFormatImpl;\r\n    private privAudio: HTMLAudioElement;\r\n    private privMediaSource: MediaSource;\r\n    private privSourceBuffer: SourceBuffer;\r\n    private privPlaybackStarted: boolean = false;\r\n    private privAudioBuffer: ArrayBuffer[];\r\n    private privAppendingToBuffer: boolean = false;\r\n    private privMediaSourceOpened: boolean = false;\r\n    private privIsClosed: boolean;\r\n    private privIsPaused: boolean;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privBytesReceived: number = 0;\r\n\r\n    public constructor(audioDestinationId?: string) {\r\n        this.privId = audioDestinationId ? audioDestinationId : createNoDashGuid();\r\n        this.privIsPaused = false;\r\n        this.privIsClosed = false;\r\n    }\r\n\r\n    public id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public write(buffer: ArrayBuffer, cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privAudioBuffer !== undefined) {\r\n            this.privAudioBuffer.push(buffer);\r\n            this.updateSourceBuffer().then(() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            this.privAudioOutputStream.write(buffer);\r\n            this.privBytesReceived += buffer.byteLength;\r\n        }\r\n    }\r\n\r\n    public close(cb?: () => void, err?: (error: string) => void): void {\r\n        this.privIsClosed = true;\r\n        if (this.privSourceBuffer !== undefined) {\r\n            this.handleSourceBufferUpdateEnd().then(() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n        } else if (this.privAudioOutputStream !== undefined) {\r\n            if ((this.privFormat.formatTag === AudioFormatTag.PCM || this.privFormat.formatTag === AudioFormatTag.MuLaw\r\n                || this.privFormat.formatTag === AudioFormatTag.ALaw) && this.privFormat.hasHeader === false) {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(`Play back is not supported for raw PCM, mulaw or alaw format without header.`);\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            } else {\r\n                let receivedAudio = new ArrayBuffer(this.privBytesReceived);\r\n                this.privAudioOutputStream.read(receivedAudio).then((_: number): void => {\r\n                    receivedAudio = SynthesisAdapterBase.addHeader(receivedAudio, this.privFormat);\r\n                    const audioBlob = new Blob([receivedAudio], { type: AudioFormatToMimeType[this.privFormat.formatTag] });\r\n                    this.privAudio.src = window.URL.createObjectURL(audioBlob);\r\n                    this.notifyPlayback().then(() => {\r\n                        if (!!cb) {\r\n                            cb();\r\n                        }\r\n                    }, (error: string): void => {\r\n                        if (!!err) {\r\n                            err(error);\r\n                        }\r\n                    });\r\n                }, (error: string): void => {\r\n                    if (!!err) {\r\n                        err(error);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // unsupported format, call onAudioEnd directly.\r\n            if (!!this.onAudioEnd) {\r\n                this.onAudioEnd(this);\r\n            }\r\n        }\r\n    }\r\n\r\n    set format(format: AudioStreamFormat) {\r\n        if (typeof (AudioContext) !== \"undefined\" || typeof ((window as any).webkitAudioContext) !== \"undefined\") {\r\n            this.privFormat = format as AudioOutputFormatImpl;\r\n            const mimeType: string = AudioFormatToMimeType[this.privFormat.formatTag];\r\n            if (mimeType === undefined) {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Unknown mimeType for format ${AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`);\r\n\r\n            } else if (typeof (MediaSource) !== \"undefined\" && MediaSource.isTypeSupported(mimeType)) {\r\n                this.privAudio = new Audio();\r\n                this.privAudioBuffer = [];\r\n                this.privMediaSource = new MediaSource();\r\n                this.privAudio.src = URL.createObjectURL(this.privMediaSource);\r\n                this.privAudio.load();\r\n                this.privMediaSource.onsourceopen = (event: Event): void => {\r\n                    this.privMediaSourceOpened = true;\r\n                    this.privMediaSource.duration = MediaDurationPlaceholderSeconds;\r\n                    this.privSourceBuffer = this.privMediaSource.addSourceBuffer(mimeType);\r\n                    this.privSourceBuffer.onupdate = (_: Event) => {\r\n                        this.updateSourceBuffer().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdateend = (_: Event) => {\r\n                        this.handleSourceBufferUpdateEnd().catch((reason: string): void => {\r\n                            Events.instance.onEvent(new BackgroundEvent(reason));\r\n                        });\r\n                    };\r\n                    this.privSourceBuffer.onupdatestart = (_: Event) => {\r\n                        this.privAppendingToBuffer = false;\r\n                    };\r\n                };\r\n                this.updateSourceBuffer().catch((reason: string): void => {\r\n                    Events.instance.onEvent(new BackgroundEvent(reason));\r\n                });\r\n\r\n            } else {\r\n                // tslint:disable-next-line:no-console\r\n                console.warn(\r\n                    `Format ${AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`);\r\n                this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n                this.privAudioOutputStream.format = this.privFormat;\r\n                this.privAudio = new Audio();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get volume(): number {\r\n        return this.privAudio.volume;\r\n    }\r\n\r\n    public set volume(volume: number) {\r\n        this.privAudio.volume = volume;\r\n    }\r\n\r\n    public mute(): void {\r\n        this.privAudio.muted = true;\r\n    }\r\n\r\n    public unmute(): void {\r\n        this.privAudio.muted = false;\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get currentTime(): number {\r\n        if (this.privAudio !== undefined) {\r\n            return this.privAudio.currentTime;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public pause(): void {\r\n        if (!this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.pause();\r\n            this.privIsPaused = true;\r\n        }\r\n    }\r\n\r\n    public resume(cb?: () => void, err?: (error: string) => void): void {\r\n        if (this.privIsPaused && this.privAudio !== undefined) {\r\n            this.privAudio.play().then(() => {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            }, (error: string): void => {\r\n                if (!!err) {\r\n                    err(error);\r\n                }\r\n            });\r\n            this.privIsPaused = false;\r\n        }\r\n    }\r\n\r\n    public onAudioStart: (sender: IPlayer) => void;\r\n\r\n    public onAudioEnd: (sender: IPlayer) => void;\r\n\r\n    public get internalAudio(): HTMLAudioElement {\r\n        return this.privAudio;\r\n    }\r\n\r\n    private async updateSourceBuffer(): Promise<void> {\r\n        if (this.privAudioBuffer !== undefined && (this.privAudioBuffer.length > 0) && this.sourceBufferAvailable()) {\r\n            this.privAppendingToBuffer = true;\r\n            const binary = this.privAudioBuffer.shift();\r\n            try {\r\n                this.privSourceBuffer.appendBuffer(binary);\r\n            } catch (error) {\r\n                this.privAudioBuffer.unshift(binary);\r\n                // tslint:disable-next-line:no-console\r\n                console.log(\r\n                    \"buffer filled, pausing addition of binaries until space is made\");\r\n                return;\r\n            }\r\n            await this.notifyPlayback();\r\n        } else if (this.canEndStream()) {\r\n            await this.handleSourceBufferUpdateEnd();\r\n        }\r\n    }\r\n\r\n    private async handleSourceBufferUpdateEnd(): Promise<void> {\r\n        if (this.canEndStream() && this.sourceBufferAvailable()) {\r\n            this.privMediaSource.endOfStream();\r\n            await this.notifyPlayback();\r\n        }\r\n    }\r\n\r\n    private async notifyPlayback(): Promise<void> {\r\n        if (!this.privPlaybackStarted && this.privAudio !== undefined) {\r\n            this.privPlaybackStarted = true;\r\n            if (!!this.onAudioStart) {\r\n                this.onAudioStart(this);\r\n            }\r\n            this.privAudio.onended = (): void => {\r\n                if (!!this.onAudioEnd) {\r\n                    this.onAudioEnd(this);\r\n                }\r\n            };\r\n            if (!this.privIsPaused) {\r\n                await this.privAudio.play();\r\n            }\r\n        }\r\n    }\r\n\r\n    private canEndStream(): boolean {\r\n        return (this.isClosed && this.privSourceBuffer !== undefined && (this.privAudioBuffer.length === 0)\r\n            && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === \"open\");\r\n    }\r\n\r\n    private sourceBufferAvailable(): boolean {\r\n        return (this.privSourceBuffer !== undefined && !this.privSourceBuffer.updating);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}