{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\olesr\\\\OneDrive\\\\Documents\\\\webapp_educ\\\\educator\\\\src\\\\recording.js\",\n    _s = $RefreshSig$();\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst recording = () => {\n  _s();\n\n  const mediaRecorder = useRef(null);\n  const mediaChunks = useRef([]);\n  const mediaStream = useRef(null);\n  const [mediaBlobUrl, setMediaBlobUrl] = useState(null);\n  useEffect(() => {\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n  }, [audio]);\n  const getMediaStream = useCallback(async () => {\n    try {\n      const audioStream = await window.navigator.mediaDevices.getUserMedia({\n        audio: true\n      });\n      audioStream.getAudioTracks().forEach(audioTrack => stream.addTrack(audioTrack));\n      mediaStream.current = stream;\n    } catch (error) {\n      console.log(\"some error occured\");\n    }\n  }, [audio]);\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty = Object.assign({\n      type: chunk.type\n    }, blobPropertyBag || {\n      type: \"audio/wav\"\n    });\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const onRecordingActive = _ref => {\n    let {\n      data\n    } = _ref;\n    mediaChunks.current.push(data);\n  };\n\n  const startRecording = async () => {\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current.getTracks().some(track => track.readyState === \"ended\");\n\n      if (isStreamEnded) {\n        await getMediaStream();\n      }\n\n      if (!mediaStream.current.active) {\n        return;\n      }\n\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n      mediaRecorder.current.start();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        mediaRecorder.current.stop();\n        mediaStream.current && mediaStream.current.getTracks().forEach(track => track.stop());\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startRecording,\n      children: \"Start Recording\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 79,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: stopRecording,\n      children: \"Stop Recording\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"video\", {\n      src: mediaBlobUrl,\n      controls: true,\n      autoPlay: true,\n      loop: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 78,\n    columnNumber: 5\n  }, this);\n};\n\n_s(recording, \"cvVS4b20Lp/26VP+cRC1EgUyLzc=\");\n\nexport default recording;","map":{"version":3,"sources":["C:/Users/olesr/OneDrive/Documents/webapp_educ/educator/src/recording.js"],"names":["recording","mediaRecorder","useRef","mediaChunks","mediaStream","mediaBlobUrl","setMediaBlobUrl","useState","useEffect","current","askPermissionOnMount","getMediaStream","audio","useCallback","audioStream","window","navigator","mediaDevices","getUserMedia","getAudioTracks","forEach","audioTrack","stream","addTrack","error","console","log","onRecordingStop","chunk","blobProperty","Object","assign","type","blobPropertyBag","blob","Blob","url","URL","createObjectURL","setStatus","onStop","onRecordingActive","data","push","startRecording","isStreamEnded","getTracks","some","track","readyState","active","MediaRecorder","ondataavailable","onstop","start","stopRecording","state","stop"],"mappings":"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","sourcesContent":["const recording = () => {\r\n  const mediaRecorder = useRef(null);\r\n  const mediaChunks = useRef([]);\r\n  const mediaStream = useRef(null);\r\n  const [mediaBlobUrl, setMediaBlobUrl] = useState(null);\r\n\r\n  useEffect(() => {\r\n    if (!mediaStream.current && askPermissionOnMount) {\r\n      getMediaStream();\r\n    }\r\n  }, [audio]);\r\n\r\n  const getMediaStream = useCallback(async () => {\r\n    try {\r\n      const audioStream = await window.navigator.mediaDevices.getUserMedia({\r\n        audio: true,\r\n      });\r\n      audioStream\r\n        .getAudioTracks()\r\n        .forEach((audioTrack) => stream.addTrack(audioTrack));\r\n      mediaStream.current = stream;\r\n    } catch (error) {\r\n      console.log(\"some error occured\");\r\n    }\r\n  }, [audio]);\r\n\r\n  const onRecordingStop = () => {\r\n    const [chunk] = mediaChunks.current;\r\n    const blobProperty = Object.assign(\r\n      { type: chunk.type },\r\n      blobPropertyBag || { type: \"audio/wav\" }\r\n    );\r\n    const blob = new Blob(mediaChunks.current, blobProperty);\r\n    const url = URL.createObjectURL(blob);\r\n    setStatus(\"stopped\");\r\n    setMediaBlobUrl(url);\r\n    onStop(url, blob);\r\n  };\r\n\r\n  const onRecordingActive = ({ data }) => {\r\n    mediaChunks.current.push(data);\r\n  };\r\n\r\n  const startRecording = async () => {\r\n    if (!mediaStream.current) {\r\n      await getMediaStream();\r\n    }\r\n    if (mediaStream.current) {\r\n      const isStreamEnded = mediaStream.current\r\n        .getTracks()\r\n        .some((track) => track.readyState === \"ended\");\r\n      if (isStreamEnded) {\r\n        await getMediaStream();\r\n      }\r\n\r\n      if (!mediaStream.current.active) {\r\n        return;\r\n      }\r\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\r\n      mediaRecorder.current.ondataavailable = onRecordingActive;\r\n      mediaRecorder.current.onstop = onRecordingStop;\r\n      mediaRecorder.current.start();\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorder.current) {\r\n      if (mediaRecorder.current.state !== \"inactive\") {\r\n        mediaRecorder.current.stop();\r\n        mediaStream.current &&\r\n          mediaStream.current.getTracks().forEach((track) => track.stop());\r\n        mediaChunks.current = [];\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <button onClick={startRecording}>Start Recording</button>\r\n      <button onClick={stopRecording}>Stop Recording</button>\r\n      <video src={mediaBlobUrl} controls autoPlay loop />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default recording;\r\n"]},"metadata":{},"sourceType":"module"}