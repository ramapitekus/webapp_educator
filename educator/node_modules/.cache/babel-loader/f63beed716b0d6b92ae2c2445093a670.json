{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { connectivity, type } from \"../common.speech/Exports\";\nimport { AudioSourceErrorEvent, AudioSourceInitializingEvent, AudioSourceOffEvent, AudioSourceReadyEvent, AudioStreamNodeAttachedEvent, AudioStreamNodeAttachingEvent, AudioStreamNodeDetachedEvent, AudioStreamNodeErrorEvent, ChunkedArrayBufferStream, createNoDashGuid, Deferred, Events, EventSource } from \"../common/Exports\";\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\nexport class MicAudioSource {\n  constructor(privRecorder, deviceId, audioSourceId, mediaStream) {\n    this.privRecorder = privRecorder;\n    this.deviceId = deviceId;\n    this.privStreams = {};\n\n    this.turnOn = () => {\n      if (this.privInitializeDeferral) {\n        return this.privInitializeDeferral.promise;\n      }\n\n      this.privInitializeDeferral = new Deferred();\n\n      try {\n        this.createAudioContext();\n      } catch (error) {\n        if (error instanceof Error) {\n          const typedError = error;\n          this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\n        } else {\n          this.privInitializeDeferral.reject(error);\n        }\n\n        return this.privInitializeDeferral.promise;\n      }\n\n      const nav = window.navigator;\n      let getUserMedia = nav.getUserMedia || nav.webkitGetUserMedia || nav.mozGetUserMedia || nav.msGetUserMedia;\n\n      if (!!nav.mediaDevices) {\n        getUserMedia = (constraints, successCallback, errorCallback) => {\n          nav.mediaDevices.getUserMedia(constraints).then(successCallback).catch(errorCallback);\n        };\n      }\n\n      if (!getUserMedia) {\n        const errorMsg = \"Browser does not support getUserMedia.\";\n        this.privInitializeDeferral.reject(errorMsg);\n        this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\n      } else {\n        const next = () => {\n          this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\n\n          if (this.privMediaStream && this.privMediaStream.active) {\n            this.onEvent(new AudioSourceReadyEvent(this.privId));\n            this.privInitializeDeferral.resolve();\n          } else {\n            getUserMedia({\n              audio: this.deviceId ? {\n                deviceId: this.deviceId\n              } : true,\n              video: false\n            }, mediaStream => {\n              this.privMediaStream = mediaStream;\n              this.onEvent(new AudioSourceReadyEvent(this.privId));\n              this.privInitializeDeferral.resolve();\n            }, error => {\n              const errorMsg = `Error occurred during microphone initialization: ${error}`;\n              this.privInitializeDeferral.reject(errorMsg);\n              this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\n            });\n          }\n        };\n\n        if (this.privContext.state === \"suspended\") {\n          // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\n          // https://github.com/WebAudio/web-audio-api/issues/790\n          this.privContext.resume().then(next).catch(reason => {\n            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\n          });\n        } else {\n          next();\n        }\n      }\n\n      return this.privInitializeDeferral.promise;\n    };\n\n    this.id = () => {\n      return this.privId;\n    };\n\n    this.attach = audioNodeId => {\n      this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\n      return this.listen(audioNodeId).then(stream => {\n        this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\n        return {\n          detach: () => __awaiter(this, void 0, void 0, function* () {\n            stream.readEnded();\n            delete this.privStreams[audioNodeId];\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n            return this.turnOff();\n          }),\n          id: () => {\n            return audioNodeId;\n          },\n          read: () => {\n            return stream.read();\n          }\n        };\n      });\n    };\n\n    this.detach = audioNodeId => {\n      if (audioNodeId && this.privStreams[audioNodeId]) {\n        this.privStreams[audioNodeId].close();\n        delete this.privStreams[audioNodeId];\n        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\n      }\n    };\n\n    this.listen = audioNodeId => __awaiter(this, void 0, void 0, function* () {\n      yield this.turnOn();\n      const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\n      this.privStreams[audioNodeId] = stream;\n\n      try {\n        this.privRecorder.record(this.privContext, this.privMediaStream, stream);\n      } catch (error) {\n        this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\n        throw error;\n      }\n\n      const result = stream;\n      return result;\n    });\n\n    this.onEvent = event => {\n      this.privEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    };\n\n    this.createAudioContext = () => {\n      if (!!this.privContext) {\n        return;\n      }\n\n      this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\n    };\n\n    this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\n    this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\n    this.privEvents = new EventSource();\n    this.privMediaStream = mediaStream || null;\n    this.privIsClosing = false;\n  }\n\n  get format() {\n    return Promise.resolve(MicAudioSource.AUDIOFORMAT);\n  }\n\n  get blob() {\n    return Promise.reject(\"Not implemented for Mic input\");\n  }\n\n  turnOff() {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const streamId in this.privStreams) {\n        if (streamId) {\n          const stream = this.privStreams[streamId];\n\n          if (stream) {\n            stream.close();\n          }\n        }\n      }\n\n      this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\n\n      if (this.privInitializeDeferral) {\n        // Correctly handle when browser forces mic off before turnOn() completes\n        yield this.privInitializeDeferral;\n        this.privInitializeDeferral = null;\n      }\n\n      yield this.destroyAudioContext();\n      return;\n    });\n  }\n\n  get events() {\n    return this.privEvents;\n  }\n\n  get deviceInfo() {\n    return this.getMicrophoneLabel().then(label => {\n      return {\n        bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\n        channelcount: MicAudioSource.AUDIOFORMAT.channels,\n        connectivity: connectivity.Unknown,\n        manufacturer: \"Speech SDK\",\n        model: label,\n        samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\n        type: type.Microphones\n      };\n    });\n  }\n\n  setProperty(name, value) {\n    if (name === AudioWorkletSourceURLPropertyName) {\n      this.privRecorder.setWorkletUrl(value);\n    } else {\n      throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\n    }\n  }\n\n  getMicrophoneLabel() {\n    const defaultMicrophoneName = \"microphone\"; // If we did this already, return the value.\n\n    if (this.privMicrophoneLabel !== undefined) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    } // If the stream isn't currently running, we can't query devices because security.\n\n\n    if (this.privMediaStream === undefined || !this.privMediaStream.active) {\n      return Promise.resolve(defaultMicrophoneName);\n    } // Setup a default\n\n\n    this.privMicrophoneLabel = defaultMicrophoneName; // Get the id of the device running the audio track.\n\n    const microphoneDeviceId = this.privMediaStream.getTracks()[0].getSettings().deviceId; // If the browser doesn't support getting the device ID, set a default and return.\n\n    if (undefined === microphoneDeviceId) {\n      return Promise.resolve(this.privMicrophoneLabel);\n    }\n\n    const deferred = new Deferred(); // Enumerate the media devices.\n\n    navigator.mediaDevices.enumerateDevices().then(devices => {\n      for (const device of devices) {\n        if (device.deviceId === microphoneDeviceId) {\n          // Found the device\n          this.privMicrophoneLabel = device.label;\n          break;\n        }\n      }\n\n      deferred.resolve(this.privMicrophoneLabel);\n    }, () => deferred.resolve(this.privMicrophoneLabel));\n    return deferred.promise;\n  }\n\n  destroyAudioContext() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privContext) {\n        return;\n      }\n\n      this.privRecorder.releaseMediaResources(this.privContext); // This pattern brought to you by a bug in the TypeScript compiler where it\n      // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\n      // https://github.com/Microsoft/TypeScript/issues/11498\n\n      let hasClose = false;\n\n      if (\"close\" in this.privContext) {\n        hasClose = true;\n      }\n\n      if (hasClose) {\n        if (!this.privIsClosing) {\n          // The audio context close may take enough time that the close is called twice\n          this.privIsClosing = true;\n          yield this.privContext.close();\n          this.privContext = null;\n          this.privIsClosing = false;\n        }\n      } else if (null !== this.privContext && this.privContext.state === \"running\") {\n        // Suspend actually takes a callback, but analogous to the\n        // resume method, it'll be only fired if suspend is called\n        // in a direct response to a user action. The later is not always\n        // the case, as TurnOff is also called, when we receive an\n        // end-of-speech message from the service. So, doing a best effort\n        // fire-and-forget here.\n        yield this.privContext.suspend();\n      }\n    });\n  }\n\n}\nMicAudioSource.AUDIOFORMAT = AudioStreamFormat.getDefaultInputFormat();","map":{"version":3,"mappings":"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","names":["connectivity","type","AudioSourceErrorEvent","AudioSourceInitializingEvent","AudioSourceOffEvent","AudioSourceReadyEvent","AudioStreamNodeAttachedEvent","AudioStreamNodeAttachingEvent","AudioStreamNodeDetachedEvent","AudioStreamNodeErrorEvent","ChunkedArrayBufferStream","createNoDashGuid","Deferred","Events","EventSource","AudioStreamFormat","AudioStreamFormatImpl","AudioWorkletSourceURLPropertyName","MicAudioSource","constructor","privRecorder","deviceId","audioSourceId","mediaStream","privInitializeDeferral","promise","createAudioContext","error","Error","typedError","reject","name","message","nav","window","navigator","getUserMedia","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","mediaDevices","constraints","successCallback","errorCallback","then","catch","errorMsg","onEvent","next","privId","privMediaStream","active","resolve","audio","video","privContext","state","resume","reason","audioNodeId","listen","stream","detach","__awaiter","readEnded","privStreams","turnOff","id","read","close","turnOn","privOutputChunkSize","record","result","event","privEvents","instance","getAudioContext","AUDIOFORMAT","samplesPerSec","avgBytesPerSec","privIsClosing","format","Promise","blob","streamId","destroyAudioContext","events","deviceInfo","getMicrophoneLabel","label","bitspersample","bitsPerSample","channelcount","channels","Unknown","manufacturer","model","samplerate","Microphones","setProperty","value","setWorkletUrl","defaultMicrophoneName","privMicrophoneLabel","undefined","microphoneDeviceId","getTracks","getSettings","deferred","enumerateDevices","devices","device","releaseMediaResources","hasClose","suspend","getDefaultInputFormat"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.browser\\src\\common.browser\\MicAudioSource.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    ChunkedArrayBufferStream,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Stream,\r\n} from \"../common/Exports\";\r\nimport {\r\n    AudioStreamFormat,\r\n    AudioStreamFormatImpl,\r\n} from \"../sdk/Audio/AudioStreamFormat\";\r\nimport { IRecorder } from \"./IRecorder\";\r\n\r\n// Extending the default definition with browser specific definitions for backward compatibility\r\ninterface INavigator extends Navigator {\r\n    webkitGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    mozGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n    msGetUserMedia?: (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback) => void;\r\n}\r\n\r\nexport const AudioWorkletSourceURLPropertyName = \"MICROPHONE-WorkletSourceUrl\";\r\n\r\nexport class MicAudioSource implements IAudioSource {\r\n\r\n    private static readonly AUDIOFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getDefaultInputFormat() as AudioStreamFormatImpl;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privInitializeDeferral: Deferred<void>;\r\n\r\n    private privMediaStream: MediaStream;\r\n\r\n    private privContext: AudioContext;\r\n\r\n    private privMicrophoneLabel: string;\r\n\r\n    private privOutputChunkSize: number;\r\n\r\n    private privIsClosing: boolean;\r\n\r\n    public constructor(\r\n        private readonly privRecorder: IRecorder,\r\n        private readonly deviceId?: string,\r\n        audioSourceId?: string,\r\n        mediaStream?: MediaStream\r\n        ) {\r\n\r\n        this.privOutputChunkSize = MicAudioSource.AUDIOFORMAT.avgBytesPerSec / 10;\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privMediaStream = mediaStream || null;\r\n        this.privIsClosing = false;\r\n    }\r\n\r\n    public get format(): Promise<AudioStreamFormatImpl> {\r\n        return Promise.resolve(MicAudioSource.AUDIOFORMAT);\r\n    }\r\n\r\n    public get blob(): Promise<Blob> {\r\n        return Promise.reject(\"Not implemented for Mic input\");\r\n    }\r\n\r\n    public turnOn = (): Promise<void> => {\r\n        if (this.privInitializeDeferral) {\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        this.privInitializeDeferral = new Deferred<void>();\r\n\r\n        try {\r\n            this.createAudioContext();\r\n        } catch (error) {\r\n            if (error instanceof Error) {\r\n                const typedError: Error = error as Error;\r\n                this.privInitializeDeferral.reject(typedError.name + \": \" + typedError.message);\r\n            } else {\r\n                this.privInitializeDeferral.reject(error);\r\n            }\r\n            return this.privInitializeDeferral.promise;\r\n        }\r\n\r\n        const nav = window.navigator as INavigator;\r\n\r\n        let getUserMedia = (\r\n            nav.getUserMedia ||\r\n            nav.webkitGetUserMedia ||\r\n            nav.mozGetUserMedia ||\r\n            nav.msGetUserMedia\r\n        );\r\n\r\n        if (!!nav.mediaDevices) {\r\n            getUserMedia = (constraints: MediaStreamConstraints, successCallback: NavigatorUserMediaSuccessCallback, errorCallback: NavigatorUserMediaErrorCallback): void => {\r\n                nav.mediaDevices\r\n                    .getUserMedia(constraints)\r\n                    .then(successCallback)\r\n                    .catch(errorCallback);\r\n            };\r\n        }\r\n\r\n        if (!getUserMedia) {\r\n            const errorMsg = \"Browser does not support getUserMedia.\";\r\n            this.privInitializeDeferral.reject(errorMsg);\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // mic initialized error - no streamid at this point\r\n        } else {\r\n            const next = () => {\r\n                this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n                if (this.privMediaStream && this.privMediaStream.active) {\r\n                    this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                    this.privInitializeDeferral.resolve();\r\n                } else {\r\n                    getUserMedia(\r\n                        { audio: this.deviceId ? { deviceId: this.deviceId } : true, video: false },\r\n                        (mediaStream: MediaStream) => {\r\n                            this.privMediaStream = mediaStream;\r\n                            this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n                            this.privInitializeDeferral.resolve();\r\n                        }, (error: MediaStreamError) => {\r\n                            const errorMsg = `Error occurred during microphone initialization: ${error}`;\r\n                            this.privInitializeDeferral.reject(errorMsg);\r\n                            this.onEvent(new AudioSourceErrorEvent(this.privId, errorMsg));\r\n                        });\r\n                }\r\n            };\r\n\r\n            if (this.privContext.state === \"suspended\") {\r\n                // NOTE: On iOS, the Web Audio API requires sounds to be triggered from an explicit user action.\r\n                // https://github.com/WebAudio/web-audio-api/issues/790\r\n                this.privContext.resume()\r\n                    .then(next)\r\n                    .catch((reason: any) => {\r\n                        this.privInitializeDeferral.reject(`Failed to initialize audio context: ${reason}`);\r\n                    });\r\n            } else {\r\n                next();\r\n            }\r\n        }\r\n\r\n        return this.privInitializeDeferral.promise;\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.listen(audioNodeId).then<IAudioStreamNode>(\r\n            (stream: Stream<ArrayBuffer>) => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: async () => {\r\n                        stream.readEnded();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                        return this.turnOff();\r\n                    },\r\n                    id: () => {\r\n                        return audioNodeId;\r\n                    },\r\n                    read: () => {\r\n                        return stream.read();\r\n                    },\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public async turnOff(): Promise<void> {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        if (this.privInitializeDeferral) {\r\n            // Correctly handle when browser forces mic off before turnOn() completes\r\n            await this.privInitializeDeferral;\r\n            this.privInitializeDeferral = null;\r\n        }\r\n\r\n        await this.destroyAudioContext();\r\n\r\n        return;\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return this.getMicrophoneLabel().then((label: string) => {\r\n            return {\r\n                bitspersample: MicAudioSource.AUDIOFORMAT.bitsPerSample,\r\n                channelcount: MicAudioSource.AUDIOFORMAT.channels,\r\n                connectivity: connectivity.Unknown,\r\n                manufacturer: \"Speech SDK\",\r\n                model: label,\r\n                samplerate: MicAudioSource.AUDIOFORMAT.samplesPerSec,\r\n                type: type.Microphones,\r\n            };\r\n        });\r\n    }\r\n\r\n    public setProperty(name: string, value: string): void {\r\n        if (name === AudioWorkletSourceURLPropertyName) {\r\n            this.privRecorder.setWorkletUrl(value);\r\n        } else {\r\n            throw new Error(\"Property '\" + name + \"' is not supported on Microphone.\");\r\n        }\r\n    }\r\n\r\n    private getMicrophoneLabel(): Promise<string> {\r\n        const defaultMicrophoneName: string = \"microphone\";\r\n\r\n        // If we did this already, return the value.\r\n        if (this.privMicrophoneLabel !== undefined) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        // If the stream isn't currently running, we can't query devices because security.\r\n        if (this.privMediaStream === undefined || !this.privMediaStream.active) {\r\n            return Promise.resolve(defaultMicrophoneName);\r\n        }\r\n\r\n        // Setup a default\r\n        this.privMicrophoneLabel = defaultMicrophoneName;\r\n\r\n        // Get the id of the device running the audio track.\r\n        const microphoneDeviceId: string = this.privMediaStream.getTracks()[0].getSettings().deviceId;\r\n\r\n        // If the browser doesn't support getting the device ID, set a default and return.\r\n        if (undefined === microphoneDeviceId) {\r\n            return Promise.resolve(this.privMicrophoneLabel);\r\n        }\r\n\r\n        const deferred: Deferred<string> = new Deferred<string>();\r\n\r\n        // Enumerate the media devices.\r\n        navigator.mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]) => {\r\n            for (const device of devices) {\r\n                if (device.deviceId === microphoneDeviceId) {\r\n                    // Found the device\r\n                    this.privMicrophoneLabel = device.label;\r\n                    break;\r\n                }\r\n            }\r\n            deferred.resolve(this.privMicrophoneLabel);\r\n        }, () => deferred.resolve(this.privMicrophoneLabel));\r\n\r\n        return deferred.promise;\r\n    }\r\n\r\n    private listen = async (audioNodeId: string): Promise<Stream<ArrayBuffer>> => {\r\n        await this.turnOn();\r\n        const stream = new ChunkedArrayBufferStream(this.privOutputChunkSize, audioNodeId);\r\n        this.privStreams[audioNodeId] = stream;\r\n        try {\r\n            this.privRecorder.record(this.privContext, this.privMediaStream, stream);\r\n        } catch (error) {\r\n            this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, error));\r\n            throw error;\r\n        }\r\n        const result: Stream<ArrayBuffer> = stream;\r\n        return result;\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private createAudioContext = (): void => {\r\n        if (!!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privContext = AudioStreamFormatImpl.getAudioContext(MicAudioSource.AUDIOFORMAT.samplesPerSec);\r\n    }\r\n\r\n    private async destroyAudioContext(): Promise<void> {\r\n        if (!this.privContext) {\r\n            return;\r\n        }\r\n\r\n        this.privRecorder.releaseMediaResources(this.privContext);\r\n\r\n        // This pattern brought to you by a bug in the TypeScript compiler where it\r\n        // confuses the (\"close\" in this.privContext) with this.privContext always being null as the alternate.\r\n        // https://github.com/Microsoft/TypeScript/issues/11498\r\n        let hasClose: boolean = false;\r\n        if (\"close\" in this.privContext) {\r\n            hasClose = true;\r\n        }\r\n\r\n        if (hasClose) {\r\n            if (!this.privIsClosing) {\r\n                // The audio context close may take enough time that the close is called twice\r\n                this.privIsClosing = true;\r\n                await this.privContext.close();\r\n                this.privContext = null;\r\n                this.privIsClosing = false;\r\n            }\r\n        } else if (null !== this.privContext && this.privContext.state === \"running\") {\r\n            // Suspend actually takes a callback, but analogous to the\r\n            // resume method, it'll be only fired if suspend is called\r\n            // in a direct response to a user action. The later is not always\r\n            // the case, as TurnOff is also called, when we receive an\r\n            // end-of-speech message from the service. So, doing a best effort\r\n            // fire-and-forget here.\r\n            await this.privContext.suspend();\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}