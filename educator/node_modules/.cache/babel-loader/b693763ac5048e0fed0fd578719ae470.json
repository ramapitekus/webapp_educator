{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useCallback, useEffect, useRef, useState } from \"react\";\nexport let RecorderErrors;\n\n(function (RecorderErrors) {\n  RecorderErrors[\"AbortError\"] = \"media_aborted\";\n  RecorderErrors[\"NotAllowedError\"] = \"permission_denied\";\n  RecorderErrors[\"NotFoundError\"] = \"no_specified_media_found\";\n  RecorderErrors[\"NotReadableError\"] = \"media_in_use\";\n  RecorderErrors[\"OverconstrainedError\"] = \"invalid_media_constraints\";\n  RecorderErrors[\"TypeError\"] = \"no_constraints\";\n  RecorderErrors[\"NONE\"] = \"\";\n  RecorderErrors[\"NO_RECORDER\"] = \"recorder_error\";\n})(RecorderErrors || (RecorderErrors = {}));\n\nexport function useReactMediaRecorder(_ref) {\n  _s();\n\n  let {\n    audio = true,\n    video = false,\n    onStop = () => null,\n    blobPropertyBag,\n    screen = false,\n    mediaRecorderOptions = null,\n    askPermissionOnMount = false\n  } = _ref;\n  const mediaRecorder = useRef(null);\n  const mediaChunks = useRef([]);\n  const mediaStream = useRef(null);\n  const [status, setStatus] = useState(\"idle\");\n  const [mediaBlobUrl, setMediaBlobUrl] = useState(null);\n  const [error, setError] = useState(\"NONE\");\n  const getMediaStream = useCallback(async () => {\n    setStatus(\"acquiring_media\");\n    const requiredMedia = {\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\n      video: typeof video === \"boolean\" ? !!video : video\n    };\n\n    try {\n      if (screen) {\n        //@ts-ignore\n        const stream = await window.navigator.mediaDevices.getDisplayMedia({\n          video: video || true\n        });\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\n          stopRecording();\n        });\n\n        if (audio) {\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\n            audio\n          });\n          audioStream.getAudioTracks().forEach(audioTrack => stream.addTrack(audioTrack));\n        }\n\n        mediaStream.current = stream;\n      } else {\n        const stream = await window.navigator.mediaDevices.getUserMedia(requiredMedia);\n        mediaStream.current = stream;\n      }\n\n      setStatus(\"idle\");\n    } catch (error) {\n      setError(error.name);\n      setStatus(\"idle\");\n    }\n  }, [audio, video, screen]);\n  useEffect(() => {\n    if (!window.MediaRecorder) {\n      throw new Error(\"Unsupported Browser\");\n    }\n\n    if (screen) {\n      //@ts-ignore\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\n        throw new Error(\"This browser doesn't support screen capturing\");\n      }\n    }\n\n    const checkConstraints = mediaType => {\n      const supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();\n      const unSupportedConstraints = Object.keys(mediaType).filter(constraint => !supportedMediaConstraints[constraint]);\n\n      if (unSupportedConstraints.length > 0) {\n        console.error(`The constraints ${unSupportedConstraints.join(\",\")} doesn't support on this browser. Please check your ReactMediaRecorder component.`);\n      }\n    };\n\n    if (typeof audio === \"object\") {\n      checkConstraints(audio);\n    }\n\n    if (typeof video === \"object\") {\n      checkConstraints(video);\n    }\n\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\n        console.error(`The specified MIME type you supplied for MediaRecorder doesn't support this browser`);\n      }\n    }\n\n    if (!mediaStream.current && askPermissionOnMount) {\n      getMediaStream();\n    }\n\n    return () => {\n      if (mediaStream.current) {\n        const tracks = mediaStream.current.getTracks();\n        tracks.forEach(track => track.stop());\n      }\n    };\n  }, [audio, screen, video, getMediaStream, mediaRecorderOptions, askPermissionOnMount]); // Media Recorder Handlers\n\n  const startRecording = async () => {\n    setError(\"NONE\");\n\n    if (!mediaStream.current) {\n      await getMediaStream();\n    }\n\n    if (mediaStream.current) {\n      const isStreamEnded = mediaStream.current.getTracks().some(track => track.readyState === \"ended\");\n\n      if (isStreamEnded) {\n        await getMediaStream();\n      } // User blocked the permissions (getMediaStream errored out)\n\n\n      if (!mediaStream.current.active) {\n        return;\n      }\n\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\n      mediaRecorder.current.ondataavailable = onRecordingActive;\n      mediaRecorder.current.onstop = onRecordingStop;\n\n      mediaRecorder.current.onerror = () => {\n        setError(\"NO_RECORDER\");\n        setStatus(\"idle\");\n      };\n\n      mediaRecorder.current.start();\n      setStatus(\"recording\");\n    }\n  };\n\n  const onRecordingActive = _ref2 => {\n    let {\n      data\n    } = _ref2;\n    mediaChunks.current.push(data);\n  };\n\n  const onRecordingStop = () => {\n    const [chunk] = mediaChunks.current;\n    const blobProperty = Object.assign({\n      type: chunk.type\n    }, blobPropertyBag || (video ? {\n      type: \"video/mp4\"\n    } : {\n      type: \"audio/wav\"\n    }));\n    const blob = new Blob(mediaChunks.current, blobProperty);\n    const url = URL.createObjectURL(blob);\n    setStatus(\"stopped\");\n    setMediaBlobUrl(url);\n    onStop(url, blob);\n  };\n\n  const pauseRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\n      setStatus(\"paused\");\n      mediaRecorder.current.pause();\n    }\n  };\n\n  const resumeRecording = () => {\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\n      setStatus(\"recording\");\n      mediaRecorder.current.resume();\n    }\n  };\n\n  const stopRecording = () => {\n    if (mediaRecorder.current) {\n      if (mediaRecorder.current.state !== \"inactive\") {\n        setStatus(\"stopping\");\n        mediaRecorder.current.stop();\n        mediaStream.current && mediaStream.current.getTracks().forEach(track => track.stop());\n        mediaChunks.current = [];\n      }\n    }\n  };\n\n  return {\n    error: RecorderErrors[error],\n    startRecording,\n    pauseRecording,\n    resumeRecording,\n    stopRecording,\n    mediaBlobUrl,\n    status,\n    previewStream: mediaStream.current ? new MediaStream(mediaStream.current.getVideoTracks()) : null,\n    previewAudioStream: mediaStream.current ? new MediaStream(mediaStream.current.getAudioTracks()) : null,\n    clearBlobUrl: () => {\n      if (mediaBlobUrl) {\n        URL.revokeObjectURL(mediaBlobUrl);\n      }\n\n      setMediaBlobUrl(null);\n      setStatus(\"idle\");\n    }\n  };\n}\n\n_s(useReactMediaRecorder, \"obu07HZ+UwWpowZ6wSNiQp5vG6I=\");\n\nexport const ReactMediaRecorder = props => {\n  _s2();\n\n  return props.render(useReactMediaRecorder(props));\n};\n\n_s2(ReactMediaRecorder, \"nRhgjCUzn+Ducq/dfE3avdJQHVQ=\", false, function () {\n  return [useReactMediaRecorder];\n});\n\n_c = ReactMediaRecorder;\n\nvar _c;\n\n$RefreshReg$(_c, \"ReactMediaRecorder\");","map":{"version":3,"sources":["C:/Users/olesr/OneDrive/Documents/webapp_educ/educator/src/record.ts"],"names":["useCallback","useEffect","useRef","useState","RecorderErrors","useReactMediaRecorder","audio","video","onStop","blobPropertyBag","screen","mediaRecorderOptions","askPermissionOnMount","mediaRecorder","mediaChunks","mediaStream","status","setStatus","mediaBlobUrl","setMediaBlobUrl","error","setError","getMediaStream","requiredMedia","stream","window","navigator","mediaDevices","getDisplayMedia","getVideoTracks","addEventListener","stopRecording","audioStream","getUserMedia","getAudioTracks","forEach","audioTrack","addTrack","current","name","MediaRecorder","Error","checkConstraints","mediaType","supportedMediaConstraints","getSupportedConstraints","unSupportedConstraints","Object","keys","filter","constraint","length","console","join","mimeType","isTypeSupported","tracks","getTracks","track","stop","startRecording","isStreamEnded","some","readyState","active","ondataavailable","onRecordingActive","onstop","onRecordingStop","onerror","start","data","push","chunk","blobProperty","assign","type","blob","Blob","url","URL","createObjectURL","pauseRecording","state","pause","resumeRecording","resume","previewStream","MediaStream","previewAudioStream","clearBlobUrl","revokeObjectURL","ReactMediaRecorder","props","render"],"mappings":"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","sourcesContent":["import { ReactElement, useCallback, useEffect, useRef, useState } from \"react\";\r\n\r\nexport type ReactMediaRecorderRenderProps = {\r\n  error: string;\r\n  startRecording: () => void;\r\n  pauseRecording: () => void;\r\n  resumeRecording: () => void;\r\n  stopRecording: () => void;\r\n  mediaBlobUrl: null | string;\r\n  status: StatusMessages;\r\n  previewStream: MediaStream | null;\r\n  previewAudioStream: MediaStream | null;\r\n  clearBlobUrl: () => void;\r\n};\r\n\r\nexport type ReactMediaRecorderHookProps = {\r\n  audio?: boolean | MediaTrackConstraints;\r\n  video?: boolean | MediaTrackConstraints;\r\n  screen?: boolean;\r\n  onStop?: (blobUrl: string, blob: Blob) => void;\r\n  blobPropertyBag?: BlobPropertyBag;\r\n  mediaRecorderOptions?: MediaRecorderOptions | null;\r\n  askPermissionOnMount?: boolean;\r\n};\r\nexport type ReactMediaRecorderProps = ReactMediaRecorderHookProps & {\r\n  render: (props: ReactMediaRecorderRenderProps) => ReactElement;\r\n};\r\n\r\nexport type StatusMessages =\r\n  | \"media_aborted\"\r\n  | \"permission_denied\"\r\n  | \"no_specified_media_found\"\r\n  | \"media_in_use\"\r\n  | \"invalid_media_constraints\"\r\n  | \"no_constraints\"\r\n  | \"recorder_error\"\r\n  | \"idle\"\r\n  | \"acquiring_media\"\r\n  | \"delayed_start\"\r\n  | \"recording\"\r\n  | \"stopping\"\r\n  | \"stopped\"\r\n  | \"paused\";\r\n\r\nexport enum RecorderErrors {\r\n  AbortError = \"media_aborted\",\r\n  NotAllowedError = \"permission_denied\",\r\n  NotFoundError = \"no_specified_media_found\",\r\n  NotReadableError = \"media_in_use\",\r\n  OverconstrainedError = \"invalid_media_constraints\",\r\n  TypeError = \"no_constraints\",\r\n  NONE = \"\",\r\n  NO_RECORDER = \"recorder_error\",\r\n}\r\n\r\nexport function useReactMediaRecorder({\r\n  audio = true,\r\n  video = false,\r\n  onStop = () => null,\r\n  blobPropertyBag,\r\n  screen = false,\r\n  mediaRecorderOptions = null,\r\n  askPermissionOnMount = false,\r\n}: ReactMediaRecorderHookProps): ReactMediaRecorderRenderProps {\r\n  const mediaRecorder = useRef<MediaRecorder | null>(null);\r\n  const mediaChunks = useRef<Blob[]>([]);\r\n  const mediaStream = useRef<MediaStream | null>(null);\r\n  const [status, setStatus] = useState<StatusMessages>(\"idle\");\r\n  const [mediaBlobUrl, setMediaBlobUrl] = useState<string | null>(null);\r\n  const [error, setError] = useState<keyof typeof RecorderErrors>(\"NONE\");\r\n\r\n  const getMediaStream = useCallback(async () => {\r\n    setStatus(\"acquiring_media\");\r\n    const requiredMedia: MediaStreamConstraints = {\r\n      audio: typeof audio === \"boolean\" ? !!audio : audio,\r\n      video: typeof video === \"boolean\" ? !!video : video,\r\n    };\r\n    try {\r\n      if (screen) {\r\n        //@ts-ignore\r\n        const stream = (await window.navigator.mediaDevices.getDisplayMedia({\r\n          video: video || true,\r\n        })) as MediaStream;\r\n        stream.getVideoTracks()[0].addEventListener(\"ended\", () => {\r\n          stopRecording();\r\n        });\r\n        if (audio) {\r\n          const audioStream = await window.navigator.mediaDevices.getUserMedia({\r\n            audio,\r\n          });\r\n\r\n          audioStream\r\n            .getAudioTracks()\r\n            .forEach((audioTrack) => stream.addTrack(audioTrack));\r\n        }\r\n        mediaStream.current = stream;\r\n      } else {\r\n        const stream = await window.navigator.mediaDevices.getUserMedia(\r\n          requiredMedia\r\n        );\r\n        mediaStream.current = stream;\r\n      }\r\n      setStatus(\"idle\");\r\n    } catch (error: any) {\r\n      setError(error.name);\r\n      setStatus(\"idle\");\r\n    }\r\n  }, [audio, video, screen]);\r\n\r\n  useEffect(() => {\r\n    if (!window.MediaRecorder) {\r\n      throw new Error(\"Unsupported Browser\");\r\n    }\r\n\r\n    if (screen) {\r\n      //@ts-ignore\r\n      if (!window.navigator.mediaDevices.getDisplayMedia) {\r\n        throw new Error(\"This browser doesn't support screen capturing\");\r\n      }\r\n    }\r\n\r\n    const checkConstraints = (mediaType: MediaTrackConstraints) => {\r\n      const supportedMediaConstraints =\r\n        navigator.mediaDevices.getSupportedConstraints();\r\n      const unSupportedConstraints = Object.keys(mediaType).filter(\r\n        (constraint) =>\r\n          !(supportedMediaConstraints as { [key: string]: any })[constraint]\r\n      );\r\n\r\n      if (unSupportedConstraints.length > 0) {\r\n        console.error(\r\n          `The constraints ${unSupportedConstraints.join(\r\n            \",\"\r\n          )} doesn't support on this browser. Please check your ReactMediaRecorder component.`\r\n        );\r\n      }\r\n    };\r\n\r\n    if (typeof audio === \"object\") {\r\n      checkConstraints(audio);\r\n    }\r\n    if (typeof video === \"object\") {\r\n      checkConstraints(video);\r\n    }\r\n\r\n    if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {\r\n      if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {\r\n        console.error(\r\n          `The specified MIME type you supplied for MediaRecorder doesn't support this browser`\r\n        );\r\n      }\r\n    }\r\n\r\n    if (!mediaStream.current && askPermissionOnMount) {\r\n      getMediaStream();\r\n    }\r\n\r\n    return () => {\r\n      if (mediaStream.current) {\r\n        const tracks = mediaStream.current.getTracks();\r\n        tracks.forEach((track) => track.stop());\r\n      }\r\n    };\r\n  }, [\r\n    audio,\r\n    screen,\r\n    video,\r\n    getMediaStream,\r\n    mediaRecorderOptions,\r\n    askPermissionOnMount,\r\n  ]);\r\n\r\n  // Media Recorder Handlers\r\n\r\n  const startRecording = async () => {\r\n    setError(\"NONE\");\r\n    if (!mediaStream.current) {\r\n      await getMediaStream();\r\n    }\r\n    if (mediaStream.current) {\r\n      const isStreamEnded = mediaStream.current\r\n        .getTracks()\r\n        .some((track) => track.readyState === \"ended\");\r\n      if (isStreamEnded) {\r\n        await getMediaStream();\r\n      }\r\n\r\n      // User blocked the permissions (getMediaStream errored out)\r\n      if (!mediaStream.current.active) {\r\n        return;\r\n      }\r\n      mediaRecorder.current = new MediaRecorder(mediaStream.current);\r\n      mediaRecorder.current.ondataavailable = onRecordingActive;\r\n      mediaRecorder.current.onstop = onRecordingStop;\r\n      mediaRecorder.current.onerror = () => {\r\n        setError(\"NO_RECORDER\");\r\n        setStatus(\"idle\");\r\n      };\r\n      mediaRecorder.current.start();\r\n      setStatus(\"recording\");\r\n    }\r\n  };\r\n\r\n  const onRecordingActive = ({ data }: BlobEvent) => {\r\n    mediaChunks.current.push(data);\r\n  };\r\n\r\n  const onRecordingStop = () => {\r\n    const [chunk] = mediaChunks.current;\r\n    const blobProperty: BlobPropertyBag = Object.assign(\r\n      { type: chunk.type },\r\n      blobPropertyBag || (video ? { type: \"video/mp4\" } : { type: \"audio/wav\" })\r\n    );\r\n    const blob = new Blob(mediaChunks.current, blobProperty);\r\n    const url = URL.createObjectURL(blob);\r\n    setStatus(\"stopped\");\r\n    setMediaBlobUrl(url);\r\n    onStop(url, blob);\r\n  };\r\n\r\n  const pauseRecording = () => {\r\n    if (mediaRecorder.current && mediaRecorder.current.state === \"recording\") {\r\n      setStatus(\"paused\");\r\n      mediaRecorder.current.pause();\r\n    }\r\n  };\r\n  const resumeRecording = () => {\r\n    if (mediaRecorder.current && mediaRecorder.current.state === \"paused\") {\r\n      setStatus(\"recording\");\r\n      mediaRecorder.current.resume();\r\n    }\r\n  };\r\n\r\n  const stopRecording = () => {\r\n    if (mediaRecorder.current) {\r\n      if (mediaRecorder.current.state !== \"inactive\") {\r\n        setStatus(\"stopping\");\r\n        mediaRecorder.current.stop();\r\n        mediaStream.current &&\r\n          mediaStream.current.getTracks().forEach((track) => track.stop());\r\n        mediaChunks.current = [];\r\n      }\r\n    }\r\n  };\r\n\r\n  return {\r\n    error: RecorderErrors[error],\r\n    startRecording,\r\n    pauseRecording,\r\n    resumeRecording,\r\n    stopRecording,\r\n    mediaBlobUrl,\r\n    status,\r\n    previewStream: mediaStream.current\r\n      ? new MediaStream(mediaStream.current.getVideoTracks())\r\n      : null,\r\n    previewAudioStream: mediaStream.current\r\n      ? new MediaStream(mediaStream.current.getAudioTracks())\r\n      : null,\r\n    clearBlobUrl: () => {\r\n      if (mediaBlobUrl) {\r\n        URL.revokeObjectURL(mediaBlobUrl);\r\n      }\r\n      setMediaBlobUrl(null);\r\n      setStatus(\"idle\");\r\n    },\r\n  };\r\n}\r\n\r\nexport const ReactMediaRecorder = (props: ReactMediaRecorderProps) =>\r\n  props.render(useReactMediaRecorder(props));"]},"metadata":{},"sourceType":"module"}