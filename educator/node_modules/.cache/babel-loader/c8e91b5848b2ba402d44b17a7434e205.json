{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createNoDashGuid, Deferred } from \"../../common/Exports\";\n/**\r\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\r\n * TODO: define what telemetry is required.\r\n */\n\nexport class ConversationRequestSession {\n  constructor(sessionId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n\n    this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n      this.privSessionId = connectionId;\n    };\n\n    this.onAuthCompleted = (isError, error) => {\n      if (isError) {\n        this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = (statusCode, reason) => {\n      if (statusCode === 200) {\n        return;\n      } else if (statusCode === 403) {\n        this.onComplete();\n      }\n    };\n\n    this.onServiceTurnEndResponse = continuousRecognition => {\n      if (!continuousRecognition) {\n        this.onComplete();\n      } else {\n        this.privRequestId = createNoDashGuid();\n      }\n    };\n\n    this.onComplete = () => {//\n    };\n\n    this.privSessionId = sessionId;\n    this.privRequestId = createNoDashGuid();\n    this.privRequestCompletionDeferral = new Deferred();\n  }\n\n  get sessionId() {\n    return this.privSessionId;\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get completionPromise() {\n    return this.privRequestCompletionDeferral.promise;\n  }\n\n  dispose(error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SACIA,gBADJ,EAEIC,QAFJ,QAIO,sBAJP;AAMA;;;;;AAIA,OAAM,MAAOC,0BAAP,CAAiC;AAOnCC,cAAYC,SAAZ,EAA6B;AANrB,0BAA0B,KAA1B;AACA,2BAAiC,IAAIC,KAAJ,EAAjC;;AAuBD,gCAAuB,CAACC,gBAAD,EAA2BC,YAA3B,KAAyD;AACnF,WAAKC,aAAL,GAAqBD,YAArB;AACH,KAFM;;AAIA,2BAAkB,CAACE,OAAD,EAAmBC,KAAnB,KAA2C;AAChE,UAAID,OAAJ,EAAa;AACT,aAAKE,UAAL;AACH;AACJ,KAJM;;AAMA,0CAAiC,CAACC,UAAD,EAAqBC,MAArB,KAA8C;AAClF,UAAID,UAAU,KAAK,GAAnB,EAAwB;AACpB;AACH,OAFD,MAEO,IAAIA,UAAU,KAAK,GAAnB,EAAwB;AAC3B,aAAKD,UAAL;AACH;AACJ,KANM;;AAQA,oCAA4BG,qBAAD,IAAyC;AACvE,UAAI,CAACA,qBAAL,EAA4B;AACxB,aAAKH,UAAL;AACH,OAFD,MAEO;AACH,aAAKI,aAAL,GAAqBf,gBAAgB,EAArC;AACH;AACJ,KANM;;AAkBC,sBAAa,MAAW,CAC5B;AACH,KAFO;;AArDJ,SAAKQ,aAAL,GAAqBJ,SAArB;AACA,SAAKW,aAAL,GAAqBf,gBAAgB,EAArC;AACA,SAAKgB,6BAAL,GAAqC,IAAIf,QAAJ,EAArC;AACH;;AAEmB,MAATG,SAAS;AAChB,WAAO,KAAKI,aAAZ;AACH;;AAEmB,MAATS,SAAS;AAChB,WAAO,KAAKF,aAAZ;AACH;;AAE2B,MAAjBG,iBAAiB;AACxB,WAAO,KAAKF,6BAAL,CAAmCG,OAA1C;AACH;;AA4BYC,SAAO,CAACV,KAAD,EAAe;;AAC/B,UAAI,CAAC,KAAKW,cAAV,EAA0B;AACtB;AACA,aAAKA,cAAL,GAAsB,IAAtB;;AACA,aAAK,MAAMC,UAAX,IAAyB,KAAKC,eAA9B,EAA+C;AAC3C,gBAAMD,UAAU,CAACE,MAAX,EAAN;AACH;AACJ;AACJ;AAAA;;AA3DkC","names":["createNoDashGuid","Deferred","ConversationRequestSession","constructor","sessionId","Array","authFetchEventId","connectionId","privSessionId","isError","error","onComplete","statusCode","reason","continuousRecognition","privRequestId","privRequestCompletionDeferral","requestId","completionPromise","promise","dispose","privIsDisposed","detachable","privDetachables","detach"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\Transcription\\src\\common.speech\\Transcription\\ConversationRequestSession.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    IDetachable,\r\n} from \"../../common/Exports\";\r\n\r\n/**\r\n * Placeholder class for the Conversation Request Session. Based off RequestSession.\r\n * TODO: define what telemetry is required.\r\n */\r\nexport class ConversationRequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privRequestCompletionDeferral: Deferred<void>;\r\n    private privSessionId: string;\r\n\r\n    constructor(sessionId: string) {\r\n        this.privSessionId = sessionId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privRequestCompletionDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get completionPromise(): Promise<void> {\r\n        return this.privRequestCompletionDeferral.promise;\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privSessionId = connectionId;\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (continuousRecognition: boolean): void => {\r\n        if (!continuousRecognition) {\r\n            this.onComplete();\r\n        } else {\r\n            this.privRequestId = createNoDashGuid();\r\n        }\r\n    }\r\n\r\n    public async dispose(error?: string): Promise<void> {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        //\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}