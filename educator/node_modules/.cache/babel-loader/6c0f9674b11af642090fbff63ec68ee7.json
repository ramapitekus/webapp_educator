{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nimport { Deferred, MessageType, RawWebsocketMessage } from \"../../common/Exports\";\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\n/**\r\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\r\n */\n\nexport class ConversationWebsocketMessageFormatter {\n  constructor() {\n    /**\r\n     * Format incoming messages: text (speech partial/final, IM) or binary (tts)\r\n     */\n    this.toConnectionMessage = message => {\n      const deferral = new Deferred();\n\n      try {\n        if (message.messageType === MessageType.Text) {\n          const incomingMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\n          deferral.resolve(incomingMessage);\n        } else if (message.messageType === MessageType.Binary) {\n          deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\n        }\n      } catch (e) {\n        deferral.reject(`Error formatting the message. Error: ${e}`);\n      }\n\n      return deferral.promise;\n    };\n    /**\r\n     * Format outgoing messages: text (commands or IM)\r\n     */\n\n\n    this.fromConnectionMessage = message => {\n      const deferral = new Deferred();\n\n      try {\n        if (message.messageType === MessageType.Text) {\n          const payload = `${message.textBody ? message.textBody : \"\"}`;\n          deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\n        }\n      } catch (e) {\n        deferral.reject(`Error formatting the message. ${e}`);\n      }\n\n      return deferral.promise;\n    };\n  }\n\n}","map":{"version":3,"mappings":"AAAA;AACA;AAEA,SAEIA,QAFJ,EAKIC,WALJ,EAMIC,mBANJ,QAOO,sBAPP;AAQA,SAASC,6BAAT,QAA8C,iCAA9C;AAEA;;;;AAGA,OAAM,MAAOC,qCAAP,CAA4C;AAAlDC;AAEI;;;AAGO,+BAAuBC,OAAD,IAAyE;AAClG,YAAMC,QAAQ,GAAG,IAAIP,QAAJ,EAAjB;;AAEA,UAAI;AACA,YAAIM,OAAO,CAACE,WAAR,KAAwBP,WAAW,CAACQ,IAAxC,EAA8C;AAC1C,gBAAMC,eAAe,GAAkC,IAAIP,6BAAJ,CAAkCG,OAAO,CAACE,WAA1C,EAAuDF,OAAO,CAACK,WAA/D,EAA4E,EAA5E,EAAgFL,OAAO,CAACM,EAAxF,CAAvD;AACAL,kBAAQ,CAACM,OAAT,CAAiBH,eAAjB;AACH,SAHD,MAGO,IAAIJ,OAAO,CAACE,WAAR,KAAwBP,WAAW,CAACa,MAAxC,EAAgD;AACnDP,kBAAQ,CAACM,OAAT,CAAiB,IAAIV,6BAAJ,CAAkCG,OAAO,CAACE,WAA1C,EAAuDF,OAAO,CAACS,aAA/D,EAA8EC,SAA9E,EAAyFV,OAAO,CAACM,EAAjG,CAAjB;AACH;AACJ,OAPD,CAOE,OAAOK,CAAP,EAAU;AACRV,gBAAQ,CAACW,MAAT,CAAgB,wCAAwCD,CAAC,EAAzD;AACH;;AAED,aAAOV,QAAQ,CAACY,OAAhB;AACH,KAfM;AAiBP;;;;;AAGO,iCAAyBb,OAAD,IAA6D;AAExF,YAAMC,QAAQ,GAAG,IAAIP,QAAJ,EAAjB;;AAEA,UAAI;AACA,YAAIM,OAAO,CAACE,WAAR,KAAwBP,WAAW,CAACQ,IAAxC,EAA8C;AAC1C,gBAAMW,OAAO,GAAG,GAAGd,OAAO,CAACe,QAAR,GAAmBf,OAAO,CAACe,QAA3B,GAAsC,EAAE,EAA3D;AACAd,kBAAQ,CAACM,OAAT,CAAiB,IAAIX,mBAAJ,CAAwBD,WAAW,CAACQ,IAApC,EAA0CW,OAA1C,EAAmDd,OAAO,CAACM,EAA3D,CAAjB;AACH;AACJ,OALD,CAKE,OAAOK,CAAP,EAAU;AACRV,gBAAQ,CAACW,MAAT,CAAgB,iCAAiCD,CAAC,EAAlD;AACH;;AAED,aAAOV,QAAQ,CAACY,OAAhB;AACH,KAdM;AAeV;;AAxCiD","names":["Deferred","MessageType","RawWebsocketMessage","ConversationConnectionMessage","ConversationWebsocketMessageFormatter","constructor","message","deferral","messageType","Text","incomingMessage","textContent","id","resolve","Binary","binaryContent","undefined","e","reject","promise","payload","textBody"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\Transcription\\src\\common.speech\\Transcription\\ConversationWebsocketMessageFormatter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ConnectionMessage,\r\n    Deferred,\r\n    IStringDictionary,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    RawWebsocketMessage,\r\n} from \"../../common/Exports\";\r\nimport { ConversationConnectionMessage } from \"./ConversationConnectionMessage\";\r\n\r\n/**\r\n * Based off WebsocketMessageFormatter. The messages for Conversation Translator have some variations from the Speech messages.\r\n */\r\nexport class ConversationWebsocketMessageFormatter implements IWebsocketMessageFormatter {\r\n\r\n    /**\r\n     * Format incoming messages: text (speech partial/final, IM) or binary (tts)\r\n     */\r\n    public toConnectionMessage = (message: RawWebsocketMessage): Promise<ConversationConnectionMessage> => {\r\n        const deferral = new Deferred<ConversationConnectionMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const incomingMessage: ConversationConnectionMessage = new ConversationConnectionMessage(message.messageType, message.textContent, {}, message.id);\r\n                deferral.resolve(incomingMessage);\r\n            } else if (message.messageType === MessageType.Binary) {\r\n                deferral.resolve(new ConversationConnectionMessage(message.messageType, message.binaryContent, undefined, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. Error: ${e}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n\r\n    /**\r\n     * Format outgoing messages: text (commands or IM)\r\n     */\r\n    public fromConnectionMessage = (message: ConnectionMessage): Promise<RawWebsocketMessage> => {\r\n\r\n        const deferral = new Deferred<RawWebsocketMessage>();\r\n\r\n        try {\r\n            if (message.messageType === MessageType.Text) {\r\n                const payload = `${message.textBody ? message.textBody : \"\"}`;\r\n                deferral.resolve(new RawWebsocketMessage(MessageType.Text, payload, message.id));\r\n            }\r\n        } catch (e) {\r\n            deferral.reject(`Error formatting the message. ${e}`);\r\n        }\r\n\r\n        return deferral.promise;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}