{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { ConnectingToServiceEvent, ListeningStartedEvent, RecognitionStartedEvent, RecognitionTriggeredEvent } from \"./RecognitionEvents\";\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\nexport class RequestSession {\n  constructor(audioSourceId) {\n    this.privIsDisposed = false;\n    this.privDetachables = new Array();\n    this.privIsAudioNodeDetached = false;\n    this.privIsRecognizing = false;\n    this.privIsSpeechEnded = false;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privHypothesisReceived = false;\n    this.privBytesSent = 0;\n    this.privRecogNumber = 0;\n    this.privInTurn = false;\n    this.privConnectionAttempts = 0;\n\n    this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n      this.privAuthFetchEventId = authFetchEventId;\n      this.privSessionId = connectionId;\n      this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\n    };\n\n    this.onSpeechContext = () => {\n      this.privRequestId = createNoDashGuid();\n    };\n\n    this.onServiceTurnStartResponse = () => {\n      if (!!this.privTurnDeferral && !!this.privInTurn) {\n        // What? How are we starting a turn with another not done?\n        this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n\n        /* tslint:disable:no-empty */\n\n        this.privTurnDeferral.promise.then().catch(() => {});\n      }\n\n      this.privInTurn = true;\n      this.privTurnDeferral = new Deferred();\n    };\n\n    this.getTelemetry = () => {\n      if (this.privServiceTelemetryListener.hasTelemetry) {\n        return this.privServiceTelemetryListener.getTelemetry();\n      } else {\n        return null;\n      }\n    };\n\n    this.onEvent = event => {\n      if (!!this.privServiceTelemetryListener) {\n        this.privServiceTelemetryListener.onEvent(event);\n      }\n\n      Events.instance.onEvent(event);\n    };\n\n    this.privAudioSourceId = audioSourceId;\n    this.privRequestId = createNoDashGuid();\n    this.privAudioNodeId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  get sessionId() {\n    return this.privSessionId;\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get audioNodeId() {\n    return this.privAudioNodeId;\n  }\n\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n\n  get isSpeechEnded() {\n    return this.privIsSpeechEnded;\n  }\n\n  get isRecognizing() {\n    return this.privIsRecognizing;\n  }\n\n  get currentTurnAudioOffset() {\n    return this.privTurnStartAudioOffset;\n  }\n\n  get recogNumber() {\n    return this.privRecogNumber;\n  }\n\n  get numConnectionAttempts() {\n    return this.privConnectionAttempts;\n  } // The number of bytes sent for the current connection.\n  // Counter is reset to 0 each time a connection is established.\n\n\n  get bytesSent() {\n    return this.privBytesSent;\n  }\n\n  listenForServiceTelemetry(eventSource) {\n    if (!!this.privServiceTelemetryListener) {\n      this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\n    }\n  }\n\n  startNewRecognition() {\n    this.privIsSpeechEnded = false;\n    this.privIsRecognizing = true;\n    this.privTurnStartAudioOffset = 0;\n    this.privLastRecoOffset = 0;\n    this.privRecogNumber++;\n    this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\n    this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n  }\n\n  onAudioSourceAttachCompleted(audioNode, isError, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privAudioNode = audioNode;\n      this.privIsAudioNodeDetached = false;\n\n      if (isError) {\n        yield this.onComplete();\n      } else {\n        this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\n      }\n    });\n  }\n\n  onAuthCompleted(isError, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isError) {\n        yield this.onComplete();\n      }\n    });\n  }\n\n  onConnectionEstablishCompleted(statusCode, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (statusCode === 200) {\n        this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\n\n        if (!!this.privAudioNode) {\n          this.privAudioNode.replay();\n        }\n\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privBytesSent = 0;\n        return;\n      } else if (statusCode === 403) {\n        yield this.onComplete();\n      }\n    });\n  }\n\n  onServiceTurnEndResponse(continuousRecognition) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privTurnDeferral.resolve();\n\n      if (!continuousRecognition || this.isSpeechEnded) {\n        yield this.onComplete();\n        this.privInTurn = false;\n      } else {\n        // Start a new request set.\n        this.privTurnStartAudioOffset = this.privLastRecoOffset;\n        this.privAudioNode.replay();\n      }\n    });\n  }\n\n  onHypothesis(offset) {\n    if (!this.privHypothesisReceived) {\n      this.privHypothesisReceived = true;\n      this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\n    }\n  }\n\n  onPhraseRecognized(offset) {\n    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\n    this.onServiceRecognized(offset);\n  }\n\n  onServiceRecognized(offset) {\n    this.privLastRecoOffset = offset;\n    this.privHypothesisReceived = false;\n    this.privAudioNode.shrinkBuffers(offset);\n    this.privConnectionAttempts = 0;\n  }\n\n  onAudioSent(bytesSent) {\n    this.privBytesSent += bytesSent;\n  }\n\n  onRetryConnection() {\n    this.privConnectionAttempts++;\n  }\n\n  dispose(error) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n\n        for (const detachable of this.privDetachables) {\n          yield detachable.detach();\n        }\n\n        (_a = this.privServiceTelemetryListener) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.privIsRecognizing = false;\n      }\n    });\n  }\n\n  onStopRecognizing() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.onComplete();\n    });\n  } // Should be called with the audioNode for this session has indicated that it is out of speech.\n\n\n  onSpeechEnded() {\n    this.privIsSpeechEnded = true;\n  }\n\n  onComplete() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privIsRecognizing) {\n        this.privIsRecognizing = false;\n        yield this.detachAudioNode();\n      }\n    });\n  }\n\n  detachAudioNode() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.privIsAudioNodeDetached) {\n        this.privIsAudioNodeDetached = true;\n\n        if (this.privAudioNode) {\n          yield this.privAudioNode.detach();\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["createNoDashGuid","Deferred","Events","ConnectingToServiceEvent","ListeningStartedEvent","RecognitionStartedEvent","RecognitionTriggeredEvent","ServiceTelemetryListener","RequestSession","constructor","audioSourceId","Array","authFetchEventId","connectionId","privAuthFetchEventId","privSessionId","onEvent","privRequestId","privTurnDeferral","privInTurn","reject","promise","then","catch","privServiceTelemetryListener","hasTelemetry","getTelemetry","event","instance","privAudioSourceId","privAudioNodeId","resolve","sessionId","requestId","audioNodeId","turnCompletionPromise","isSpeechEnded","privIsSpeechEnded","isRecognizing","privIsRecognizing","currentTurnAudioOffset","privTurnStartAudioOffset","recogNumber","privRecogNumber","numConnectionAttempts","privConnectionAttempts","bytesSent","privBytesSent","listenForServiceTelemetry","eventSource","privDetachables","push","attachListener","startNewRecognition","privLastRecoOffset","onAudioSourceAttachCompleted","audioNode","isError","error","privAudioNode","privIsAudioNodeDetached","onComplete","onAuthCompleted","onConnectionEstablishCompleted","statusCode","reason","replay","onServiceTurnEndResponse","continuousRecognition","onHypothesis","offset","privHypothesisReceived","hypothesisReceived","findTimeAtOffset","onPhraseRecognized","phraseReceived","onServiceRecognized","shrinkBuffers","onAudioSent","onRetryConnection","dispose","privIsDisposed","detachable","detach","_a","onStopRecognizing","onSpeechEnded","detachAudioNode"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\RequestSession.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { Z_NO_COMPRESSION } from \"zlib\";\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events,\r\n    IDetachable,\r\n    IEventSource,\r\n    PlatformEvent\r\n} from \"../common/Exports\";\r\nimport {\r\n    ConnectingToServiceEvent,\r\n    ListeningStartedEvent,\r\n    RecognitionStartedEvent,\r\n    RecognitionTriggeredEvent,\r\n    SpeechRecognitionEvent,\r\n} from \"./RecognitionEvents\";\r\nimport { ServiceTelemetryListener } from \"./ServiceTelemetryListener.Internal\";\r\n\r\nexport class RequestSession {\r\n    private privIsDisposed: boolean = false;\r\n    private privServiceTelemetryListener: ServiceTelemetryListener;\r\n    private privDetachables: IDetachable[] = new Array<IDetachable>();\r\n    private privRequestId: string;\r\n    private privAudioSourceId: string;\r\n    private privAudioNodeId: string;\r\n    private privAudioNode: ReplayableAudioNode;\r\n    private privAuthFetchEventId: string;\r\n    private privIsAudioNodeDetached: boolean = false;\r\n    private privIsRecognizing: boolean = false;\r\n    private privIsSpeechEnded: boolean = false;\r\n    private privTurnStartAudioOffset: number = 0;\r\n    private privLastRecoOffset: number = 0;\r\n    private privHypothesisReceived: boolean = false;\r\n    private privBytesSent: number = 0;\r\n    private privRecogNumber: number = 0;\r\n    private privSessionId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privConnectionAttempts: number = 0;\r\n\r\n    constructor(audioSourceId: string) {\r\n        this.privAudioSourceId = audioSourceId;\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privAudioNodeId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public get sessionId(): string {\r\n        return this.privSessionId;\r\n    }\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get audioNodeId(): string {\r\n        return this.privAudioNodeId;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSpeechEnded(): boolean {\r\n        return this.privIsSpeechEnded;\r\n    }\r\n\r\n    public get isRecognizing(): boolean {\r\n        return this.privIsRecognizing;\r\n    }\r\n\r\n    public get currentTurnAudioOffset(): number {\r\n        return this.privTurnStartAudioOffset;\r\n    }\r\n\r\n    public get recogNumber(): number {\r\n        return this.privRecogNumber;\r\n    }\r\n\r\n    public get numConnectionAttempts(): number {\r\n        return this.privConnectionAttempts;\r\n    }\r\n\r\n    // The number of bytes sent for the current connection.\r\n    // Counter is reset to 0 each time a connection is established.\r\n    public get bytesSent(): number {\r\n        return this.privBytesSent;\r\n    }\r\n    public listenForServiceTelemetry(eventSource: IEventSource<PlatformEvent>): void {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privDetachables.push(eventSource.attachListener(this.privServiceTelemetryListener));\r\n        }\r\n    }\r\n\r\n    public startNewRecognition(): void {\r\n        this.privIsSpeechEnded = false;\r\n        this.privIsRecognizing = true;\r\n        this.privTurnStartAudioOffset = 0;\r\n        this.privLastRecoOffset = 0;\r\n        this.privRecogNumber++;\r\n        this.privServiceTelemetryListener = new ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId);\r\n        this.onEvent(new RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n    }\r\n\r\n    public async onAudioSourceAttachCompleted(audioNode: ReplayableAudioNode, isError: boolean, error?: string): Promise<void> {\r\n        this.privAudioNode = audioNode;\r\n        this.privIsAudioNodeDetached = false;\r\n\r\n        if (isError) {\r\n            await this.onComplete();\r\n        } else {\r\n            this.onEvent(new ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));\r\n        }\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.privSessionId = connectionId;\r\n        this.onEvent(new ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));\r\n    }\r\n\r\n    public async onAuthCompleted(isError: boolean, error?: string): Promise<void> {\r\n        if (isError) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onConnectionEstablishCompleted(statusCode: number, reason?: string): Promise<void> {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId));\r\n            if (!!this.privAudioNode) {\r\n                this.privAudioNode.replay();\r\n            }\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privBytesSent = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            await this.onComplete();\r\n        }\r\n    }\r\n\r\n    public async onServiceTurnEndResponse(continuousRecognition: boolean): Promise<void> {\r\n        this.privTurnDeferral.resolve();\r\n\r\n        if (!continuousRecognition || this.isSpeechEnded) {\r\n            await this.onComplete();\r\n            this.privInTurn = false;\r\n        } else {\r\n            // Start a new request set.\r\n            this.privTurnStartAudioOffset = this.privLastRecoOffset;\r\n            this.privAudioNode.replay();\r\n        }\r\n    }\r\n\r\n    public onSpeechContext = (): void => {\r\n        this.privRequestId = createNoDashGuid();\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            /* tslint:disable:no-empty */\r\n            this.privTurnDeferral.promise.then().catch(() => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onHypothesis(offset: number): void {\r\n        if (!this.privHypothesisReceived) {\r\n            this.privHypothesisReceived = true;\r\n            this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        }\r\n    }\r\n\r\n    public onPhraseRecognized(offset: number): void {\r\n        this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(offset));\r\n        this.onServiceRecognized(offset);\r\n    }\r\n\r\n    public onServiceRecognized(offset: number): void {\r\n        this.privLastRecoOffset = offset;\r\n        this.privHypothesisReceived = false;\r\n        this.privAudioNode.shrinkBuffers(offset);\r\n        this.privConnectionAttempts = 0;\r\n    }\r\n\r\n    public onAudioSent(bytesSent: number): void {\r\n        this.privBytesSent += bytesSent;\r\n    }\r\n\r\n    public onRetryConnection(): void {\r\n        this.privConnectionAttempts++;\r\n    }\r\n\r\n    public async dispose(error?: string): Promise<void> {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n            for (const detachable of this.privDetachables) {\r\n                await detachable.detach();\r\n            }\r\n\r\n            this.privServiceTelemetryListener?.dispose();\r\n            this.privIsRecognizing = false;\r\n        }\r\n    }\r\n\r\n    public getTelemetry = (): string => {\r\n        if (this.privServiceTelemetryListener.hasTelemetry) {\r\n            return this.privServiceTelemetryListener.getTelemetry();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    public async onStopRecognizing(): Promise<void> {\r\n        await this.onComplete();\r\n    }\r\n\r\n    // Should be called with the audioNode for this session has indicated that it is out of speech.\r\n    public onSpeechEnded(): void {\r\n        this.privIsSpeechEnded = true;\r\n    }\r\n\r\n    protected onEvent = (event: SpeechRecognitionEvent): void => {\r\n        if (!!this.privServiceTelemetryListener) {\r\n            this.privServiceTelemetryListener.onEvent(event);\r\n        }\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private async onComplete(): Promise<void> {\r\n        if (!!this.privIsRecognizing) {\r\n            this.privIsRecognizing = false;\r\n            await this.detachAudioNode();\r\n        }\r\n    }\r\n\r\n    private async detachAudioNode(): Promise<void> {\r\n        if (!this.privIsAudioNodeDetached) {\r\n            this.privIsAudioNodeDetached = true;\r\n            if (this.privAudioNode) {\r\n                await this.privAudioNode.detach();\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}