{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\nimport { BackgroundEvent, createGuid, createNoDashGuid, Deferred, Events, EventSource, MessageType, ServiceEvent } from \"../common/Exports\";\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\nimport { ActivityReceivedEventArgs, CancellationErrorCode, CancellationReason, DialogServiceConfig, PropertyCollection, PropertyId, RecognitionEventArgs, ResultReason, SessionEventArgs, SpeechRecognitionCanceledEventArgs, SpeechRecognitionEventArgs, SpeechRecognitionResult, TurnStatusReceivedEventArgs } from \"../sdk/Exports\";\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\nimport { CancellationErrorCodePropertyName, EnumTranslation, RecognitionStatus, ServiceRecognizerBase, SimpleSpeechPhrase, SpeechDetected, SpeechHypothesis, SpeechKeyword } from \"./Exports\";\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector) {\n    super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\n\n    this.sendAgentConfig = connection => {\n      if (this.agentConfig && !this.agentConfigSent) {\n        if (this.privRecognizerConfig.parameters.getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\n          const config = this.agentConfig.get();\n          config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\n          this.agentConfig.set(config);\n        }\n\n        this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\n        const agentConfigJson = this.agentConfig.toJsonString(); // guard against sending this multiple times on one connection\n\n        this.agentConfigSent = true;\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent.config\", this.privRequestSession.requestId, \"application/json\", agentConfigJson));\n      }\n\n      return;\n    };\n\n    this.sendAgentContext = connection => {\n      const guid = createGuid();\n      const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\n      const agentContext = {\n        channelData: \"\",\n        context: {\n          interactionId: guid\n        },\n        messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\n        version: 0.5\n      };\n      const agentContextJson = JSON.stringify(agentContext);\n      return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.agent.context\", this.privRequestSession.requestId, \"application/json\", agentContextJson));\n    };\n\n    this.handleResponseMessage = responseMessage => {\n      // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\n      // event according to the message type that's specified.\n      const responsePayload = JSON.parse(responseMessage.textBody);\n\n      switch (responsePayload.messageType.toLowerCase()) {\n        case \"message\":\n          const responseRequestId = responseMessage.requestId.toUpperCase();\n          const activityPayload = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\n          const turn = this.privTurnStateManager.GetTurn(responseRequestId); // update the conversation Id\n\n          if (activityPayload.conversationId) {\n            const updateAgentConfig = this.agentConfig.get();\n            updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\n            this.agentConfig.set(updateAgentConfig);\n          }\n\n          const pullAudioOutputStream = turn.processActivityPayload(activityPayload, AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\n          const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\n\n          if (!!this.privDialogServiceConnector.activityReceived) {\n            try {\n              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          break;\n\n        case \"messagestatus\":\n          if (!!this.privDialogServiceConnector.turnStatusReceived) {\n            try {\n              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new TurnStatusReceivedEventArgs(responseMessage.textBody));\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          break;\n\n        default:\n          Events.instance.onEvent(new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\n          break;\n      }\n    };\n\n    this.privEvents = new EventSource();\n    this.privDialogServiceConnector = dialogServiceConnector;\n    this.receiveMessageOverride = this.receiveDialogMessageOverride;\n    this.privTurnStateManager = new DialogServiceTurnStateManager();\n    this.recognizeOverride = this.listenOnce;\n    this.postConnectImplOverride = this.dialogConnectImpl;\n    this.configConnectionOverride = this.configConnection;\n    this.disconnectOverride = this.privDisconnect;\n    this.privDialogAudioSource = audioSource;\n    this.agentConfigSent = false;\n    this.privLastResult = null;\n    this.connectionEvents.attach(connectionEvent => __awaiter(this, void 0, void 0, function* () {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        this.terminateMessageLoop = true;\n      }\n    }));\n  }\n\n  sendMessage(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const interactionGuid = createGuid();\n      const requestId = createNoDashGuid();\n      const agentMessage = {\n        context: {\n          interactionId: interactionGuid\n        },\n        messagePayload: JSON.parse(message),\n        version: 0.5\n      };\n      const agentMessageJson = JSON.stringify(agentMessage);\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"agent\", requestId, \"application/json\", agentMessageJson));\n    });\n  }\n\n  privDisconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n      this.terminateMessageLoop = true;\n      this.agentConfigSent = false;\n      return;\n    });\n  }\n\n  processTypeSpecificMessages(connectionMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const resultProps = new PropertyCollection();\n\n      if (connectionMessage.messageType === MessageType.Text) {\n        resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\n      }\n\n      let result;\n      let processed;\n\n      switch (connectionMessage.path.toLowerCase()) {\n        case \"speech.phrase\":\n          const speechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\n          this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\n\n          if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\n            const args = this.fireEventForResult(speechPhrase, resultProps);\n            this.privLastResult = args.result;\n\n            if (!!this.privDialogServiceConnector.recognized) {\n              try {\n                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\n                /* tslint:disable:no-empty */\n              } catch (error) {// Not going to let errors in the event handler\n                // trip things up.\n              }\n            }\n          }\n\n          processed = true;\n          break;\n\n        case \"speech.hypothesis\":\n          const hypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\n          const offset = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\n          result = new SpeechRecognitionResult(this.privRequestSession.requestId, ResultReason.RecognizingSpeech, hypothesis.Text, hypothesis.Duration, offset, hypothesis.Language, hypothesis.LanguageDetectionConfidence, undefined, undefined, connectionMessage.textBody, resultProps);\n          this.privRequestSession.onHypothesis(offset);\n          const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\n\n          if (!!this.privDialogServiceConnector.recognizing) {\n            try {\n              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          processed = true;\n          break;\n\n        case \"speech.keyword\":\n          const keyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\n          result = new SpeechRecognitionResult(this.privRequestSession.requestId, keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch, keyword.Text, keyword.Duration, keyword.Offset, undefined, undefined, undefined, undefined, connectionMessage.textBody, resultProps);\n\n          if (keyword.Status !== \"Accepted\") {\n            this.privLastResult = result;\n          }\n\n          const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\n\n          if (!!this.privDialogServiceConnector.recognized) {\n            try {\n              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\n              /* tslint:disable:no-empty */\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n\n          processed = true;\n          break;\n\n        case \"audio\":\n          {\n            const audioRequestId = connectionMessage.requestId.toUpperCase();\n            const turn = this.privTurnStateManager.GetTurn(audioRequestId);\n\n            try {\n              // Empty binary message signals end of stream.\n              if (!connectionMessage.binaryBody) {\n                turn.endAudioStream();\n              } else {\n                turn.audioStream.write(connectionMessage.binaryBody);\n              }\n            } catch (error) {// Not going to let errors in the event handler\n              // trip things up.\n            }\n          }\n          processed = true;\n          break;\n\n        case \"response\":\n          {\n            this.handleResponseMessage(connectionMessage);\n          }\n          processed = true;\n          break;\n\n        default:\n          break;\n      }\n\n      return processed;\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognition(sessionId, requestId, cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = true;\n\n      if (!!this.privRequestSession.isRecognizing) {\n        yield this.privRequestSession.onStopRecognizing();\n      }\n\n      if (!!this.privDialogServiceConnector.canceled) {\n        const properties = new PropertyCollection();\n        properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\n        const cancelEvent = new SpeechRecognitionCanceledEventArgs(cancellationReason, error, errorCode, undefined, sessionId);\n\n        try {\n          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\n          /* tslint:disable:no-empty */\n        } catch (_a) {}\n\n        if (!!this.privSuccessCallback) {\n          const result = new SpeechRecognitionResult(undefined, // ResultId\n          ResultReason.Canceled, undefined, // Text\n          undefined, // Duration\n          undefined, // Offset\n          undefined, // Language\n          undefined, // Language Detection Confidence\n          undefined, // Speaker Id\n          error, undefined, // Json\n          properties);\n\n          try {\n            this.privSuccessCallback(result);\n            this.privSuccessCallback = undefined;\n            /* tslint:disable:no-empty */\n          } catch (_b) {}\n        }\n      }\n    });\n  }\n\n  listenOnce(recoMode, successCallback, errorCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privRecognizerConfig.recognitionMode = recoMode;\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallback;\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\n      this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId); // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n\n      const conPromise = this.connectImpl();\n      const preAudioPromise = this.sendPreAudioMessages();\n      const node = yield this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\n      const format = yield this.privDialogAudioSource.format;\n      const deviceInfo = yield this.privDialogAudioSource.deviceInfo;\n      const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\n      yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n      this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n        source: deviceInfo\n      };\n\n      try {\n        yield conPromise;\n        yield preAudioPromise;\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n        return Promise.resolve();\n      }\n\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n\n      const audioSendPromise = this.sendAudio(audioNode); // /* tslint:disable:no-empty */\n\n      audioSendPromise.then(() => {}, error => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }));\n    });\n  } // Establishes a websocket connection to the end point.\n\n\n  dialogConnectImpl(connection) {\n    this.privConnectionLoop = this.startMessageLoop();\n    return connection;\n  }\n\n  receiveDialogMessageOverride() {\n    // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\n    const communicationCustodian = new Deferred();\n\n    const loop = () => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const isDisposed = this.isDisposed();\n        const terminateMessageLoop = !this.isDisposed() && this.terminateMessageLoop;\n\n        if (isDisposed || terminateMessageLoop) {\n          // We're done.\n          communicationCustodian.resolve(undefined);\n          return;\n        }\n\n        const connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (!message) {\n          return loop();\n        }\n\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n        switch (connectionMessage.path.toLowerCase()) {\n          case \"turn.start\":\n            {\n              const turnRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase(); // turn started by the service\n\n              if (turnRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.StartTurn(turnRequestId);\n              } else {\n                this.privRequestSession.onServiceTurnStartResponse();\n              }\n            }\n            break;\n\n          case \"speech.startdetected\":\n            const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n            const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n\n            if (!!this.privRecognizer.speechStartDetected) {\n              this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n            }\n\n            break;\n\n          case \"speech.enddetected\":\n            let json;\n\n            if (connectionMessage.textBody.length > 0) {\n              json = connectionMessage.textBody;\n            } else {\n              // If the request was empty, the JSON returned is empty.\n              json = \"{ Offset: 0 }\";\n            }\n\n            const speechStopDetected = SpeechDetected.fromJSON(json);\n            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n            const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n            if (!!this.privRecognizer.speechEndDetected) {\n              this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n            }\n\n            break;\n\n          case \"turn.end\":\n            {\n              const turnEndRequestId = connectionMessage.requestId.toUpperCase();\n              const audioSessionReqId = this.privRequestSession.requestId.toUpperCase(); // turn started by the service\n\n              if (turnEndRequestId !== audioSessionReqId) {\n                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\n              } else {\n                // Audio session turn\n                const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n                yield this.privRequestSession.onServiceTurnEndResponse(false);\n\n                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                  if (!!this.privRecognizer.sessionStopped) {\n                    this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                  }\n                } // report result to promise.\n\n\n                if (!!this.privSuccessCallback && this.privLastResult) {\n                  try {\n                    this.privSuccessCallback(this.privLastResult);\n                    this.privLastResult = null;\n                  } catch (e) {\n                    if (!!this.privErrorCallback) {\n                      this.privErrorCallback(e);\n                    }\n                  } // Only invoke the call back once.\n                  // and if it's successful don't invoke the\n                  // error after that.\n\n\n                  this.privSuccessCallback = undefined;\n                  this.privErrorCallback = undefined;\n                }\n              }\n            }\n            break;\n\n          default:\n            if (!this.processTypeSpecificMessages(connectionMessage)) {\n              if (!!this.serviceEvents) {\n                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n              }\n            }\n\n        }\n\n        const ret = loop();\n        return ret;\n      } catch (error) {\n        this.terminateMessageLoop = true;\n        communicationCustodian.resolve();\n      }\n    });\n\n    loop().catch(reason => {\n      Events.instance.onEvent(new BackgroundEvent(reason));\n    });\n    return communicationCustodian.promise;\n  }\n\n  startMessageLoop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.terminateMessageLoop = false;\n\n      try {\n        yield this.receiveDialogMessageOverride();\n      } catch (error) {\n        yield this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }\n\n      return Promise.resolve();\n    });\n  } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  configConnection(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.terminateMessageLoop) {\n        this.terminateMessageLoop = false;\n        return Promise.reject(`Connection to service terminated.`);\n      }\n\n      yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n      yield this.sendAgentConfig(connection);\n      return connection;\n    });\n  }\n\n  sendPreAudioMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      this.addKeywordContextData();\n      yield this.sendSpeechContext(connection);\n      yield this.sendAgentContext(connection);\n      yield this.sendWaveHeader(connection);\n    });\n  }\n\n  fireEventForResult(serviceResult, properties) {\n    const resultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\n    const offset = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\n    const result = new SpeechRecognitionResult(this.privRequestSession.requestId, resultReason, serviceResult.DisplayText, serviceResult.Duration, offset, serviceResult.Language, serviceResult.LanguageDetectionConfidence, undefined, undefined, JSON.stringify(serviceResult), properties);\n    const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\n    return ev;\n  }\n\n  onEvent(event) {\n    this.privEvents.onEvent(event);\n    Events.instance.onEvent(event);\n  }\n\n  addKeywordContextData() {\n    const keywordPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\n\n    if (keywordPropertyValue === undefined) {\n      return;\n    }\n\n    const keywordOffsetPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\n    const keywordDurationPropertyValue = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect-Durations\");\n    const keywords = keywordPropertyValue.split(\";\");\n    const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\n    const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\n    const keywordDefinitionArray = [];\n\n    for (let i = 0; i < keywords.length; i++) {\n      const definition = {};\n      definition.text = keywords[i];\n\n      if (i < keywordOffsets.length) {\n        definition.offset = Number(keywordOffsets[i]);\n      }\n\n      if (i < keywordDurations.length) {\n        definition.duration = Number(keywordDurations[i]);\n      }\n\n      keywordDefinitionArray.push(definition);\n    }\n\n    this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\n    this.speechContext.setSection(\"keywordDetection\", [{\n      clientDetectedKeywords: keywordDefinitionArray,\n      onReject: {\n        action: \"EndOfTurn\"\n      },\n      type: \"startTrigger\"\n    }]);\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ReplayableAudioNode","SendingAgentContextMessageEvent","BackgroundEvent","createGuid","createNoDashGuid","Deferred","Events","EventSource","MessageType","ServiceEvent","AudioOutputFormatImpl","ActivityReceivedEventArgs","CancellationErrorCode","CancellationReason","DialogServiceConfig","PropertyCollection","PropertyId","RecognitionEventArgs","ResultReason","SessionEventArgs","SpeechRecognitionCanceledEventArgs","SpeechRecognitionEventArgs","SpeechRecognitionResult","TurnStatusReceivedEventArgs","DialogServiceTurnStateManager","CancellationErrorCodePropertyName","EnumTranslation","RecognitionStatus","ServiceRecognizerBase","SimpleSpeechPhrase","SpeechDetected","SpeechHypothesis","SpeechKeyword","ActivityPayloadResponse","SpeechConnectionMessage","DialogServiceAdapter","constructor","authentication","connectionFactory","audioSource","recognizerConfig","dialogServiceConnector","connection","agentConfig","agentConfigSent","privRecognizerConfig","parameters","getProperty","Conversation_DialogType","DialogTypes","CustomCommands","config","get","botInfo","commandsCulture","SpeechServiceConnection_RecoLanguage","set","onEvent","agentConfigJson","toJsonString","send","Text","privRequestSession","requestId","guid","speechActivityTemplate","privDialogServiceConnector","properties","Conversation_Speech_Activity_Template","agentContext","channelData","context","interactionId","messagePayload","undefined","version","agentContextJson","JSON","stringify","responseMessage","responsePayload","parse","textBody","messageType","toLowerCase","responseRequestId","toUpperCase","activityPayload","fromJSON","turn","privTurnStateManager","GetTurn","conversationId","updateAgentConfig","pullAudioOutputStream","processActivityPayload","fromSpeechSynthesisOutputFormatString","SpeechServiceConnection_SynthOutputFormat","activity","activityReceived","error","turnStatusReceived","instance","privEvents","receiveMessageOverride","receiveDialogMessageOverride","recognizeOverride","listenOnce","postConnectImplOverride","dialogConnectImpl","configConnectionOverride","configConnection","disconnectOverride","privDisconnect","privDialogAudioSource","privLastResult","connectionEvents","attach","connectionEvent","__awaiter","name","terminateMessageLoop","sendMessage","message","interactionGuid","agentMessage","agentMessageJson","fetchConnection","cancelRecognition","sessionId","Error","NoError","processTypeSpecificMessages","connectionMessage","resultProps","setProperty","SpeechServiceResponse_JsonResult","result","processed","path","speechPhrase","onPhraseRecognized","currentTurnAudioOffset","Offset","Duration","TooManyRequests","args","fireEventForResult","recognized","hypothesis","offset","RecognizingSpeech","Language","LanguageDetectionConfidence","onHypothesis","ev","recognizing","keyword","Status","RecognizedKeyword","NoMatch","event","duration","resultId","audioRequestId","binaryBody","endAudioStream","audioStream","write","handleResponseMessage","cancellationReason","errorCode","isRecognizing","onStopRecognizing","canceled","cancelEvent","privSuccessCallback","Canceled","recoMode","successCallback","errorCallback","recognitionMode","privErrorCallback","startNewRecognition","listenForServiceTelemetry","events","Speech_SessionId","conPromise","connectImpl","preAudioPromise","sendPreAudioMessages","node","audioNodeId","format","deviceInfo","audioNode","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","ConnectionFailure","Promise","resolve","sessionStartEventArgs","privRecognizer","sessionStarted","audioSendPromise","sendAudio","then","RuntimeError","privConnectionLoop","startMessageLoop","communicationCustodian","loop","isDisposed","read","fromConnectionMessage","turnRequestId","audioSessionReqId","StartTurn","onServiceTurnStartResponse","speechStartDetected","speechStartEventArgs","json","length","speechStopDetected","onServiceRecognized","speechStopEventArgs","speechEndDetected","turnEndRequestId","CompleteTurn","sessionStopEventArgs","onServiceTurnEndResponse","isContinuousRecognition","isSpeechEnded","sessionStopped","e","serviceEvents","ret","catch","reason","promise","reject","sendSpeechServiceConfig","serialize","sendAgentConfig","addKeywordContextData","sendSpeechContext","sendAgentContext","sendWaveHeader","serviceResult","resultReason","implTranslateRecognitionResult","DisplayText","keywordPropertyValue","keywordOffsetPropertyValue","keywordDurationPropertyValue","keywords","split","keywordOffsets","keywordDurations","keywordDefinitionArray","i","definition","text","Number","push","speechContext","setSection","clientDetectedKeywords","onReject","action","type"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\DialogServiceAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    ReplayableAudioNode\r\n} from \"../common.browser/Exports\";\r\nimport { SendingAgentContextMessageEvent } from \"../common/DialogEvents\";\r\nimport {\r\n    BackgroundEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    createGuid,\r\n    createNoDashGuid,\r\n    Deferred,\r\n    DialogEvent,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    MessageType,\r\n    ServiceEvent,\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    ActivityReceivedEventArgs,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    DialogServiceConfig,\r\n    DialogServiceConnector,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    ResultReason,\r\n    SessionEventArgs,\r\n    SpeechRecognitionCanceledEventArgs,\r\n    SpeechRecognitionEventArgs,\r\n    SpeechRecognitionResult,\r\n    TurnStatusReceivedEventArgs,\r\n} from \"../sdk/Exports\";\r\nimport { DialogServiceTurnStateManager } from \"./DialogServiceTurnStateManager\";\r\nimport {\r\n    CancellationErrorCodePropertyName,\r\n    EnumTranslation,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionStatus,\r\n    ServiceRecognizerBase,\r\n    SimpleSpeechPhrase,\r\n    SpeechDetected,\r\n    SpeechHypothesis,\r\n    SpeechKeyword,\r\n} from \"./Exports\";\r\nimport { IAuthentication } from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognitionMode, RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { ActivityPayloadResponse } from \"./ServiceMessages/ActivityResponsePayload\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport class DialogServiceAdapter extends ServiceRecognizerBase {\r\n    private privDialogServiceConnector: DialogServiceConnector;\r\n\r\n    private privDialogAudioSource: IAudioSource;\r\n\r\n    private privConnectionLoop: Promise<void>;\r\n    private terminateMessageLoop: boolean;\r\n    private agentConfigSent: boolean;\r\n    private privLastResult: SpeechRecognitionResult;\r\n    private privEvents: EventSource<DialogEvent>;\r\n\r\n    // Turns are of two kinds:\r\n    // 1: SR turns, end when the SR result is returned and then turn end.\r\n    // 2: Service turns where an activity is sent by the service along with the audio.\r\n    private privTurnStateManager: DialogServiceTurnStateManager;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        dialogServiceConnector: DialogServiceConnector) {\r\n\r\n        super(authentication, connectionFactory, audioSource, recognizerConfig, dialogServiceConnector);\r\n\r\n        this.privEvents = new EventSource<DialogEvent>();\r\n        this.privDialogServiceConnector = dialogServiceConnector;\r\n        this.receiveMessageOverride = this.receiveDialogMessageOverride;\r\n        this.privTurnStateManager = new DialogServiceTurnStateManager();\r\n        this.recognizeOverride = this.listenOnce;\r\n        this.postConnectImplOverride = this.dialogConnectImpl;\r\n        this.configConnectionOverride = this.configConnection;\r\n        this.disconnectOverride = this.privDisconnect;\r\n        this.privDialogAudioSource = audioSource;\r\n\r\n        this.agentConfigSent = false;\r\n        this.privLastResult = null;\r\n        this.connectionEvents.attach(async (connectionEvent: ConnectionEvent): Promise<void> => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                this.terminateMessageLoop = true;\r\n            }\r\n        });\r\n    }\r\n\r\n    public async sendMessage(message: string): Promise<void> {\r\n        const interactionGuid: string = createGuid();\r\n        const requestId: string = createNoDashGuid();\r\n\r\n        const agentMessage: any = {\r\n            context: {\r\n                interactionId: interactionGuid\r\n            },\r\n            messagePayload: JSON.parse(message),\r\n            version: 0.5\r\n        };\r\n\r\n        const agentMessageJson = JSON.stringify(agentMessage);\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"agent\",\r\n            requestId,\r\n            \"application/json\",\r\n            agentMessageJson));\r\n\r\n    }\r\n\r\n    protected async privDisconnect(): Promise<void> {\r\n        await this.cancelRecognition(this.privRequestSession.sessionId,\r\n            this.privRequestSession.requestId,\r\n            CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        this.terminateMessageLoop = true;\r\n        this.agentConfigSent = false;\r\n        return;\r\n    }\r\n\r\n    protected async processTypeSpecificMessages(connectionMessage: SpeechConnectionMessage): Promise<boolean> {\r\n\r\n        const resultProps: PropertyCollection = new PropertyCollection();\r\n        if (connectionMessage.messageType === MessageType.Text) {\r\n            resultProps.setProperty(PropertyId.SpeechServiceResponse_JsonResult, connectionMessage.textBody);\r\n        }\r\n\r\n        let result: SpeechRecognitionResult;\r\n        let processed: boolean;\r\n\r\n        switch (connectionMessage.path.toLowerCase()) {\r\n            case \"speech.phrase\":\r\n                const speechPhrase: SimpleSpeechPhrase = SimpleSpeechPhrase.fromJSON(connectionMessage.textBody);\r\n\r\n                this.privRequestSession.onPhraseRecognized(this.privRequestSession.currentTurnAudioOffset + speechPhrase.Offset + speechPhrase.Duration);\r\n\r\n                if (speechPhrase.RecognitionStatus !== RecognitionStatus.TooManyRequests && speechPhrase.RecognitionStatus !== RecognitionStatus.Error) {\r\n                    const args: SpeechRecognitionEventArgs = this.fireEventForResult(speechPhrase, resultProps);\r\n                    this.privLastResult = args.result;\r\n\r\n                    if (!!this.privDialogServiceConnector.recognized) {\r\n                        try {\r\n                            this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, args);\r\n                            /* tslint:disable:no-empty */\r\n                        } catch (error) {\r\n                            // Not going to let errors in the event handler\r\n                            // trip things up.\r\n                        }\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.hypothesis\":\r\n                const hypothesis: SpeechHypothesis = SpeechHypothesis.fromJSON(connectionMessage.textBody);\r\n                const offset: number = hypothesis.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    ResultReason.RecognizingSpeech,\r\n                    hypothesis.Text,\r\n                    hypothesis.Duration,\r\n                    offset,\r\n                    hypothesis.Language,\r\n                    hypothesis.LanguageDetectionConfidence,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                this.privRequestSession.onHypothesis(offset);\r\n\r\n                const ev = new SpeechRecognitionEventArgs(result, hypothesis.Duration, this.privRequestSession.sessionId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognizing) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, ev);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"speech.keyword\":\r\n                const keyword: SpeechKeyword = SpeechKeyword.fromJSON(connectionMessage.textBody);\r\n\r\n                result = new SpeechRecognitionResult(\r\n                    this.privRequestSession.requestId,\r\n                    keyword.Status === \"Accepted\" ? ResultReason.RecognizedKeyword : ResultReason.NoMatch,\r\n                    keyword.Text,\r\n                    keyword.Duration,\r\n                    keyword.Offset,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    undefined,\r\n                    connectionMessage.textBody,\r\n                    resultProps);\r\n\r\n                if (keyword.Status !== \"Accepted\") {\r\n                    this.privLastResult = result;\r\n                }\r\n\r\n                const event = new SpeechRecognitionEventArgs(result, result.duration, result.resultId);\r\n\r\n                if (!!this.privDialogServiceConnector.recognized) {\r\n                    try {\r\n                        this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, event);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n            case \"audio\":\r\n                {\r\n                    const audioRequestId = connectionMessage.requestId.toUpperCase();\r\n                    const turn = this.privTurnStateManager.GetTurn(audioRequestId);\r\n                    try {\r\n                        // Empty binary message signals end of stream.\r\n                        if (!connectionMessage.binaryBody) {\r\n                            turn.endAudioStream();\r\n                        } else {\r\n                            turn.audioStream.write(connectionMessage.binaryBody);\r\n                        }\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            case \"response\":\r\n                {\r\n                    this.handleResponseMessage(connectionMessage);\r\n\r\n                }\r\n                processed = true;\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        return processed;\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        this.terminateMessageLoop = true;\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n        }\r\n\r\n        if (!!this.privDialogServiceConnector.canceled) {\r\n            const properties: PropertyCollection = new PropertyCollection();\r\n            properties.setProperty(CancellationErrorCodePropertyName, CancellationErrorCode[errorCode]);\r\n\r\n            const cancelEvent: SpeechRecognitionCanceledEventArgs = new SpeechRecognitionCanceledEventArgs(\r\n                cancellationReason,\r\n                error,\r\n                errorCode,\r\n                undefined,\r\n                sessionId);\r\n\r\n            try {\r\n                this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, cancelEvent);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n\r\n            if (!!this.privSuccessCallback) {\r\n                const result: SpeechRecognitionResult = new SpeechRecognitionResult(\r\n                    undefined, // ResultId\r\n                    ResultReason.Canceled,\r\n                    undefined, // Text\r\n                    undefined, // Duration\r\n                    undefined, // Offset\r\n                    undefined, // Language\r\n                    undefined, // Language Detection Confidence\r\n                    undefined, // Speaker Id\r\n                    error,\r\n                    undefined, // Json\r\n                    properties);\r\n                try {\r\n                    this.privSuccessCallback(result);\r\n                    this.privSuccessCallback = undefined;\r\n                    /* tslint:disable:no-empty */\r\n                } catch { }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async listenOnce(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallback: (e: string) => void\r\n    ): Promise<void> {\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallback;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events);\r\n\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.Speech_SessionId, this.privRequestSession.sessionId);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n\r\n        const preAudioPromise: Promise<void> = this.sendPreAudioMessages();\r\n\r\n        const node: IAudioStreamNode = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId);\r\n        const format: AudioStreamFormatImpl = await this.privDialogAudioSource.format;\r\n        const deviceInfo: ISpeechConfigAudioDevice = await this.privDialogAudioSource.deviceInfo;\r\n\r\n        const audioNode = new ReplayableAudioNode(node, format.avgBytesPerSec);\r\n        await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n\r\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        try {\r\n            await conPromise;\r\n            await preAudioPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        // /* tslint:disable:no-empty */\r\n        audioSendPromise.then(() => { /*add? return true;*/ }, async (error: string) => {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n    }\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    private dialogConnectImpl(connection: Promise<IConnection>): Promise<IConnection> {\r\n        this.privConnectionLoop = this.startMessageLoop();\r\n        return connection;\r\n    }\r\n\r\n    private receiveDialogMessageOverride(): Promise<void> {\r\n\r\n        // we won't rely on the cascading promises of the connection since we want to continually be available to receive messages\r\n        const communicationCustodian: Deferred<void> = new Deferred<void>();\r\n\r\n        const loop = async (): Promise<void> => {\r\n            try {\r\n                const isDisposed: boolean = this.isDisposed();\r\n                const terminateMessageLoop = (!this.isDisposed() && this.terminateMessageLoop);\r\n                if (isDisposed || terminateMessageLoop) {\r\n                    // We're done.\r\n                    communicationCustodian.resolve(undefined);\r\n                    return;\r\n                }\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const message: ConnectionMessage = await connection.read();\r\n\r\n                if (!message) {\r\n                    return loop();\r\n                }\r\n\r\n                const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        {\r\n                            const turnRequestId = connectionMessage.requestId.toUpperCase();\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.StartTurn(turnRequestId);\r\n                            } else {\r\n                                this.privRequestSession.onServiceTurnStartResponse();\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n\r\n                        let json: string;\r\n\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n\r\n                        this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        {\r\n                            const turnEndRequestId = connectionMessage.requestId.toUpperCase();\r\n\r\n                            const audioSessionReqId = this.privRequestSession.requestId.toUpperCase();\r\n\r\n                            // turn started by the service\r\n                            if (turnEndRequestId !== audioSessionReqId) {\r\n                                this.privTurnStateManager.CompleteTurn(turnEndRequestId);\r\n                            } else {\r\n                                // Audio session turn\r\n\r\n                                const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                                await this.privRequestSession.onServiceTurnEndResponse(false);\r\n\r\n                                if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                                    if (!!this.privRecognizer.sessionStopped) {\r\n                                        this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                                    }\r\n                                }\r\n\r\n                                // report result to promise.\r\n                                if (!!this.privSuccessCallback && this.privLastResult) {\r\n                                    try {\r\n                                        this.privSuccessCallback(this.privLastResult);\r\n                                        this.privLastResult = null;\r\n                                    } catch (e) {\r\n                                        if (!!this.privErrorCallback) {\r\n                                            this.privErrorCallback(e);\r\n                                        }\r\n                                    }\r\n                                    // Only invoke the call back once.\r\n                                    // and if it's successful don't invoke the\r\n                                    // error after that.\r\n                                    this.privSuccessCallback = undefined;\r\n                                    this.privErrorCallback = undefined;\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        if (!this.processTypeSpecificMessages(connectionMessage)) {\r\n                            if (!!this.serviceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n                }\r\n                const ret: Promise<void> = loop();\r\n\r\n                return ret;\r\n            } catch (error) {\r\n                this.terminateMessageLoop = true;\r\n                communicationCustodian.resolve();\r\n            }\r\n        };\r\n\r\n        loop().catch((reason: string): void => {\r\n            Events.instance.onEvent(new BackgroundEvent(reason));\r\n        });\r\n\r\n        return communicationCustodian.promise;\r\n    }\r\n\r\n    private async startMessageLoop(): Promise<void> {\r\n\r\n        this.terminateMessageLoop = false;\r\n\r\n        try {\r\n            await this.receiveDialogMessageOverride();\r\n        } catch (error) {\r\n            await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        }\r\n\r\n        return Promise.resolve();\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configConnection(connection: IConnection): Promise<IConnection> {\r\n        if (this.terminateMessageLoop) {\r\n            this.terminateMessageLoop = false;\r\n            return Promise.reject(`Connection to service terminated.`);\r\n        }\r\n\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendAgentConfig(connection);\r\n        return connection;\r\n    }\r\n\r\n    private async sendPreAudioMessages(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        this.addKeywordContextData();\r\n        await this.sendSpeechContext(connection);\r\n        await this.sendAgentContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n    }\r\n\r\n    private sendAgentConfig = (connection: IConnection): Promise<void> => {\r\n        if (this.agentConfig && !this.agentConfigSent) {\r\n\r\n            if (this.privRecognizerConfig\r\n                .parameters\r\n                .getProperty(PropertyId.Conversation_DialogType) === DialogServiceConfig.DialogTypes.CustomCommands) {\r\n                const config = this.agentConfig.get();\r\n                config.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_RecoLanguage, \"en-us\");\r\n                this.agentConfig.set(config);\r\n            }\r\n            this.onEvent(new SendingAgentContextMessageEvent(this.agentConfig));\r\n\r\n            const agentConfigJson = this.agentConfig.toJsonString();\r\n\r\n            // guard against sending this multiple times on one connection\r\n            this.agentConfigSent = true;\r\n\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"agent.config\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                agentConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    private sendAgentContext = (connection: IConnection): Promise<void> => {\r\n        const guid: string = createGuid();\r\n\r\n        const speechActivityTemplate = this.privDialogServiceConnector.properties.getProperty(PropertyId.Conversation_Speech_Activity_Template);\r\n\r\n        const agentContext: any = {\r\n            channelData: \"\",\r\n            context: {\r\n                interactionId: guid\r\n            },\r\n            messagePayload: typeof speechActivityTemplate === undefined ? undefined : speechActivityTemplate,\r\n            version: 0.5\r\n        };\r\n\r\n        const agentContextJson = JSON.stringify(agentContext);\r\n\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"speech.agent.context\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            agentContextJson));\r\n    }\r\n\r\n    private fireEventForResult(serviceResult: SimpleSpeechPhrase, properties: PropertyCollection): SpeechRecognitionEventArgs {\r\n        const resultReason: ResultReason = EnumTranslation.implTranslateRecognitionResult(serviceResult.RecognitionStatus);\r\n\r\n        const offset: number = serviceResult.Offset + this.privRequestSession.currentTurnAudioOffset;\r\n\r\n        const result = new SpeechRecognitionResult(\r\n            this.privRequestSession.requestId,\r\n            resultReason,\r\n            serviceResult.DisplayText,\r\n            serviceResult.Duration,\r\n            offset,\r\n            serviceResult.Language,\r\n            serviceResult.LanguageDetectionConfidence,\r\n            undefined,\r\n            undefined,\r\n            JSON.stringify(serviceResult),\r\n            properties);\r\n\r\n        const ev = new SpeechRecognitionEventArgs(result, offset, this.privRequestSession.sessionId);\r\n        return ev;\r\n    }\r\n\r\n    private handleResponseMessage = (responseMessage: SpeechConnectionMessage): void => {\r\n        // \"response\" messages can contain either \"message\" (activity) or \"MessageStatus\" data. Fire the appropriate\r\n        // event according to the message type that's specified.\r\n        const responsePayload = JSON.parse(responseMessage.textBody);\r\n        switch (responsePayload.messageType.toLowerCase()) {\r\n            case \"message\":\r\n                const responseRequestId = responseMessage.requestId.toUpperCase();\r\n                const activityPayload: ActivityPayloadResponse = ActivityPayloadResponse.fromJSON(responseMessage.textBody);\r\n                const turn = this.privTurnStateManager.GetTurn(responseRequestId);\r\n\r\n                // update the conversation Id\r\n                if (activityPayload.conversationId) {\r\n                    const updateAgentConfig = this.agentConfig.get();\r\n                    updateAgentConfig.botInfo.conversationId = activityPayload.conversationId;\r\n                    this.agentConfig.set(updateAgentConfig);\r\n                }\r\n\r\n                const pullAudioOutputStream: PullAudioOutputStreamImpl = turn.processActivityPayload(\r\n                    activityPayload,\r\n                    AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(PropertyId.SpeechServiceConnection_SynthOutputFormat, undefined)));\r\n                const activity = new ActivityReceivedEventArgs(activityPayload.messagePayload, pullAudioOutputStream);\r\n                if (!!this.privDialogServiceConnector.activityReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, activity);\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            case \"messagestatus\":\r\n                if (!!this.privDialogServiceConnector.turnStatusReceived) {\r\n                    try {\r\n                        this.privDialogServiceConnector.turnStatusReceived(\r\n                            this.privDialogServiceConnector,\r\n                            new TurnStatusReceivedEventArgs(responseMessage.textBody));\r\n                        /* tslint:disable:no-empty */\r\n                    } catch (error) {\r\n                        // Not going to let errors in the event handler\r\n                        // trip things up.\r\n                    }\r\n                }\r\n                break;\r\n\r\n            default:\r\n                Events.instance.onEvent(\r\n                    new BackgroundEvent(`Unexpected response of type ${responsePayload.messageType}. Ignoring.`));\r\n                break;\r\n        }\r\n    }\r\n\r\n    private onEvent(event: DialogEvent): void {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private addKeywordContextData(): void {\r\n        const keywordPropertyValue: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-KeywordsToDetect\");\r\n        if (keywordPropertyValue === undefined) {\r\n            return;\r\n        }\r\n\r\n        const keywordOffsetPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Offsets\");\r\n        const keywordDurationPropertyValue: string = this.privRecognizerConfig.parameters\r\n            .getProperty(\"SPEECH-KeywordsToDetect-Durations\");\r\n\r\n        const keywords = keywordPropertyValue.split(\";\");\r\n        const keywordOffsets = keywordOffsetPropertyValue === undefined ? [] : keywordOffsetPropertyValue.split(\";\");\r\n        const keywordDurations = keywordDurationPropertyValue === undefined ? [] : keywordDurationPropertyValue.split(\";\");\r\n\r\n        const keywordDefinitionArray = [];\r\n        for (let i = 0; i < keywords.length; i++) {\r\n            const definition: { [section: string]: any } = {};\r\n            definition.text = keywords[i];\r\n            if (i < keywordOffsets.length) {\r\n                definition.offset = Number(keywordOffsets[i]);\r\n            }\r\n            if (i < keywordDurations.length) {\r\n                definition.duration = Number(keywordDurations[i]);\r\n            }\r\n            keywordDefinitionArray.push(definition);\r\n        }\r\n\r\n        this.speechContext.setSection(\"invocationSource\", \"VoiceActivationWithKeyword\");\r\n        this.speechContext.setSection(\"keywordDetection\", [{\r\n            clientDetectedKeywords: keywordDefinitionArray,\r\n            onReject: { action: \"EndOfTurn\" },\r\n            type: \"startTrigger\"\r\n        }]);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}