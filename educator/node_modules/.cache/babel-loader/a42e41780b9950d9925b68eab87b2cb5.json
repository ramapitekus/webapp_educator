{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\nimport { ArgumentNullError, BackgroundEvent, ConnectionClosedEvent, ConnectionErrorEvent, ConnectionEstablishedEvent, ConnectionMessageReceivedEvent, ConnectionMessageSentEvent, ConnectionOpenResponse, ConnectionStartEvent, ConnectionState, Deferred, Events, EventSource, MessageType, Queue, RawWebsocketMessage } from \"../common/Exports\"; // Node.JS specific web socket / browser support.\n\nimport ws from \"ws\";\nimport { CertCheckAgent } from \"./CertChecks\";\nexport class WebsocketMessageAdapter {\n  constructor(uri, connectionId, messageFormatter, proxyInfo, headers, enableCompression) {\n    this.open = () => {\n      if (this.privConnectionState === ConnectionState.Disconnected) {\n        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);\n      }\n\n      if (this.privConnectionEstablishDeferral) {\n        return this.privConnectionEstablishDeferral.promise;\n      }\n\n      this.privConnectionEstablishDeferral = new Deferred();\n      this.privCertificateValidatedDeferral = new Deferred();\n      this.privConnectionState = ConnectionState.Connecting;\n\n      try {\n        if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\n          // Browser handles cert checks.\n          this.privCertificateValidatedDeferral.resolve();\n          this.privWebsocketClient = new WebSocket(this.privUri);\n        } else {\n          const options = {\n            headers: this.privHeaders,\n            perMessageDeflate: this.privEnableCompression\n          }; // The ocsp library will handle validation for us and fail the connection if needed.\n\n          this.privCertificateValidatedDeferral.resolve();\n          const checkAgent = new CertCheckAgent(this.proxyInfo);\n          options.agent = checkAgent.GetAgent(); // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\n          // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\n\n          const uri = new URL(this.privUri);\n          let protocol = uri.protocol;\n\n          if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"wss:\") {\n            protocol = \"https:\";\n          } else if ((protocol === null || protocol === void 0 ? void 0 : protocol.toLocaleLowerCase()) === \"ws:\") {\n            protocol = \"http:\";\n          }\n\n          options.agent.protocol = protocol;\n          this.privWebsocketClient = new ws(this.privUri, options);\n        }\n\n        this.privWebsocketClient.binaryType = \"arraybuffer\";\n        this.privReceivingMessageQueue = new Queue();\n        this.privDisconnectDeferral = new Deferred();\n        this.privSendMessageQueue = new Queue();\n        this.processSendQueue().catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      } catch (error) {\n        this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\n        return this.privConnectionEstablishDeferral.promise;\n      }\n\n      this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\n\n      this.privWebsocketClient.onopen = e => {\n        this.privCertificateValidatedDeferral.promise.then(() => {\n          this.privConnectionState = ConnectionState.Connected;\n          this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\n        }, error => {\n          this.privConnectionEstablishDeferral.reject(error);\n        });\n      };\n\n      this.privWebsocketClient.onerror = e => {\n        this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\n        this.privLastErrorReceived = e.message;\n      };\n\n      this.privWebsocketClient.onclose = e => {\n        if (this.privConnectionState === ConnectionState.Connecting) {\n          this.privConnectionState = ConnectionState.Disconnected; // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\n\n          this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\n        } else {\n          this.privConnectionState = ConnectionState.Disconnected;\n          this.privWebsocketClient = null;\n          this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\n        }\n\n        this.onClose(e.code, e.reason).catch(reason => {\n          Events.instance.onEvent(new BackgroundEvent(reason));\n        });\n      };\n\n      this.privWebsocketClient.onmessage = e => {\n        const networkReceivedTime = new Date().toISOString();\n\n        if (this.privConnectionState === ConnectionState.Connected) {\n          const deferred = new Deferred(); // let id = ++this.idCounter;\n\n          this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\n\n          if (e.data instanceof ArrayBuffer) {\n            const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid binary message format. Error: ${error}`);\n            });\n          } else {\n            const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\n            this.privMessageFormatter.toConnectionMessage(rawMessage).then(connectionMessage => {\n              this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\n              deferred.resolve(connectionMessage);\n            }, error => {\n              // TODO: Events for these ?\n              deferred.reject(`Invalid text message format. Error: ${error}`);\n            });\n          }\n        }\n      };\n\n      return this.privConnectionEstablishDeferral.promise;\n    };\n\n    this.send = message => {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\n      }\n\n      const messageSendStatusDeferral = new Deferred();\n      const messageSendDeferral = new Deferred();\n      this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\n      this.privMessageFormatter.fromConnectionMessage(message).then(rawMessage => {\n        messageSendDeferral.resolve({\n          Message: message,\n          RawWebsocketMessage: rawMessage,\n          sendStatusDeferral: messageSendStatusDeferral\n        });\n      }, error => {\n        messageSendDeferral.reject(`Error formatting the message. ${error}`);\n      });\n      return messageSendStatusDeferral.promise;\n    };\n\n    this.read = () => {\n      if (this.privConnectionState !== ConnectionState.Connected) {\n        return Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`);\n      }\n\n      return this.privReceivingMessageQueue.dequeue();\n    };\n\n    this.close = reason => {\n      if (this.privWebsocketClient) {\n        if (this.privConnectionState !== ConnectionState.Disconnected) {\n          this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\n        }\n      } else {\n        return Promise.resolve();\n      }\n\n      return this.privDisconnectDeferral.promise;\n    };\n\n    this.sendRawMessage = sendItem => {\n      try {\n        // indicates we are draining the queue and it came with no message;\n        if (!sendItem) {\n          return Promise.resolve();\n        }\n\n        this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message)); // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\n\n        if (this.isWebsocketOpen) {\n          this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\n        } else {\n          return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\n        }\n\n        return Promise.resolve();\n      } catch (e) {\n        return Promise.reject(`websocket send error: ${e}`);\n      }\n    };\n\n    this.onEvent = event => {\n      this.privConnectionEvents.onEvent(event);\n      Events.instance.onEvent(event);\n    };\n\n    if (!uri) {\n      throw new ArgumentNullError(\"uri\");\n    }\n\n    if (!messageFormatter) {\n      throw new ArgumentNullError(\"messageFormatter\");\n    }\n\n    this.proxyInfo = proxyInfo;\n    this.privConnectionEvents = new EventSource();\n    this.privConnectionId = connectionId;\n    this.privMessageFormatter = messageFormatter;\n    this.privConnectionState = ConnectionState.None;\n    this.privUri = uri;\n    this.privHeaders = headers;\n    this.privEnableCompression = enableCompression; // Add the connection ID to the headers\n\n    this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\n    this.privLastErrorReceived = \"\";\n  }\n\n  get state() {\n    return this.privConnectionState;\n  }\n\n  get events() {\n    return this.privConnectionEvents;\n  }\n\n  onClose(code, reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const closeReason = `Connection closed. ${code}: ${reason}`;\n      this.privConnectionState = ConnectionState.Disconnected;\n      this.privDisconnectDeferral.resolve();\n      yield this.privReceivingMessageQueue.drainAndDispose(pendingReceiveItem => {// TODO: Events for these ?\n        // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\n      }, closeReason);\n      yield this.privSendMessageQueue.drainAndDispose(pendingSendItem => {\n        pendingSendItem.sendStatusDeferral.reject(closeReason);\n      }, closeReason);\n    });\n  }\n\n  processSendQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n      while (true) {\n        const itemToSend = this.privSendMessageQueue.dequeue();\n        const sendItem = yield itemToSend; // indicates we are draining the queue and it came with no message;\n\n        if (!sendItem) {\n          return;\n        }\n\n        try {\n          yield this.sendRawMessage(sendItem);\n          sendItem.sendStatusDeferral.resolve();\n        } catch (sendError) {\n          sendItem.sendStatusDeferral.reject(sendError);\n        }\n      }\n    });\n  }\n\n  get isWebsocketOpen() {\n    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\n  }\n\n}\nWebsocketMessageAdapter.forceNpmWebSocket = false;","map":{"version":3,"mappings":"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","names":["HeaderNames","ArgumentNullError","BackgroundEvent","ConnectionClosedEvent","ConnectionErrorEvent","ConnectionEstablishedEvent","ConnectionMessageReceivedEvent","ConnectionMessageSentEvent","ConnectionOpenResponse","ConnectionStartEvent","ConnectionState","Deferred","Events","EventSource","MessageType","Queue","RawWebsocketMessage","ws","CertCheckAgent","WebsocketMessageAdapter","constructor","uri","connectionId","messageFormatter","proxyInfo","headers","enableCompression","privConnectionState","Disconnected","Promise","reject","privConnectionEstablishDeferral","promise","privCertificateValidatedDeferral","Connecting","WebSocket","forceNpmWebSocket","resolve","privWebsocketClient","privUri","options","privHeaders","perMessageDeflate","privEnableCompression","checkAgent","agent","GetAgent","URL","protocol","toLocaleLowerCase","binaryType","privReceivingMessageQueue","privDisconnectDeferral","privSendMessageQueue","processSendQueue","catch","reason","instance","onEvent","error","privConnectionId","onopen","e","then","Connected","onerror","message","type","privLastErrorReceived","onclose","code","onClose","onmessage","networkReceivedTime","Date","toISOString","deferred","enqueueFromPromise","data","ArrayBuffer","rawMessage","Binary","privMessageFormatter","toConnectionMessage","connectionMessage","Text","messageSendStatusDeferral","messageSendDeferral","fromConnectionMessage","Message","sendStatusDeferral","dequeue","close","sendItem","isWebsocketOpen","send","payload","id","Error","stack","event","privConnectionEvents","None","ConnectionId","state","events","closeReason","drainAndDispose","pendingReceiveItem","pendingSendItem","itemToSend","sendRawMessage","sendError","readyState","OPEN"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.browser\\src\\common.browser\\WebsocketMessageAdapter.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { HeaderNames } from \"../common.speech/HeaderNames\";\r\nimport {\r\n    ArgumentNullError,\r\n    BackgroundEvent,\r\n    ConnectionClosedEvent,\r\n    ConnectionErrorEvent,\r\n    ConnectionEstablishedEvent,\r\n    ConnectionEvent,\r\n    ConnectionMessage,\r\n    ConnectionMessageReceivedEvent,\r\n    ConnectionMessageSentEvent,\r\n    ConnectionOpenResponse,\r\n    ConnectionStartEvent,\r\n    ConnectionState,\r\n    Deferred,\r\n    Events,\r\n    EventSource,\r\n    IWebsocketMessageFormatter,\r\n    MessageType,\r\n    Queue,\r\n    RawWebsocketMessage,\r\n} from \"../common/Exports\";\r\nimport { ProxyInfo } from \"./ProxyInfo\";\r\n\r\n// Node.JS specific web socket / browser support.\r\nimport ws from \"ws\";\r\nimport { CertCheckAgent } from \"./CertChecks\";\r\n\r\ninterface ISendItem {\r\n    Message: ConnectionMessage;\r\n    RawWebsocketMessage: RawWebsocketMessage;\r\n    sendStatusDeferral: Deferred<void>;\r\n}\r\n\r\nexport class WebsocketMessageAdapter {\r\n    private privConnectionState: ConnectionState;\r\n    private privMessageFormatter: IWebsocketMessageFormatter;\r\n    private privWebsocketClient: WebSocket | ws;\r\n\r\n    private privSendMessageQueue: Queue<ISendItem>;\r\n    private privReceivingMessageQueue: Queue<ConnectionMessage>;\r\n    private privConnectionEstablishDeferral: Deferred<ConnectionOpenResponse>;\r\n    private privCertificateValidatedDeferral: Deferred<void>;\r\n    private privDisconnectDeferral: Deferred<void>;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privConnectionId: string;\r\n    private privUri: string;\r\n    private proxyInfo: ProxyInfo;\r\n    private privHeaders: { [key: string]: string; };\r\n    private privLastErrorReceived: string;\r\n    private privEnableCompression: boolean;\r\n\r\n    public static forceNpmWebSocket: boolean = false;\r\n\r\n    public constructor(\r\n        uri: string,\r\n        connectionId: string,\r\n        messageFormatter: IWebsocketMessageFormatter,\r\n        proxyInfo: ProxyInfo,\r\n        headers: { [key: string]: string; },\r\n        enableCompression: boolean) {\r\n\r\n        if (!uri) {\r\n            throw new ArgumentNullError(\"uri\");\r\n        }\r\n\r\n        if (!messageFormatter) {\r\n            throw new ArgumentNullError(\"messageFormatter\");\r\n        }\r\n\r\n        this.proxyInfo = proxyInfo;\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privConnectionId = connectionId;\r\n        this.privMessageFormatter = messageFormatter;\r\n        this.privConnectionState = ConnectionState.None;\r\n        this.privUri = uri;\r\n        this.privHeaders = headers;\r\n        this.privEnableCompression = enableCompression;\r\n\r\n        // Add the connection ID to the headers\r\n        this.privHeaders[HeaderNames.ConnectionId] = this.privConnectionId;\r\n\r\n        this.privLastErrorReceived = \"\";\r\n    }\r\n\r\n    public get state(): ConnectionState {\r\n        return this.privConnectionState;\r\n    }\r\n\r\n    public open = (): Promise<ConnectionOpenResponse> => {\r\n        if (this.privConnectionState === ConnectionState.Disconnected) {\r\n            return Promise.reject<ConnectionOpenResponse>(`Cannot open a connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        if (this.privConnectionEstablishDeferral) {\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.privConnectionEstablishDeferral = new Deferred<ConnectionOpenResponse>();\r\n        this.privCertificateValidatedDeferral = new Deferred<void>();\r\n\r\n        this.privConnectionState = ConnectionState.Connecting;\r\n\r\n        try {\r\n\r\n            if (typeof WebSocket !== \"undefined\" && !WebsocketMessageAdapter.forceNpmWebSocket) {\r\n                // Browser handles cert checks.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n\r\n                this.privWebsocketClient = new WebSocket(this.privUri);\r\n            } else {\r\n                const options: ws.ClientOptions = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };\r\n                // The ocsp library will handle validation for us and fail the connection if needed.\r\n                this.privCertificateValidatedDeferral.resolve();\r\n                const checkAgent: CertCheckAgent = new CertCheckAgent(this.proxyInfo);\r\n\r\n                options.agent = checkAgent.GetAgent();\r\n\r\n                // Workaround for https://github.com/microsoft/cognitive-services-speech-sdk-js/issues/465\r\n                // Which is root caused by https://github.com/TooTallNate/node-agent-base/issues/61\r\n                const uri = new URL(this.privUri);\r\n                let protocol: string = uri.protocol;\r\n\r\n                if (protocol?.toLocaleLowerCase() === \"wss:\") {\r\n                    protocol = \"https:\";\r\n                } else if (protocol?.toLocaleLowerCase() === \"ws:\") {\r\n                    protocol = \"http:\";\r\n                }\r\n                (options.agent as any).protocol = protocol;\r\n                this.privWebsocketClient = new ws(this.privUri, options);\r\n            }\r\n\r\n            this.privWebsocketClient.binaryType = \"arraybuffer\";\r\n            this.privReceivingMessageQueue = new Queue<ConnectionMessage>();\r\n            this.privDisconnectDeferral = new Deferred<void>();\r\n            this.privSendMessageQueue = new Queue<ISendItem>();\r\n            this.processSendQueue().catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        } catch (error) {\r\n            this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(500, error));\r\n            return this.privConnectionEstablishDeferral.promise;\r\n        }\r\n\r\n        this.onEvent(new ConnectionStartEvent(this.privConnectionId, this.privUri));\r\n\r\n        this.privWebsocketClient.onopen = (e: { target: WebSocket | ws }) => {\r\n            this.privCertificateValidatedDeferral.promise.then((): void => {\r\n                this.privConnectionState = ConnectionState.Connected;\r\n                this.onEvent(new ConnectionEstablishedEvent(this.privConnectionId));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(200, \"\"));\r\n            }, (error: string): void => {\r\n                this.privConnectionEstablishDeferral.reject(error);\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onerror = (e: { error: any; message: string; type: string; target: WebSocket | ws }) => {\r\n            this.onEvent(new ConnectionErrorEvent(this.privConnectionId, e.message, e.type));\r\n            this.privLastErrorReceived = e.message;\r\n        };\r\n\r\n        this.privWebsocketClient.onclose = (e: { wasClean: boolean; code: number; reason: string; target: WebSocket | ws }) => {\r\n            if (this.privConnectionState === ConnectionState.Connecting) {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                // this.onEvent(new ConnectionEstablishErrorEvent(this.connectionId, e.code, e.reason));\r\n                this.privConnectionEstablishDeferral.resolve(new ConnectionOpenResponse(e.code, e.reason + \" \" + this.privLastErrorReceived));\r\n            } else {\r\n                this.privConnectionState = ConnectionState.Disconnected;\r\n                this.privWebsocketClient = null;\r\n                this.onEvent(new ConnectionClosedEvent(this.privConnectionId, e.code, e.reason));\r\n            }\r\n\r\n            this.onClose(e.code, e.reason).catch((reason: string): void => {\r\n                Events.instance.onEvent(new BackgroundEvent(reason));\r\n            });\r\n        };\r\n\r\n        this.privWebsocketClient.onmessage = (e: { data: ws.Data; type: string; target: WebSocket | ws }) => {\r\n            const networkReceivedTime = new Date().toISOString();\r\n            if (this.privConnectionState === ConnectionState.Connected) {\r\n                const deferred = new Deferred<ConnectionMessage>();\r\n                // let id = ++this.idCounter;\r\n                this.privReceivingMessageQueue.enqueueFromPromise(deferred.promise);\r\n                if (e.data instanceof ArrayBuffer) {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Binary, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage) => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string) => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid binary message format. Error: ${error}`);\r\n                        });\r\n                } else {\r\n                    const rawMessage = new RawWebsocketMessage(MessageType.Text, e.data);\r\n                    this.privMessageFormatter\r\n                        .toConnectionMessage(rawMessage)\r\n                        .then((connectionMessage: ConnectionMessage) => {\r\n                            this.onEvent(new ConnectionMessageReceivedEvent(this.privConnectionId, networkReceivedTime, connectionMessage));\r\n                            deferred.resolve(connectionMessage);\r\n                        }, (error: string) => {\r\n                            // TODO: Events for these ?\r\n                            deferred.reject(`Invalid text message format. Error: ${error}`);\r\n                        });\r\n                }\r\n            }\r\n        };\r\n\r\n        return this.privConnectionEstablishDeferral.promise;\r\n    }\r\n\r\n    public send = (message: ConnectionMessage): Promise<void> => {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(`Cannot send on connection that is in ${ConnectionState[this.privConnectionState]} state`);\r\n        }\r\n\r\n        const messageSendStatusDeferral = new Deferred<void>();\r\n        const messageSendDeferral = new Deferred<ISendItem>();\r\n\r\n        this.privSendMessageQueue.enqueueFromPromise(messageSendDeferral.promise);\r\n\r\n        this.privMessageFormatter\r\n            .fromConnectionMessage(message)\r\n            .then((rawMessage: RawWebsocketMessage) => {\r\n                messageSendDeferral.resolve({\r\n                    Message: message,\r\n                    RawWebsocketMessage: rawMessage,\r\n                    sendStatusDeferral: messageSendStatusDeferral,\r\n                });\r\n            }, (error: string) => {\r\n                messageSendDeferral.reject(`Error formatting the message. ${error}`);\r\n            });\r\n\r\n        return messageSendStatusDeferral.promise;\r\n    }\r\n\r\n    public read = (): Promise<ConnectionMessage> => {\r\n        if (this.privConnectionState !== ConnectionState.Connected) {\r\n            return Promise.reject<ConnectionMessage>(`Cannot read on connection that is in ${this.privConnectionState} state`);\r\n        }\r\n\r\n        return this.privReceivingMessageQueue.dequeue();\r\n    }\r\n\r\n    public close = (reason?: string): Promise<void> => {\r\n        if (this.privWebsocketClient) {\r\n            if (this.privConnectionState !== ConnectionState.Disconnected) {\r\n                this.privWebsocketClient.close(1000, reason ? reason : \"Normal closure by client\");\r\n            }\r\n        } else {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        return this.privDisconnectDeferral.promise;\r\n    }\r\n\r\n    public get events(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    private sendRawMessage = (sendItem: ISendItem): Promise<void> => {\r\n        try {\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return Promise.resolve();\r\n            }\r\n\r\n            this.onEvent(new ConnectionMessageSentEvent(this.privConnectionId, new Date().toISOString(), sendItem.Message));\r\n\r\n            // add a check for the ws readystate in order to stop the red console error 'WebSocket is already in CLOSING or CLOSED state' appearing\r\n            if (this.isWebsocketOpen) {\r\n                this.privWebsocketClient.send(sendItem.RawWebsocketMessage.payload);\r\n            } else {\r\n                return Promise.reject(\"websocket send error: Websocket not ready \" + this.privConnectionId + \" \" + sendItem.Message.id + \" \" + new Error().stack);\r\n            }\r\n            return Promise.resolve();\r\n\r\n        } catch (e) {\r\n            return Promise.reject(`websocket send error: ${e}`);\r\n        }\r\n    }\r\n\r\n    private async onClose(code: number, reason: string): Promise<void> {\r\n        const closeReason = `Connection closed. ${code}: ${reason}`;\r\n        this.privConnectionState = ConnectionState.Disconnected;\r\n        this.privDisconnectDeferral.resolve();\r\n        await this.privReceivingMessageQueue.drainAndDispose((pendingReceiveItem: ConnectionMessage) => {\r\n            // TODO: Events for these ?\r\n            // Logger.instance.onEvent(new LoggingEvent(LogType.Warning, null, `Failed to process received message. Reason: ${closeReason}, Message: ${JSON.stringify(pendingReceiveItem)}`));\r\n        }, closeReason);\r\n\r\n        await this.privSendMessageQueue.drainAndDispose((pendingSendItem: ISendItem) => {\r\n            pendingSendItem.sendStatusDeferral.reject(closeReason);\r\n        }, closeReason);\r\n    }\r\n\r\n    private async processSendQueue(): Promise<void> {\r\n        while (true) {\r\n            const itemToSend: Promise<ISendItem> = this.privSendMessageQueue.dequeue();\r\n            const sendItem: ISendItem = await itemToSend;\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!sendItem) {\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.sendRawMessage(sendItem);\r\n                sendItem.sendStatusDeferral.resolve();\r\n            } catch (sendError) {\r\n                sendItem.sendStatusDeferral.reject(sendError);\r\n            }\r\n        }\r\n    }\r\n\r\n    private onEvent = (event: ConnectionEvent): void => {\r\n        this.privConnectionEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private get isWebsocketOpen(): boolean {\r\n        return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}