{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\n// Multi-device Conversation is a Preview feature.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\nimport { marshalPromiseToCallbacks } from \"../../common/Exports\";\nimport { Contracts } from \"../Contracts\";\nimport { AudioConfig, CancellationErrorCode, CancellationReason, ProfanityOption, PropertyCollection, PropertyId, SpeechTranslationConfig, TranslationRecognizer } from \"../Exports\";\nimport { ConversationImpl } from \"./Conversation\";\nimport { ConversationCommon, ConversationTranslationCanceledEventArgs } from \"./Exports\";\nexport var SpeechState;\n\n(function (SpeechState) {\n  SpeechState[SpeechState[\"Inactive\"] = 0] = \"Inactive\";\n  SpeechState[SpeechState[\"Connecting\"] = 1] = \"Connecting\";\n  SpeechState[SpeechState[\"Connected\"] = 2] = \"Connected\";\n})(SpeechState || (SpeechState = {})); // tslint:disable:max-classes-per-file\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\n\n\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\n  constructor(speechConfig, audioConfig, translator) {\n    super(speechConfig, audioConfig);\n    this.privSpeechState = SpeechState.Inactive;\n\n    if (!!translator) {\n      this.privTranslator = translator;\n\n      this.sessionStarted = () => {\n        this.privSpeechState = SpeechState.Connected;\n      };\n\n      this.sessionStopped = () => {\n        this.privSpeechState = SpeechState.Inactive;\n      };\n\n      this.recognized = (tr, e) => __awaiter(this, void 0, void 0, function* () {\n        // TODO: add support for getting recognitions from here if own speech\n        var _a; // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\n\n\n        if ((_a = e.result) === null || _a === void 0 ? void 0 : _a.errorDetails) {\n          yield this.cancelSpeech(); // TODO: format the error message contained in 'errorDetails'\n\n          this.fireCancelEvent(e.result.errorDetails);\n        }\n      });\n\n      this.canceled = (r, e) => __awaiter(this, void 0, void 0, function* () {\n        if (this.privSpeechState !== SpeechState.Inactive) {\n          try {\n            yield this.cancelSpeech();\n          } catch (error) {\n            this.privSpeechState = SpeechState.Inactive;\n          }\n        }\n      });\n    }\n  }\n\n  get state() {\n    return this.privSpeechState;\n  }\n\n  set state(newState) {\n    this.privSpeechState = newState;\n  }\n\n  onConnection() {\n    this.privSpeechState = SpeechState.Connected;\n  }\n\n  onDisconnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privSpeechState = SpeechState.Inactive;\n      yield this.cancelSpeech();\n    });\n  }\n  /**\r\n   * Fire a cancel event\r\n   * @param error\r\n   */\n\n\n  fireCancelEvent(error) {\n    var _a, _b, _c;\n\n    try {\n      if (!!this.privTranslator.canceled) {\n        const cancelEvent = new ConversationTranslationCanceledEventArgs((_a = error === null || error === void 0 ? void 0 : error.reason) !== null && _a !== void 0 ? _a : CancellationReason.Error, (_b = error === null || error === void 0 ? void 0 : error.errorDetails) !== null && _b !== void 0 ? _b : error, (_c = error === null || error === void 0 ? void 0 : error.errorCode) !== null && _c !== void 0 ? _c : CancellationErrorCode.RuntimeError, undefined, error === null || error === void 0 ? void 0 : error.sessionId);\n        this.privTranslator.canceled(this.privTranslator, cancelEvent);\n      }\n    } catch (e) {//\n    }\n  }\n\n  cancelSpeech() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.stopContinuousRecognitionAsync();\n        yield (_a = this.privReco) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.privSpeechState = SpeechState.Inactive;\n      } catch (e) {// ignore the error\n      }\n    });\n  }\n\n}\n/***\r\n * Join, leave or connect to a conversation.\r\n */\n\n\nexport class ConversationTranslator extends ConversationCommon {\n  constructor(audioConfig) {\n    super(audioConfig);\n    this.privIsDisposed = false;\n    this.privIsSpeaking = false;\n    this.privErrors = ConversationConnectionConfig.restErrors;\n    this.privPlaceholderKey = \"abcdefghijklmnopqrstuvwxyz012345\";\n    this.privPlaceholderRegion = \"westus\";\n    this.privProperties = new PropertyCollection();\n  }\n\n  get properties() {\n    return this.privProperties;\n  }\n\n  get speechRecognitionLanguage() {\n    return this.privSpeechRecognitionLanguage;\n  }\n\n  get participants() {\n    var _a;\n\n    return (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.participants;\n  }\n\n  joinConversationAsync(conversation, nickname, param1, param2, param3) {\n    try {\n      if (typeof conversation === \"string\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\n\n        if (!!this.privConversation) {\n          this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\n        }\n\n        let lang = param1;\n\n        if (lang === undefined || lang === null || lang === \"\") {\n          lang = ConversationConnectionConfig.defaultLanguageCode;\n        } // create a placeholder config\n\n\n        this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion);\n        this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\n        this.privSpeechTranslationConfig.addTargetLanguage(lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\n        const endpoint = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\n\n        if (endpoint) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\n        }\n\n        const speechEndpointHost = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\n\n        if (speechEndpointHost) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\n        } // join the conversation\n\n\n        this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\n        this.privConversation.conversationTranslator = this;\n        this.privConversation.joinConversationAsync(conversation, nickname, lang, result => {\n          if (!result) {\n            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\n          }\n\n          this.privSpeechTranslationConfig.authorizationToken = result; // connect to the ws\n\n          this.privConversation.startConversationAsync(() => {\n            this.handleCallback(param2, param3);\n          }, error => {\n            this.handleError(error, param3);\n          });\n        }, error => {\n          this.handleError(error, param3);\n        });\n      } else if (typeof conversation === \"object\") {\n        Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\n        Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\")); // save the nickname\n\n        this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname); // ref the conversation object\n\n        this.privConversation = conversation; // ref the conversation translator object\n\n        this.privConversation.conversationTranslator = this;\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n        this.privSpeechTranslationConfig = conversation.config;\n        this.handleCallback(param1, param2);\n      } else {\n        this.handleError(new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")), param2);\n      }\n    } catch (error) {\n      this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\n    }\n  }\n  /**\r\n   * Leave the conversation\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  leaveConversationAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      // stop the speech websocket\n      yield this.cancelSpeech(); // stop the websocket\n\n      yield this.privConversation.endConversationImplAsync(); // https delete request\n\n      yield this.privConversation.deleteConversationImplAsync();\n      this.dispose();\n    }))(), cb, err);\n  }\n  /**\r\n   * Send a text message\r\n   * @param message\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  sendTextMessageAsync(message, cb, err) {\n    var _a;\n\n    try {\n      Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n      Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\n      (_a = this.privConversation) === null || _a === void 0 ? void 0 : _a.sendTextMessageAsync(message, cb, err);\n    } catch (error) {\n      this.handleError(error, err);\n    }\n  }\n  /**\r\n   * Start speaking\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  startTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\n        Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\n\n        if (this.privCTRecognizer === undefined) {\n          yield this.connectTranslatorRecognizer();\n        }\n\n        Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\n\n        if (!this.canSpeak) {\n          this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\n        }\n\n        yield this.startContinuousRecognition();\n        this.privIsSpeaking = true;\n      } catch (error) {\n        this.privIsSpeaking = false;\n        yield this.cancelSpeech();\n        throw error;\n      }\n    }))(), cb, err);\n  }\n  /**\r\n   * Stop speaking\r\n   * @param cb\r\n   * @param err\r\n   */\n\n\n  stopTranscribingAsync(cb, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (!this.privIsSpeaking) {\n          // stop speech\n          yield this.cancelSpeech();\n          return;\n        } // stop the recognition but leave the websocket open\n\n\n        this.privIsSpeaking = false;\n        yield new Promise((resolve, reject) => {\n          var _a;\n\n          (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.stopContinuousRecognitionAsync(resolve, reject);\n        });\n      } catch (error) {\n        yield this.cancelSpeech();\n      }\n    }))(), cb, err);\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason, success, err) {\n    marshalPromiseToCallbacks((() => __awaiter(this, void 0, void 0, function* () {\n      var _a, _b;\n\n      if (this.isDisposed && !this.privIsSpeaking) {\n        return;\n      }\n\n      yield this.cancelSpeech();\n      this.privIsDisposed = true;\n      (_a = this.privSpeechTranslationConfig) === null || _a === void 0 ? void 0 : _a.close();\n      this.privSpeechRecognitionLanguage = undefined;\n      this.privProperties = undefined;\n      this.privAudioConfig = undefined;\n      this.privSpeechTranslationConfig = undefined;\n      (_b = this.privConversation) === null || _b === void 0 ? void 0 : _b.dispose();\n      this.privConversation = undefined;\n    }))(), success, err);\n  }\n  /**\r\n   * Cancel the speech websocket\r\n   */\n\n\n  cancelSpeech() {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        this.privIsSpeaking = false;\n        yield (_a = this.privCTRecognizer) === null || _a === void 0 ? void 0 : _a.onDisconnection();\n        this.privCTRecognizer = undefined;\n      } catch (e) {// ignore the error\n      }\n    });\n  }\n  /**\r\n   * Connect to the speech translation recognizer.\r\n   * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\r\n   * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\r\n   * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\r\n   */\n\n\n  connectTranslatorRecognizer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.privAudioConfig === undefined) {\n          this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\n        } // clear the temp subscription key if it's a participant joining\n\n\n        if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey) {\n          this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\n        } // TODO\n\n\n        const token = encodeURIComponent(this.privConversation.room.token);\n        let endpointHost = this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\n        endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\n        const url = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\n        this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\n        this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\n      } catch (error) {\n        yield this.cancelSpeech();\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Handle the start speaking request\r\n   */\n\n\n  startContinuousRecognition() {\n    return new Promise((resolve, reject) => {\n      this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\n    });\n  }\n\n  get canSpeak() {\n    // is there a Conversation websocket available and has the Recognizer been set up\n    if (!this.privConversation.isConnected || !this.privCTRecognizer) {\n      return false;\n    } // is the user already speaking\n\n\n    if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\n      return false;\n    } // is the user muted\n\n\n    if (this.privConversation.isMutedByHost) {\n      return false;\n    }\n\n    return true;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ConversationConnectionConfig","marshalPromiseToCallbacks","Contracts","AudioConfig","CancellationErrorCode","CancellationReason","ProfanityOption","PropertyCollection","PropertyId","SpeechTranslationConfig","TranslationRecognizer","ConversationImpl","ConversationCommon","ConversationTranslationCanceledEventArgs","SpeechState","ConversationTranslationRecognizer","constructor","speechConfig","audioConfig","translator","privSpeechState","Inactive","privTranslator","sessionStarted","Connected","sessionStopped","recognized","tr","e","__awaiter","result","_a","errorDetails","cancelSpeech","fireCancelEvent","canceled","r","error","state","newState","onConnection","onDisconnection","cancelEvent","reason","Error","_b","errorCode","_c","RuntimeError","undefined","sessionId","stopContinuousRecognitionAsync","privReco","disconnect","ConversationTranslator","restErrors","privProperties","properties","speechRecognitionLanguage","privSpeechRecognitionLanguage","participants","privConversation","joinConversationAsync","conversation","nickname","param1","param2","param3","throwIfNullOrUndefined","privErrors","invalidArgs","replace","throwIfNullOrWhitespace","handleError","permissionDeniedStart","lang","defaultLanguageCode","privSpeechTranslationConfig","fromSubscription","privPlaceholderKey","privPlaceholderRegion","setProfanity","Masked","addTargetLanguage","setProperty","SpeechServiceConnection_RecoLanguage","ConversationTranslator_Name","endpoint","getProperty","ConversationTranslator_Host","speechEndpointHost","SpeechServiceConnection_Host","conversationTranslator","permissionDeniedConnect","authorizationToken","startConversationAsync","handleCallback","room","token","config","leaveConversationAsync","cb","err","endConversationImplAsync","deleteConversationImplAsync","dispose","sendTextMessageAsync","message","permissionDeniedSend","startTranscribingAsync","privCTRecognizer","connectTranslatorRecognizer","canSpeak","startContinuousRecognition","privIsSpeaking","stopTranscribingAsync","Promise","resolve","reject","isDisposed","privIsDisposed","success","close","privAudioConfig","fromDefaultMicrophoneInput","SpeechServiceConnection_Key","encodeURIComponent","endpointHost","speechHost","cognitiveSpeechRegion","url","speechPath","configParams","SpeechServiceConnection_Endpoint","startContinuousRecognitionAsync","isConnected","Connecting","isMutedByHost"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\sdk\\Transcription\\src\\sdk\\Transcription\\ConversationTranslator.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n// Multi-device Conversation is a Preview feature.\r\n\r\nimport { ConversationConnectionConfig } from \"../../common.speech/Exports\";\r\nimport {\r\n    IDisposable,\r\n    IErrorMessages,\r\n    marshalPromiseToCallbacks\r\n} from \"../../common/Exports\";\r\nimport { Contracts } from \"../Contracts\";\r\nimport {\r\n    AudioConfig,\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    ProfanityOption,\r\n    PropertyCollection,\r\n    PropertyId,\r\n    SessionEventArgs,\r\n    SpeechTranslationConfig,\r\n    TranslationRecognitionCanceledEventArgs,\r\n    TranslationRecognitionEventArgs,\r\n    TranslationRecognizer\r\n} from \"../Exports\";\r\nimport { ConversationImpl } from \"./Conversation\";\r\nimport {\r\n    ConversationCommon,\r\n    ConversationExpirationEventArgs,\r\n    ConversationHandler,\r\n    ConversationParticipantsChangedEventArgs,\r\n    ConversationTranslationCanceledEventArgs,\r\n    ConversationTranslationEventArgs,\r\n    IConversationTranslator,\r\n    Participant,\r\n} from \"./Exports\";\r\nimport { Callback, IConversation } from \"./IConversation\";\r\n\r\nexport enum SpeechState {\r\n    Inactive, Connecting, Connected\r\n}\r\n\r\n// tslint:disable:max-classes-per-file\r\n\r\n// child class of TranslationRecognizer meant only for use with ConversationTranslator\r\nclass ConversationTranslationRecognizer extends TranslationRecognizer {\r\n    private privTranslator: ConversationTranslator;\r\n    private privSpeechState: SpeechState;\r\n    public constructor(speechConfig: SpeechTranslationConfig, audioConfig?: AudioConfig, translator?: ConversationTranslator) {\r\n        super(speechConfig, audioConfig);\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        if (!!translator) {\r\n            this.privTranslator = translator;\r\n            this.sessionStarted = () => {\r\n                this.privSpeechState = SpeechState.Connected;\r\n            };\r\n\r\n            this.sessionStopped = () => {\r\n                this.privSpeechState = SpeechState.Inactive;\r\n            };\r\n\r\n            this.recognized = async (tr: TranslationRecognizer, e: TranslationRecognitionEventArgs) => {\r\n                // TODO: add support for getting recognitions from here if own speech\r\n\r\n                // if there is an error connecting to the conversation service from the speech service the error will be returned in the ErrorDetails field.\r\n                if (e.result?.errorDetails) {\r\n                    await this.cancelSpeech();\r\n                    // TODO: format the error message contained in 'errorDetails'\r\n                    this.fireCancelEvent(e.result.errorDetails);\r\n                }\r\n            };\r\n\r\n            this.canceled = async (r: TranslationRecognizer, e: TranslationRecognitionCanceledEventArgs) => {\r\n                if (this.privSpeechState !== SpeechState.Inactive) {\r\n                    try {\r\n                        await this.cancelSpeech();\r\n                    } catch (error) {\r\n                        this.privSpeechState = SpeechState.Inactive;\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    }\r\n    public get state(): SpeechState {\r\n        return this.privSpeechState;\r\n    }\r\n\r\n    public set state(newState: SpeechState) {\r\n        this.privSpeechState = newState;\r\n    }\r\n\r\n    public onConnection(): void {\r\n        this.privSpeechState = SpeechState.Connected;\r\n    }\r\n\r\n    public async onDisconnection(): Promise<void> {\r\n        this.privSpeechState = SpeechState.Inactive;\r\n        await this.cancelSpeech();\r\n    }\r\n\r\n    /**\r\n     * Fire a cancel event\r\n     * @param error\r\n     */\r\n    private fireCancelEvent(error: any): void {\r\n        try {\r\n            if (!!this.privTranslator.canceled) {\r\n                const cancelEvent: ConversationTranslationCanceledEventArgs = new ConversationTranslationCanceledEventArgs(\r\n                    error?.reason ?? CancellationReason.Error,\r\n                    error?.errorDetails ?? error,\r\n                    error?.errorCode ?? CancellationErrorCode.RuntimeError,\r\n                    undefined,\r\n                    error?.sessionId);\r\n\r\n                this.privTranslator.canceled(this.privTranslator, cancelEvent);\r\n            }\r\n        } catch (e) {\r\n            //\r\n        }\r\n    }\r\n\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.stopContinuousRecognitionAsync();\r\n            await this.privReco?.disconnect();\r\n            this.privSpeechState = SpeechState.Inactive;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/***\r\n * Join, leave or connect to a conversation.\r\n */\r\nexport class ConversationTranslator extends ConversationCommon implements IConversationTranslator, IDisposable {\r\n\r\n    private privSpeechRecognitionLanguage: string;\r\n    private privProperties: PropertyCollection;\r\n    private privIsDisposed: boolean = false;\r\n    private privCTRecognizer: ConversationTranslationRecognizer;\r\n    private privIsSpeaking: boolean = false;\r\n    private privConversation: ConversationImpl;\r\n    private privErrors: IErrorMessages = ConversationConnectionConfig.restErrors;\r\n    private privPlaceholderKey: string = \"abcdefghijklmnopqrstuvwxyz012345\";\r\n    private privPlaceholderRegion: string = \"westus\";\r\n\r\n    public constructor(audioConfig?: AudioConfig) {\r\n        super(audioConfig);\r\n        this.privProperties = new PropertyCollection();\r\n    }\r\n\r\n    public get properties(): PropertyCollection {\r\n        return this.privProperties;\r\n    }\r\n\r\n    public get speechRecognitionLanguage(): string {\r\n        return this.privSpeechRecognitionLanguage;\r\n    }\r\n\r\n    public get participants(): Participant[] {\r\n        return this.privConversation?.participants;\r\n    }\r\n\r\n    public canceled: (sender: ConversationHandler, event: ConversationTranslationCanceledEventArgs) => void;\r\n    public conversationExpiration: (sender: IConversationTranslator, event: ConversationExpirationEventArgs) => void;\r\n    public participantsChanged: (sender: IConversationTranslator, event: ConversationParticipantsChangedEventArgs) => void;\r\n    public sessionStarted: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public sessionStopped: (sender: ConversationHandler, event: SessionEventArgs) => void;\r\n    public textMessageReceived: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribed: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n    public transcribing: (sender: IConversationTranslator, event: ConversationTranslationEventArgs) => void;\r\n\r\n    /**\r\n     * Join a conversation. If this is the host, pass in the previously created Conversation object.\r\n     * @param conversation\r\n     * @param nickname\r\n     * @param lang\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public joinConversationAsync(conversation: IConversation, nickname: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversationId: string, nickname: string, lang: string, cb?: Callback, err?: Callback): void;\r\n    public joinConversationAsync(conversation: any, nickname: string, param1?: string | Callback, param2?: Callback, param3?: Callback): void {\r\n\r\n        try {\r\n\r\n            if (typeof conversation === \"string\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                if (!!this.privConversation) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedStart), param3);\r\n                }\r\n\r\n                let lang: string = param1 as string;\r\n                if (lang === undefined || lang === null || lang === \"\") { lang = ConversationConnectionConfig.defaultLanguageCode; }\r\n\r\n                // create a placeholder config\r\n                this.privSpeechTranslationConfig = SpeechTranslationConfig.fromSubscription(\r\n                    this.privPlaceholderKey,\r\n                    this.privPlaceholderRegion);\r\n                this.privSpeechTranslationConfig.setProfanity(ProfanityOption.Masked);\r\n                this.privSpeechTranslationConfig.addTargetLanguage(lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_RecoLanguage], lang);\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Name], nickname);\r\n\r\n                const endpoint: string = this.privProperties.getProperty(PropertyId.ConversationTranslator_Host);\r\n                if (endpoint) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.ConversationTranslator_Host], endpoint);\r\n                }\r\n                const speechEndpointHost: string = this.privProperties.getProperty(PropertyId.SpeechServiceConnection_Host);\r\n                if (speechEndpointHost) {\r\n                    this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Host], speechEndpointHost);\r\n                }\r\n\r\n                // join the conversation\r\n                this.privConversation = new ConversationImpl(this.privSpeechTranslationConfig);\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                this.privConversation.joinConversationAsync(\r\n                    conversation,\r\n                    nickname,\r\n                    lang,\r\n                    ((result: string) => {\r\n\r\n                        if (!result) {\r\n                            this.handleError(new Error(this.privErrors.permissionDeniedConnect), param3);\r\n                        }\r\n\r\n                        this.privSpeechTranslationConfig.authorizationToken = result;\r\n\r\n                        // connect to the ws\r\n                        this.privConversation.startConversationAsync(\r\n                            (() => {\r\n                                this.handleCallback(param2, param3);\r\n                            }),\r\n                            ((error: any) => {\r\n                                this.handleError(error, param3);\r\n                            }));\r\n\r\n                    }),\r\n                    ((error: any) => {\r\n                        this.handleError(error, param3);\r\n                    }));\r\n\r\n            } else if (typeof conversation === \"object\") {\r\n\r\n                Contracts.throwIfNullOrUndefined(conversation, this.privErrors.invalidArgs.replace(\"{arg}\", \"conversation id\"));\r\n                Contracts.throwIfNullOrWhitespace(nickname, this.privErrors.invalidArgs.replace(\"{arg}\", \"nickname\"));\r\n\r\n                // save the nickname\r\n                this.privProperties.setProperty(PropertyId.ConversationTranslator_Name, nickname);\r\n                // ref the conversation object\r\n                this.privConversation = conversation as ConversationImpl;\r\n                // ref the conversation translator object\r\n                this.privConversation.conversationTranslator = this;\r\n\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                this.privSpeechTranslationConfig = conversation.config;\r\n\r\n                this.handleCallback(param1 as Callback, param2);\r\n            } else {\r\n                this.handleError(\r\n                    new Error(this.privErrors.invalidArgs.replace(\"{arg}\", \"invalid conversation type\")),\r\n                    param2);\r\n            }\r\n\r\n        } catch (error) {\r\n            this.handleError(error, typeof param1 === \"string\" ? param3 : param2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Leave the conversation\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public leaveConversationAsync(cb?: Callback, err?: Callback): void {\r\n\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n\r\n            // stop the speech websocket\r\n            await this.cancelSpeech();\r\n            // stop the websocket\r\n            await this.privConversation.endConversationImplAsync();\r\n            // https delete request\r\n            await this.privConversation.deleteConversationImplAsync();\r\n            this.dispose();\r\n\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Send a text message\r\n     * @param message\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public sendTextMessageAsync(message: string, cb?: Callback, err?: Callback): void {\r\n\r\n        try {\r\n            Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n            Contracts.throwIfNullOrWhitespace(message, this.privErrors.invalidArgs.replace(\"{arg}\", message));\r\n\r\n            this.privConversation?.sendTextMessageAsync(message, cb, err);\r\n        } catch (error) {\r\n\r\n            this.handleError(error, err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public startTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend);\r\n                Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect);\r\n\r\n                if (this.privCTRecognizer === undefined) {\r\n                    await this.connectTranslatorRecognizer();\r\n                }\r\n                Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend);\r\n\r\n                if (!this.canSpeak) {\r\n                    this.handleError(new Error(this.privErrors.permissionDeniedSend), err);\r\n                }\r\n\r\n                await this.startContinuousRecognition();\r\n\r\n                this.privIsSpeaking = true;\r\n            } catch (error) {\r\n                this.privIsSpeaking = false;\r\n                await this.cancelSpeech();\r\n                throw error;\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    /**\r\n     * Stop speaking\r\n     * @param cb\r\n     * @param err\r\n     */\r\n    public stopTranscribingAsync(cb?: Callback, err?: Callback): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            try {\r\n                if (!this.privIsSpeaking) {\r\n                    // stop speech\r\n                    await this.cancelSpeech();\r\n                    return;\r\n                }\r\n\r\n                // stop the recognition but leave the websocket open\r\n                this.privIsSpeaking = false;\r\n                await new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n                    this.privCTRecognizer?.stopContinuousRecognitionAsync(resolve, reject);\r\n                });\r\n\r\n            } catch (error) {\r\n                await this.cancelSpeech();\r\n            }\r\n        })(), cb, err);\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public dispose(reason?: string, success?: () => void, err?: (error: string) => void): void {\r\n        marshalPromiseToCallbacks((async (): Promise<void> => {\r\n            if (this.isDisposed && !this.privIsSpeaking) {\r\n                return;\r\n            }\r\n            await this.cancelSpeech();\r\n            this.privIsDisposed = true;\r\n            this.privSpeechTranslationConfig?.close();\r\n            this.privSpeechRecognitionLanguage = undefined;\r\n            this.privProperties = undefined;\r\n            this.privAudioConfig = undefined;\r\n            this.privSpeechTranslationConfig = undefined;\r\n            this.privConversation?.dispose();\r\n            this.privConversation = undefined;\r\n        })(), success, err);\r\n    }\r\n\r\n    /**\r\n     * Cancel the speech websocket\r\n     */\r\n    private async cancelSpeech(): Promise<void> {\r\n        try {\r\n            this.privIsSpeaking = false;\r\n            await this.privCTRecognizer?.onDisconnection();\r\n            this.privCTRecognizer = undefined;\r\n        } catch (e) {\r\n            // ignore the error\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect to the speech translation recognizer.\r\n     * Currently there is no language validation performed before sending the SpeechLanguage code to the service.\r\n     * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'\r\n     * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'\r\n     */\r\n    private async connectTranslatorRecognizer(): Promise<void> {\r\n        try {\r\n\r\n            if (this.privAudioConfig === undefined) {\r\n                this.privAudioConfig = AudioConfig.fromDefaultMicrophoneInput();\r\n            }\r\n\r\n            // clear the temp subscription key if it's a participant joining\r\n            if (this.privSpeechTranslationConfig.getProperty(PropertyId[PropertyId.SpeechServiceConnection_Key])\r\n                === this.privPlaceholderKey) {\r\n                this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Key], \"\");\r\n            }\r\n\r\n            // TODO\r\n            const token: string = encodeURIComponent(this.privConversation.room.token);\r\n\r\n            let endpointHost: string = this.privSpeechTranslationConfig.getProperty(\r\n                PropertyId[PropertyId.SpeechServiceConnection_Host], ConversationConnectionConfig.speechHost);\r\n            endpointHost = endpointHost.replace(\"{region}\", this.privConversation.room.cognitiveSpeechRegion);\r\n\r\n            const url: string = `wss://${endpointHost}${ConversationConnectionConfig.speechPath}?${ConversationConnectionConfig.configParams.token}=${token}`;\r\n\r\n            this.privSpeechTranslationConfig.setProperty(PropertyId[PropertyId.SpeechServiceConnection_Endpoint], url);\r\n\r\n            this.privCTRecognizer = new ConversationTranslationRecognizer(this.privSpeechTranslationConfig, this.privAudioConfig, this);\r\n        } catch (error) {\r\n            await this.cancelSpeech();\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the start speaking request\r\n     */\r\n    private startContinuousRecognition(): Promise<void> {\r\n        return new Promise((resolve: () => void, reject: (error: string) => void): void => {\r\n            this.privCTRecognizer.startContinuousRecognitionAsync(resolve, reject);\r\n        });\r\n    }\r\n\r\n    private get canSpeak(): boolean {\r\n\r\n        // is there a Conversation websocket available and has the Recognizer been set up\r\n        if (!this.privConversation.isConnected || !this.privCTRecognizer) {\r\n            return false;\r\n        }\r\n\r\n        // is the user already speaking\r\n        if (this.privIsSpeaking || this.privCTRecognizer.state === SpeechState.Connected || this.privCTRecognizer.state === SpeechState.Connecting) {\r\n            return false;\r\n        }\r\n\r\n        // is the user muted\r\n        if (this.privConversation.isMutedByHost) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n"]},"metadata":{},"sourceType":"module"}