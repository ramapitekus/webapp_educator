{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { createNoDashGuid, Deferred, Events } from \"../common/Exports\";\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\nimport { ConnectingToSynthesisServiceEvent, SynthesisStartedEvent, SynthesisTriggeredEvent } from \"./SynthesisEvents\";\nexport class SynthesisTurn {\n  constructor() {\n    this.privIsDisposed = false;\n    this.privIsSynthesizing = false;\n    this.privIsSynthesisEnded = false;\n    this.privBytesReceived = 0;\n    this.privInTurn = false;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n\n    this.onPreConnectionStart = (authFetchEventId, connectionId) => {\n      this.privAuthFetchEventId = authFetchEventId;\n      this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\n    };\n\n    this.onAuthCompleted = (isError, error) => {\n      if (isError) {\n        this.onComplete();\n      }\n    };\n\n    this.onConnectionEstablishCompleted = (statusCode, reason) => {\n      if (statusCode === 200) {\n        this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\n        this.privBytesReceived = 0;\n        return;\n      } else if (statusCode === 403) {\n        this.onComplete();\n      }\n    };\n\n    this.onServiceResponseMessage = responseJson => {\n      const response = JSON.parse(responseJson);\n      this.streamId = response.audio.streamId;\n    };\n\n    this.onServiceTurnEndResponse = () => {\n      this.privInTurn = false;\n      this.privTurnDeferral.resolve();\n      this.onComplete();\n    };\n\n    this.onServiceTurnStartResponse = () => {\n      if (!!this.privTurnDeferral && !!this.privInTurn) {\n        // What? How are we starting a turn with another not done?\n        this.privTurnDeferral.reject(\"Another turn started before current completed.\"); // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\n\n        /* tslint:disable:no-empty */\n\n        this.privTurnDeferral.promise.then().catch(() => {});\n      }\n\n      this.privInTurn = true;\n      this.privTurnDeferral = new Deferred();\n    };\n\n    this.dispose = error => {\n      if (!this.privIsDisposed) {\n        // we should have completed by now. If we did not its an unknown error.\n        this.privIsDisposed = true;\n      }\n    };\n\n    this.onEvent = event => {\n      Events.instance.onEvent(event);\n    };\n\n    this.onComplete = () => {\n      if (this.privIsSynthesizing) {\n        this.privIsSynthesizing = false;\n        this.privIsSynthesisEnded = true;\n        this.privAudioOutputStream.close();\n        this.privInTurn = false;\n\n        if (this.privTurnAudioDestination !== undefined) {\n          this.privTurnAudioDestination.close();\n          this.privTurnAudioDestination = undefined;\n        }\n      }\n    };\n\n    this.privRequestId = createNoDashGuid();\n    this.privTurnDeferral = new Deferred(); // We're not in a turn, so resolve.\n\n    this.privTurnDeferral.resolve();\n  }\n\n  get requestId() {\n    return this.privRequestId;\n  }\n\n  get streamId() {\n    return this.privStreamId;\n  }\n\n  set streamId(value) {\n    this.privStreamId = value;\n  }\n\n  get audioOutputFormat() {\n    return this.privAudioOutputFormat;\n  }\n\n  set audioOutputFormat(format) {\n    this.privAudioOutputFormat = format;\n  }\n\n  get turnCompletionPromise() {\n    return this.privTurnDeferral.promise;\n  }\n\n  get isSynthesisEnded() {\n    return this.privIsSynthesisEnded;\n  }\n\n  get isSynthesizing() {\n    return this.privIsSynthesizing;\n  }\n\n  get currentTextOffset() {\n    return this.privTextOffset;\n  } // The number of bytes received for current turn\n\n\n  get bytesReceived() {\n    return this.privBytesReceived;\n  }\n\n  getAllReceivedAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudio) {\n        return Promise.resolve(this.privReceivedAudio);\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      yield this.readAllAudioFromStream();\n      return Promise.resolve(this.privReceivedAudio);\n    });\n  }\n\n  getAllReceivedAudioWithHeader() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privReceivedAudioWithHeader) {\n        return this.privReceivedAudioWithHeader;\n      }\n\n      if (!this.privIsSynthesisEnded) {\n        return null;\n      }\n\n      if (this.audioOutputFormat.hasHeader) {\n        const audio = yield this.getAllReceivedAudio();\n        this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\n        return this.privReceivedAudioWithHeader;\n      } else {\n        return this.getAllReceivedAudio();\n      }\n    });\n  }\n\n  startNewSynthesis(requestId, rawText, isSSML, audioDestination) {\n    this.privIsSynthesisEnded = false;\n    this.privIsSynthesizing = true;\n    this.privRequestId = requestId;\n    this.privRawText = rawText;\n    this.privIsSSML = isSSML;\n    this.privAudioOutputStream = new PullAudioOutputStreamImpl();\n    this.privAudioOutputStream.format = this.privAudioOutputFormat;\n    this.privReceivedAudio = null;\n    this.privReceivedAudioWithHeader = null;\n    this.privBytesReceived = 0;\n    this.privTextOffset = 0;\n    this.privNextSearchTextIndex = 0;\n    this.privPartialVisemeAnimation = \"\";\n\n    if (audioDestination !== undefined) {\n      this.privTurnAudioDestination = audioDestination;\n      this.privTurnAudioDestination.format = this.privAudioOutputFormat;\n    }\n\n    this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\n  }\n\n  onAudioChunkReceived(data) {\n    if (this.isSynthesizing) {\n      this.privAudioOutputStream.write(data);\n      this.privBytesReceived += data.byteLength;\n\n      if (this.privTurnAudioDestination !== undefined) {\n        this.privTurnAudioDestination.write(data);\n      }\n    }\n  }\n\n  onWordBoundaryEvent(text) {\n    this.updateTextOffset(text);\n  }\n\n  onVisemeMetadataReceived(metadata) {\n    if (metadata.Data.AnimationChunk !== undefined) {\n      this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\n    }\n  }\n\n  onStopSynthesizing() {\n    this.onComplete();\n  }\n  /**\r\n   * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n   * partial animation.\r\n   */\n\n\n  getAndClearVisemeAnimation() {\n    const animation = this.privPartialVisemeAnimation;\n    this.privPartialVisemeAnimation = \"\";\n    return animation;\n  }\n\n  updateTextOffset(text) {\n    if (this.privTextOffset >= 0) {\n      this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\n\n      if (this.privTextOffset >= 0) {\n        this.privNextSearchTextIndex = this.privTextOffset + text.length;\n      }\n\n      if (this.privIsSSML) {\n        if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\n          this.updateTextOffset(text);\n        }\n      }\n    }\n  }\n\n  readAllAudioFromStream() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privIsSynthesisEnded) {\n        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\n\n        try {\n          yield this.privAudioOutputStream.read(this.privReceivedAudio);\n        } catch (e) {\n          this.privReceivedAudio = new ArrayBuffer(0);\n        }\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["createNoDashGuid","Deferred","Events","PullAudioOutputStreamImpl","SynthesisAdapterBase","ConnectingToSynthesisServiceEvent","SynthesisStartedEvent","SynthesisTriggeredEvent","SynthesisTurn","constructor","authFetchEventId","connectionId","privAuthFetchEventId","onEvent","privRequestId","isError","error","onComplete","statusCode","reason","requestId","privBytesReceived","responseJson","response","JSON","parse","streamId","audio","privInTurn","privTurnDeferral","resolve","reject","promise","then","catch","privIsDisposed","event","instance","privIsSynthesizing","privIsSynthesisEnded","privAudioOutputStream","close","privTurnAudioDestination","undefined","privStreamId","value","audioOutputFormat","privAudioOutputFormat","format","turnCompletionPromise","isSynthesisEnded","isSynthesizing","currentTextOffset","privTextOffset","bytesReceived","getAllReceivedAudio","privReceivedAudio","Promise","readAllAudioFromStream","getAllReceivedAudioWithHeader","privReceivedAudioWithHeader","hasHeader","addHeader","startNewSynthesis","rawText","isSSML","audioDestination","privRawText","privIsSSML","privNextSearchTextIndex","privPartialVisemeAnimation","id","onAudioChunkReceived","data","write","byteLength","onWordBoundaryEvent","text","updateTextOffset","onVisemeMetadataReceived","metadata","Data","AnimationChunk","onStopSynthesizing","getAndClearVisemeAnimation","animation","indexOf","length","ArrayBuffer","read","e"],"sources":["C:\\Users\\ozgur\\Documents\\VSCodeProjects\\webapp_educator\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\SynthesisTurn.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport {\r\n    createNoDashGuid,\r\n    Deferred,\r\n    Events, IAudioDestination\r\n} from \"../common/Exports\";\r\nimport { AudioOutputFormatImpl } from \"../sdk/Audio/AudioOutputFormat\";\r\nimport { PullAudioOutputStreamImpl } from \"../sdk/Audio/AudioOutputStream\";\r\nimport { ISynthesisMetadata } from \"./ServiceMessages/SynthesisAudioMetadata\";\r\nimport { SynthesisAdapterBase } from \"./SynthesisAdapterBase\";\r\nimport {\r\n    ConnectingToSynthesisServiceEvent,\r\n    SpeechSynthesisEvent,\r\n    SynthesisStartedEvent,\r\n    SynthesisTriggeredEvent,\r\n} from \"./SynthesisEvents\";\r\n\r\nexport interface ISynthesisResponseContext {\r\n    serviceTag: string;\r\n}\r\n\r\nexport interface ISynthesisResponseAudio {\r\n    type: string;\r\n    streamId: string;\r\n}\r\n\r\nexport interface ISynthesisResponse {\r\n    context: ISynthesisResponseContext;\r\n    audio: ISynthesisResponseAudio;\r\n}\r\n\r\nexport class SynthesisTurn {\r\n\r\n    public get requestId(): string {\r\n        return this.privRequestId;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public set streamId(value: string) {\r\n        this.privStreamId = value;\r\n    }\r\n\r\n    public get audioOutputFormat(): AudioOutputFormatImpl {\r\n        return this.privAudioOutputFormat;\r\n    }\r\n\r\n    public set audioOutputFormat(format: AudioOutputFormatImpl) {\r\n        this.privAudioOutputFormat = format;\r\n    }\r\n\r\n    public get turnCompletionPromise(): Promise<void> {\r\n        return this.privTurnDeferral.promise;\r\n    }\r\n\r\n    public get isSynthesisEnded(): boolean {\r\n        return this.privIsSynthesisEnded;\r\n    }\r\n\r\n    public get isSynthesizing(): boolean {\r\n        return this.privIsSynthesizing;\r\n    }\r\n\r\n    public get currentTextOffset(): number {\r\n        return this.privTextOffset;\r\n    }\r\n\r\n    // The number of bytes received for current turn\r\n    public get bytesReceived(): number {\r\n        return this.privBytesReceived;\r\n    }\r\n\r\n    private privIsDisposed: boolean = false;\r\n    private privAuthFetchEventId: string;\r\n    private privIsSynthesizing: boolean = false;\r\n    private privIsSynthesisEnded: boolean = false;\r\n    private privBytesReceived: number = 0;\r\n    private privRequestId: string;\r\n    private privStreamId: string;\r\n    private privTurnDeferral: Deferred<void>;\r\n    private privInTurn: boolean = false;\r\n    private privAudioOutputFormat: AudioOutputFormatImpl;\r\n    private privAudioOutputStream: PullAudioOutputStreamImpl;\r\n    private privReceivedAudio: ArrayBuffer;\r\n    private privReceivedAudioWithHeader: ArrayBuffer;\r\n    private privTextOffset: number = 0;\r\n    private privNextSearchTextIndex: number = 0;\r\n    private privPartialVisemeAnimation: string;\r\n    private privRawText: string;\r\n    private privIsSSML: boolean;\r\n    private privTurnAudioDestination: IAudioDestination;\r\n\r\n    constructor() {\r\n        this.privRequestId = createNoDashGuid();\r\n        this.privTurnDeferral = new Deferred<void>();\r\n\r\n        // We're not in a turn, so resolve.\r\n        this.privTurnDeferral.resolve();\r\n    }\r\n\r\n    public async getAllReceivedAudio(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudio) {\r\n            return Promise.resolve(this.privReceivedAudio);\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        await this.readAllAudioFromStream();\r\n        return Promise.resolve(this.privReceivedAudio);\r\n    }\r\n\r\n    public async getAllReceivedAudioWithHeader(): Promise<ArrayBuffer> {\r\n        if (!!this.privReceivedAudioWithHeader) {\r\n            return this.privReceivedAudioWithHeader;\r\n        }\r\n        if (!this.privIsSynthesisEnded) {\r\n            return null;\r\n        }\r\n        if (this.audioOutputFormat.hasHeader) {\r\n            const audio: ArrayBuffer = await this.getAllReceivedAudio();\r\n            this.privReceivedAudioWithHeader = SynthesisAdapterBase.addHeader(audio, this.audioOutputFormat);\r\n            return this.privReceivedAudioWithHeader;\r\n        } else {\r\n            return this.getAllReceivedAudio();\r\n        }\r\n    }\r\n\r\n    public startNewSynthesis(requestId: string, rawText: string, isSSML: boolean, audioDestination?: IAudioDestination): void {\r\n        this.privIsSynthesisEnded = false;\r\n        this.privIsSynthesizing = true;\r\n        this.privRequestId = requestId;\r\n        this.privRawText = rawText;\r\n        this.privIsSSML = isSSML;\r\n        this.privAudioOutputStream = new PullAudioOutputStreamImpl();\r\n        this.privAudioOutputStream.format = this.privAudioOutputFormat;\r\n        this.privReceivedAudio = null;\r\n        this.privReceivedAudioWithHeader = null;\r\n        this.privBytesReceived = 0;\r\n        this.privTextOffset = 0;\r\n        this.privNextSearchTextIndex = 0;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        if (audioDestination !== undefined) {\r\n            this.privTurnAudioDestination = audioDestination;\r\n            this.privTurnAudioDestination.format = this.privAudioOutputFormat;\r\n        }\r\n        this.onEvent(new SynthesisTriggeredEvent(this.requestId, undefined, audioDestination === undefined ? undefined : audioDestination.id()));\r\n    }\r\n\r\n    public onPreConnectionStart = (authFetchEventId: string, connectionId: string): void => {\r\n        this.privAuthFetchEventId = authFetchEventId;\r\n        this.onEvent(new ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));\r\n    }\r\n\r\n    public onAuthCompleted = (isError: boolean, error?: string): void => {\r\n        if (isError) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onConnectionEstablishCompleted = (statusCode: number, reason?: string): void => {\r\n        if (statusCode === 200) {\r\n            this.onEvent(new SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId));\r\n            this.privBytesReceived = 0;\r\n            return;\r\n        } else if (statusCode === 403) {\r\n            this.onComplete();\r\n        }\r\n    }\r\n\r\n    public onServiceResponseMessage = (responseJson: string): void => {\r\n        const response: ISynthesisResponse = JSON.parse(responseJson);\r\n        this.streamId = response.audio.streamId;\r\n    }\r\n\r\n    public onServiceTurnEndResponse = (): void => {\r\n        this.privInTurn = false;\r\n        this.privTurnDeferral.resolve();\r\n        this.onComplete();\r\n    }\r\n\r\n    public onServiceTurnStartResponse = (): void => {\r\n        if (!!this.privTurnDeferral && !!this.privInTurn) {\r\n            // What? How are we starting a turn with another not done?\r\n            this.privTurnDeferral.reject(\"Another turn started before current completed.\");\r\n            // Avoid UnhandledPromiseRejection if privTurnDeferral is not being awaited\r\n            /* tslint:disable:no-empty */\r\n            this.privTurnDeferral.promise.then().catch(() => { });\r\n        }\r\n        this.privInTurn = true;\r\n        this.privTurnDeferral = new Deferred<void>();\r\n    }\r\n\r\n    public onAudioChunkReceived(data: ArrayBuffer): void {\r\n        if (this.isSynthesizing) {\r\n            this.privAudioOutputStream.write(data);\r\n            this.privBytesReceived += data.byteLength;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.write(data);\r\n            }\r\n        }\r\n    }\r\n\r\n    public onWordBoundaryEvent(text: string): void {\r\n        this.updateTextOffset(text);\r\n    }\r\n\r\n    public onVisemeMetadataReceived(metadata: ISynthesisMetadata): void {\r\n        if (metadata.Data.AnimationChunk !== undefined) {\r\n            this.privPartialVisemeAnimation += metadata.Data.AnimationChunk;\r\n        }\r\n    }\r\n\r\n    public dispose = (error?: string): void => {\r\n        if (!this.privIsDisposed) {\r\n            // we should have completed by now. If we did not its an unknown error.\r\n            this.privIsDisposed = true;\r\n        }\r\n    }\r\n\r\n    public onStopSynthesizing(): void {\r\n        this.onComplete();\r\n    }\r\n\r\n    /**\r\n     * Gets the viseme animation string (merged from animation chunk), and clears the internal\r\n     * partial animation.\r\n     */\r\n    public getAndClearVisemeAnimation(): string {\r\n        const animation: string = this.privPartialVisemeAnimation;\r\n        this.privPartialVisemeAnimation = \"\";\r\n        return animation;\r\n    }\r\n\r\n    protected onEvent = (event: SpeechSynthesisEvent): void => {\r\n        Events.instance.onEvent(event);\r\n    }\r\n\r\n    private updateTextOffset(text: string): void {\r\n        if (this.privTextOffset >= 0) {\r\n            this.privTextOffset = this.privRawText.indexOf(text, this.privNextSearchTextIndex);\r\n            if (this.privTextOffset >= 0) {\r\n                this.privNextSearchTextIndex = this.privTextOffset + text.length;\r\n            }\r\n            if (this.privIsSSML) {\r\n                if (this.privRawText.indexOf(\"<\", this.privTextOffset + 1) > this.privRawText.indexOf(\">\", this.privTextOffset + 1)) {\r\n                    this.updateTextOffset(text);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private onComplete = (): void => {\r\n        if (this.privIsSynthesizing) {\r\n            this.privIsSynthesizing = false;\r\n            this.privIsSynthesisEnded = true;\r\n            this.privAudioOutputStream.close();\r\n            this.privInTurn = false;\r\n            if (this.privTurnAudioDestination !== undefined) {\r\n                this.privTurnAudioDestination.close();\r\n                this.privTurnAudioDestination = undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    private async readAllAudioFromStream(): Promise<void> {\r\n        if (this.privIsSynthesisEnded) {\r\n            this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);\r\n            try {\r\n                await this.privAudioOutputStream.read(this.privReceivedAudio);\r\n            } catch (e) {\r\n                this.privReceivedAudio = new ArrayBuffer(0);\r\n            }\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}