{"ast":null,"code":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT license.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\nimport { ArgumentNullError, ConnectionState, createNoDashGuid, EventSource, MessageType, ServiceEvent, Timeout } from \"../common/Exports\";\nimport { CancellationErrorCode, CancellationReason, PropertyId, RecognitionEventArgs, SessionEventArgs } from \"../sdk/Exports\";\nimport { AgentConfig, DynamicGrammarBuilder, RequestSession, SpeechContext, SpeechDetected, type } from \"./Exports\";\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\nexport class ServiceRecognizerBase {\n  constructor(authentication, connectionFactory, audioSource, recognizerConfig, recognizer) {\n    this.privSetTimeout = setTimeout;\n    this.privIsLiveAudio = false;\n    this.recognizeOverride = undefined;\n    this.disconnectOverride = undefined;\n    this.receiveMessageOverride = undefined;\n\n    this.sendSpeechContext = connection => {\n      const speechContextJson = this.speechContext.toJSON();\n      this.privRequestSession.onSpeechContext();\n\n      if (speechContextJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.context\", this.privRequestSession.requestId, \"application/json\", speechContextJson));\n      }\n\n      return;\n    };\n\n    this.sendPrePayloadJSONOverride = undefined;\n    this.postConnectImplOverride = undefined;\n    this.configConnectionOverride = undefined;\n\n    this.sendSpeechServiceConfig = (connection, requestSession, SpeechServiceConfigJson) => {\n      // filter out anything that is not required for the service to work.\n      if (ServiceRecognizerBase.telemetryDataEnabled !== true) {\n        const withTelemetry = JSON.parse(SpeechServiceConfigJson);\n        const replacement = {\n          context: {\n            system: withTelemetry.context.system\n          }\n        };\n        SpeechServiceConfigJson = JSON.stringify(replacement);\n      }\n\n      if (this.privRecognizerConfig.parameters.getProperty(\"TranscriptionService_SingleChannel\", \"false\").toLowerCase() === \"true\") {\n        const json = JSON.parse(SpeechServiceConfigJson);\n        json.context.DisableReferenceChannel = \"True\";\n        json.context.MicSpec = \"1_0_0\";\n        SpeechServiceConfigJson = JSON.stringify(json);\n      }\n\n      if (SpeechServiceConfigJson) {\n        return connection.send(new SpeechConnectionMessage(MessageType.Text, \"speech.config\", requestSession.requestId, \"application/json\", SpeechServiceConfigJson));\n      }\n\n      return;\n    };\n\n    if (!authentication) {\n      throw new ArgumentNullError(\"authentication\");\n    }\n\n    if (!connectionFactory) {\n      throw new ArgumentNullError(\"connectionFactory\");\n    }\n\n    if (!audioSource) {\n      throw new ArgumentNullError(\"audioSource\");\n    }\n\n    if (!recognizerConfig) {\n      throw new ArgumentNullError(\"recognizerConfig\");\n    }\n\n    this.privMustReportEndOfStream = false;\n    this.privAuthentication = authentication;\n    this.privConnectionFactory = connectionFactory;\n    this.privAudioSource = audioSource;\n    this.privRecognizerConfig = recognizerConfig;\n    this.privIsDisposed = false;\n    this.privRecognizer = recognizer;\n    this.privRequestSession = new RequestSession(this.privAudioSource.id());\n    this.privConnectionEvents = new EventSource();\n    this.privServiceEvents = new EventSource();\n    this.privDynamicGrammar = new DynamicGrammarBuilder();\n    this.privSpeechContext = new SpeechContext(this.privDynamicGrammar);\n    this.privAgentConfig = new AgentConfig();\n\n    if (typeof Blob !== \"undefined\" && typeof Worker !== \"undefined\") {\n      this.privSetTimeout = Timeout.setTimeout;\n    }\n\n    this.connectionEvents.attach(connectionEvent => __awaiter(this, void 0, void 0, function* () {\n      if (connectionEvent.name === \"ConnectionClosedEvent\") {\n        const connectionClosedEvent = connectionEvent;\n\n        if (connectionClosedEvent.statusCode === 1003 || connectionClosedEvent.statusCode === 1007 || connectionClosedEvent.statusCode === 1002 || connectionClosedEvent.statusCode === 4000 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) {\n          yield this.cancelRecognitionLocal(CancellationReason.Error, connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure, connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\n        }\n      }\n    }));\n  }\n\n  get audioSource() {\n    return this.privAudioSource;\n  }\n\n  get speechContext() {\n    return this.privSpeechContext;\n  }\n\n  get dynamicGrammar() {\n    return this.privDynamicGrammar;\n  }\n\n  get agentConfig() {\n    return this.privAgentConfig;\n  }\n\n  set conversationTranslatorToken(token) {\n    this.privRecognizerConfig.parameters.setProperty(PropertyId.ConversationTranslator_Token, token);\n  }\n\n  set authentication(auth) {\n    this.privAuthentication = this.authentication;\n  }\n\n  isDisposed() {\n    return this.privIsDisposed;\n  }\n\n  dispose(reason) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.privIsDisposed = true;\n\n      if (this.privConnectionConfigurationPromise) {\n        try {\n          const connection = yield this.privConnectionConfigurationPromise;\n          yield connection.dispose(reason);\n        } catch (error) {\n          // The connection is in a bad state. But we're trying to kill it, so...\n          return;\n        }\n      }\n    });\n  }\n\n  get connectionEvents() {\n    return this.privConnectionEvents;\n  }\n\n  get serviceEvents() {\n    return this.privServiceEvents;\n  }\n\n  get recognitionMode() {\n    return this.privRecognizerConfig.recognitionMode;\n  }\n\n  recognize(recoMode, successCallback, errorCallBack) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.recognizeOverride !== undefined) {\n        return this.recognizeOverride(recoMode, successCallback, errorCallBack);\n      } // Clear the existing configuration promise to force a re-transmission of config and context.\n\n\n      this.privConnectionConfigurationPromise = null;\n      this.privRecognizerConfig.recognitionMode = recoMode;\n      this.privSuccessCallback = successCallback;\n      this.privErrorCallback = errorCallBack;\n      this.privRequestSession.startNewRecognition();\n      this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events); // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\n\n      const conPromise = this.connectImpl();\n      let audioNode;\n\n      try {\n        const audioStreamNode = yield this.audioSource.attach(this.privRequestSession.audioNodeId);\n        const format = yield this.audioSource.format;\n        const deviceInfo = yield this.audioSource.deviceInfo;\n        this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === type.Microphones;\n        audioNode = new ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);\n        yield this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\n        this.privRecognizerConfig.SpeechServiceConfig.Context.audio = {\n          source: deviceInfo\n        };\n      } catch (error) {\n        yield this.privRequestSession.onStopRecognizing();\n        throw error;\n      }\n\n      try {\n        yield conPromise;\n      } catch (error) {\n        yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\n        return;\n      }\n\n      const sessionStartEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n\n      if (!!this.privRecognizer.sessionStarted) {\n        this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\n      }\n\n      const messageRetrievalPromise = this.receiveMessage();\n      const audioSendPromise = this.sendAudio(audioNode);\n      audioSendPromise.catch(error => __awaiter(this, void 0, void 0, function* () {\n        yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\n      }));\n      return;\n    });\n  }\n\n  stopRecognizing() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privRequestSession.isRecognizing) {\n        try {\n          yield this.audioSource.turnOff();\n          yield this.sendFinalAudio();\n          yield this.privRequestSession.onStopRecognizing();\n          yield this.privRequestSession.turnCompletionPromise;\n        } finally {\n          yield this.privRequestSession.dispose();\n        }\n      }\n\n      return;\n    });\n  }\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.connectImpl();\n      return Promise.resolve();\n    });\n  }\n\n  connectAsync(cb, err) {\n    this.connectImpl().then(connection => {\n      try {\n        if (!!cb) {\n          cb();\n        }\n      } catch (e) {\n        if (!!err) {\n          err(e);\n        }\n      }\n    }, reason => {\n      try {\n        if (!!err) {\n          err(reason);\n        }\n        /* tslint:disable:no-empty */\n\n      } catch (error) {}\n    });\n  }\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.NoError, \"Disconnecting\");\n\n      if (this.disconnectOverride !== undefined) {\n        yield this.disconnectOverride();\n      }\n\n      try {\n        yield (yield this.privConnectionPromise).dispose();\n      } catch (error) {}\n\n      this.privConnectionPromise = null;\n    });\n  }\n\n  sendMessage(message) {}\n\n  sendNetworkMessage(path, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const type = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\n      const contentType = typeof payload === \"string\" ? \"application/json\" : \"\";\n      const connection = yield this.fetchConnection();\n      return connection.send(new SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));\n    });\n  }\n\n  set activityTemplate(messagePayload) {\n    this.privActivityTemplate = messagePayload;\n  }\n\n  get activityTemplate() {\n    return this.privActivityTemplate;\n  }\n\n  sendTelemetryData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const telemetryData = this.privRequestSession.getTelemetry();\n\n      if (ServiceRecognizerBase.telemetryDataEnabled !== true || this.privIsDisposed || null === telemetryData) {\n        return;\n      }\n\n      if (!!ServiceRecognizerBase.telemetryData) {\n        try {\n          ServiceRecognizerBase.telemetryData(telemetryData);\n          /* tslint:disable:no-empty */\n        } catch (_a) {}\n      }\n\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Text, \"telemetry\", this.privRequestSession.requestId, \"application/json\", telemetryData));\n    });\n  } // Cancels recognition.\n\n\n  cancelRecognitionLocal(cancellationReason, errorCode, error) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!!this.privRequestSession.isRecognizing) {\n        yield this.privRequestSession.onStopRecognizing();\n        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, cancellationReason, errorCode, error);\n      }\n    });\n  }\n\n  receiveMessage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        if (this.privIsDisposed) {\n          // We're done.\n          return;\n        }\n\n        let connection = yield this.fetchConnection();\n        const message = yield connection.read();\n\n        if (this.receiveMessageOverride !== undefined) {\n          return this.receiveMessageOverride();\n        } // indicates we are draining the queue and it came with no message;\n\n\n        if (!message) {\n          if (!this.privRequestSession.isRecognizing) {\n            return;\n          } else {\n            return this.receiveMessage();\n          }\n        }\n\n        this.privServiceHasSentMessage = true;\n        const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\n\n        if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {\n          switch (connectionMessage.path.toLowerCase()) {\n            case \"turn.start\":\n              this.privMustReportEndOfStream = true;\n              this.privRequestSession.onServiceTurnStartResponse();\n              break;\n\n            case \"speech.startdetected\":\n              const speechStartDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\n              const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\n\n              if (!!this.privRecognizer.speechStartDetected) {\n                this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\n              }\n\n              break;\n\n            case \"speech.enddetected\":\n              let json;\n\n              if (connectionMessage.textBody.length > 0) {\n                json = connectionMessage.textBody;\n              } else {\n                // If the request was empty, the JSON returned is empty.\n                json = \"{ Offset: 0 }\";\n              }\n\n              const speechStopDetected = SpeechDetected.fromJSON(json); // Only shrink the buffers for continuous recognition.\n              // For single shot, the speech.phrase message will come after the speech.end and it should own buffer shrink.\n\n              if (this.privRecognizerConfig.isContinuousRecognition) {\n                this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\n              }\n\n              const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\n\n              if (!!this.privRecognizer.speechEndDetected) {\n                this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\n              }\n\n              break;\n\n            case \"turn.end\":\n              yield this.sendTelemetryData();\n\n              if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {\n                this.privMustReportEndOfStream = false;\n                yield this.cancelRecognitionLocal(CancellationReason.EndOfStream, CancellationErrorCode.NoError, undefined);\n              }\n\n              const sessionStopEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\n              yield this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);\n\n              if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\n                if (!!this.privRecognizer.sessionStopped) {\n                  this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\n                }\n\n                return;\n              } else {\n                connection = yield this.fetchConnection();\n                yield this.sendPrePayloadJSON(connection);\n              }\n\n              break;\n\n            default:\n              if (!(yield this.processTypeSpecificMessages(connectionMessage))) {\n                // here are some messages that the derived class has not processed, dispatch them to connect class\n                if (!!this.privServiceEvents) {\n                  this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\n                }\n              }\n\n          }\n        }\n\n        return this.receiveMessage();\n      } catch (error) {\n        return null;\n      }\n    });\n  } // Encapsulated for derived service recognizers that need to send additional JSON\n\n\n  sendPrePayloadJSON(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.sendPrePayloadJSONOverride !== undefined) {\n        return this.sendPrePayloadJSONOverride(connection);\n      }\n\n      yield this.sendSpeechContext(connection);\n      yield this.sendWaveHeader(connection);\n      return;\n    });\n  }\n\n  sendWaveHeader(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const format = yield this.audioSource.format; // this.writeBufferToConsole(format.header);\n\n      return connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, \"audio/x-wav\", format.header));\n    });\n  } // Establishes a websocket connection to the end point.\n\n\n  connectImpl() {\n    if (this.privConnectionPromise) {\n      return this.privConnectionPromise.then(connection => {\n        if (connection.state() === ConnectionState.Disconnected) {\n          this.privConnectionId = null;\n          this.privConnectionPromise = null;\n          this.privServiceHasSentMessage = false;\n          return this.connectImpl();\n        }\n\n        return this.privConnectionPromise;\n      }, error => {\n        this.privConnectionId = null;\n        this.privConnectionPromise = null;\n        this.privServiceHasSentMessage = false;\n        return this.connectImpl();\n      });\n    }\n\n    this.privConnectionPromise = this.retryableConnect(); // Attach an empty handler to allow the promise to run in the background while\n    // other startup events happen. It'll eventually be awaited on.\n\n    this.privConnectionPromise.catch(() => {});\n\n    if (this.postConnectImplOverride !== undefined) {\n      return this.postConnectImplOverride(this.privConnectionPromise);\n    }\n\n    return this.privConnectionPromise;\n  }\n\n  fetchConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.privConnectionConfigurationPromise) {\n        return this.privConnectionConfigurationPromise.then(connection => {\n          if (connection.state() === ConnectionState.Disconnected) {\n            this.privConnectionId = null;\n            this.privConnectionConfigurationPromise = null;\n            this.privServiceHasSentMessage = false;\n            return this.fetchConnection();\n          }\n\n          return this.privConnectionConfigurationPromise;\n        }, error => {\n          this.privConnectionId = null;\n          this.privConnectionConfigurationPromise = null;\n          this.privServiceHasSentMessage = false;\n          return this.fetchConnection();\n        });\n      }\n\n      this.privConnectionConfigurationPromise = this.configureConnection();\n      return yield this.privConnectionConfigurationPromise;\n    });\n  }\n\n  sendAudio(audioStreamNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const audioFormat = yield this.audioSource.format; // The time we last sent data to the service.\n\n      let nextSendTime = Date.now(); // Max amount to send before we start to throttle\n\n      const fastLaneSizeMs = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\n      const maxSendUnthrottledBytes = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\n      const startRecogNumber = this.privRequestSession.recogNumber;\n\n      const readAndUploadCycle = () => __awaiter(this, void 0, void 0, function* () {\n        // If speech is done, stop sending audio.\n        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {\n          const connection = yield this.fetchConnection();\n          const audioStreamChunk = yield audioStreamNode.read(); // we have a new audio chunk to upload.\n\n          if (this.privRequestSession.isSpeechEnded) {\n            // If service already recognized audio end then don't send any more audio\n            return;\n          }\n\n          let payload;\n          let sendDelay;\n\n          if (!audioStreamChunk || audioStreamChunk.isEnd) {\n            payload = null;\n            sendDelay = 0;\n          } else {\n            payload = audioStreamChunk.buffer;\n            this.privRequestSession.onAudioSent(payload.byteLength);\n\n            if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {\n              sendDelay = 0;\n            } else {\n              sendDelay = Math.max(0, nextSendTime - Date.now());\n            }\n          }\n\n          if (0 !== sendDelay) {\n            yield this.delay(sendDelay);\n          }\n\n          if (payload !== null) {\n            nextSendTime = Date.now() + payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2);\n          } // Are we still alive?\n\n\n          if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === startRecogNumber) {\n            connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, payload)).catch(() => {\n              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {});\n            });\n\n            if (!(audioStreamChunk === null || audioStreamChunk === void 0 ? void 0 : audioStreamChunk.isEnd)) {\n              // this.writeBufferToConsole(payload);\n              // Regardless of success or failure, schedule the next upload.\n              // If the underlying connection was broken, the next cycle will\n              // get a new connection and re-transmit missing audio automatically.\n              return readAndUploadCycle();\n            } else {\n              // the audio stream has been closed, no need to schedule next\n              // read-upload cycle.\n              if (!this.privIsLiveAudio) {\n                this.privRequestSession.onSpeechEnded();\n              }\n            }\n          }\n        }\n      });\n\n      return readAndUploadCycle();\n    });\n  }\n\n  retryableConnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let isUnAuthorized = false;\n      this.privAuthFetchEventId = createNoDashGuid();\n      const sessionId = this.privRequestSession.sessionId;\n      this.privConnectionId = sessionId !== undefined ? sessionId : createNoDashGuid();\n      this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\n      let lastStatusCode = 0;\n      let lastReason = \"\";\n\n      while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {\n        // Get the auth information for the connection. This is a bit of overkill for the current API surface, but leaving the plumbing in place to be able to raise a developer-customer\n        // facing event when a connection fails to let them try and provide new auth information.\n        const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\n        const auth = yield authPromise;\n        yield this.privRequestSession.onAuthCompleted(false); // Create the connection\n\n        const connection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId); // Attach the telemetry handlers.\n\n        this.privRequestSession.listenForServiceTelemetry(connection.events); // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\n        // it'll stop sending events.\n\n        connection.events.attach(event => {\n          this.connectionEvents.onEvent(event);\n        });\n        const response = yield connection.open(); // 200 == everything is fine.\n\n        if (response.statusCode === 200) {\n          yield this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);\n          return Promise.resolve(connection);\n        } else if (response.statusCode === 1006) {\n          isUnAuthorized = true;\n        }\n\n        lastStatusCode = response.statusCode;\n        lastReason = response.reason;\n        this.privRequestSession.onRetryConnection();\n      }\n\n      yield this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);\n      return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);\n    });\n  }\n\n  delay(delayMs) {\n    return new Promise((resolve, reject) => {\n      this.privSetTimeout(resolve, delayMs);\n    });\n  }\n\n  writeBufferToConsole(buffer) {\n    let out = \"Buffer Size: \";\n\n    if (null === buffer) {\n      out += \"null\";\n    } else {\n      const readView = new Uint8Array(buffer);\n      out += buffer.byteLength + \"\\r\\n\";\n\n      for (let i = 0; i < buffer.byteLength; i++) {\n        out += readView[i].toString(16).padStart(2, \"0\") + \" \";\n      }\n    } // tslint:disable-next-line:no-console\n\n\n    console.info(out);\n  }\n\n  sendFinalAudio() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.fetchConnection();\n      yield connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, null));\n      return;\n    });\n  } // Takes an established websocket connection to the endpoint and sends speech configuration information.\n\n\n  configureConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.connectImpl();\n\n      if (this.configConnectionOverride !== undefined) {\n        return this.configConnectionOverride(connection);\n      }\n\n      yield this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\n      yield this.sendPrePayloadJSON(connection);\n      return connection;\n    });\n  }\n\n}\nServiceRecognizerBase.telemetryDataEnabled = true;","map":{"version":3,"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,SAASA,mBAAT,QAAoC,2BAApC;AAEA,SACIC,iBADJ,EAIIC,eAJJ,EAKIC,gBALJ,EAMIC,WANJ,EAYIC,WAZJ,EAaIC,YAbJ,EAcIC,OAdJ,QAeO,mBAfP;AAiBA,SACIC,qBADJ,EAEIC,kBAFJ,EAGIC,UAHJ,EAIIC,oBAJJ,EAMIC,gBANJ,QAQO,gBARP;AAUA,SACIC,WADJ,EAEIC,qBAFJ,EAKIC,cALJ,EAMIC,aANJ,EAOIC,cAPJ,EAQIC,IARJ,QASO,WATP;AAgBA,SAASC,uBAAT,QAAwC,oCAAxC;AAEA,OAAM,MAAgBC,qBAAhB,CAAqC;AA+BvCC,cACIC,cADJ,EAEIC,iBAFJ,EAGIC,WAHJ,EAIIC,gBAJJ,EAKIC,UALJ,EAK0B;AAhBlB,0BAA4DC,UAA5D;AAEA,2BAA2B,KAA3B;AAuHE,6BAA2HC,SAA3H;AAwGA,8BAA0CA,SAA1C;AA6FA,kCAA8CA,SAA9C;;AAiGA,6BAAqBC,UAAD,IAA2C;AACrE,YAAMC,iBAAiB,GAAG,KAAKC,aAAL,CAAmBC,MAAnB,EAA1B;AACA,WAAKC,kBAAL,CAAwBC,eAAxB;;AAEA,UAAIJ,iBAAJ,EAAuB;AACnB,eAAOD,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CACnBd,WAAW,CAAC+B,IADO,EAEnB,gBAFmB,EAGnB,KAAKH,kBAAL,CAAwBI,SAHL,EAInB,kBAJmB,EAKnBP,iBALmB,CAAhB,CAAP;AAMH;;AACD;AACH,KAbS;;AAeA,sCAAyEF,SAAzE;AAyBA,mCAAsFA,SAAtF;AAkCA,oCAA8EA,SAA9E;;AAEA,mCAA0B,CAACC,UAAD,EAA0BS,cAA1B,EAA0DC,uBAA1D,KAA4G;AAC5I;AACA,UAAInB,qBAAqB,CAACoB,oBAAtB,KAA+C,IAAnD,EAAyD;AACrD,cAAMC,aAAa,GAAGC,IAAI,CAACC,KAAL,CAAWJ,uBAAX,CAAtB;AAEA,cAAMK,WAAW,GAAQ;AACrBC,iBAAO,EAAE;AACLC,kBAAM,EAAEL,aAAa,CAACI,OAAd,CAAsBC;AADzB;AADY,SAAzB;AAMAP,+BAAuB,GAAGG,IAAI,CAACK,SAAL,CAAeH,WAAf,CAA1B;AACH;;AAED,UAAI,KAAKI,oBAAL,CAA0BC,UAA1B,CAAqCC,WAArC,CAAiD,oCAAjD,EAAuF,OAAvF,EAAgGC,WAAhG,OAAkH,MAAtH,EAA8H;AAC1H,cAAMC,IAAI,GAAqBV,IAAI,CAACC,KAAL,CAAWJ,uBAAX,CAA/B;AACAa,YAAI,CAACP,OAAL,CAAaQ,uBAAb,GAAuC,MAAvC;AACAD,YAAI,CAACP,OAAL,CAAaS,OAAb,GAAuB,OAAvB;AACAf,+BAAuB,GAAGG,IAAI,CAACK,SAAL,CAAeK,IAAf,CAA1B;AACH;;AAED,UAAIb,uBAAJ,EAA6B;AACzB,eAAOV,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CACnBd,WAAW,CAAC+B,IADO,EAEnB,eAFmB,EAGnBE,cAAc,CAACD,SAHI,EAInB,kBAJmB,EAKnBE,uBALmB,CAAhB,CAAP;AAMH;;AAED;AACH,KA/BS;;AAzdN,QAAI,CAACjB,cAAL,EAAqB;AACjB,YAAM,IAAIrB,iBAAJ,CAAsB,gBAAtB,CAAN;AACH;;AAED,QAAI,CAACsB,iBAAL,EAAwB;AACpB,YAAM,IAAItB,iBAAJ,CAAsB,mBAAtB,CAAN;AACH;;AAED,QAAI,CAACuB,WAAL,EAAkB;AACd,YAAM,IAAIvB,iBAAJ,CAAsB,aAAtB,CAAN;AACH;;AAED,QAAI,CAACwB,gBAAL,EAAuB;AACnB,YAAM,IAAIxB,iBAAJ,CAAsB,kBAAtB,CAAN;AACH;;AAED,SAAKsD,yBAAL,GAAiC,KAAjC;AACA,SAAKC,kBAAL,GAA0BlC,cAA1B;AACA,SAAKmC,qBAAL,GAA6BlC,iBAA7B;AACA,SAAKmC,eAAL,GAAuBlC,WAAvB;AACA,SAAKwB,oBAAL,GAA4BvB,gBAA5B;AACA,SAAKkC,cAAL,GAAsB,KAAtB;AACA,SAAKC,cAAL,GAAsBlC,UAAtB;AACA,SAAKO,kBAAL,GAA0B,IAAIlB,cAAJ,CAAmB,KAAK2C,eAAL,CAAqBG,EAArB,EAAnB,CAA1B;AACA,SAAKC,oBAAL,GAA4B,IAAI1D,WAAJ,EAA5B;AACA,SAAK2D,iBAAL,GAAyB,IAAI3D,WAAJ,EAAzB;AACA,SAAK4D,kBAAL,GAA0B,IAAIlD,qBAAJ,EAA1B;AACA,SAAKmD,iBAAL,GAAyB,IAAIjD,aAAJ,CAAkB,KAAKgD,kBAAvB,CAAzB;AACA,SAAKE,eAAL,GAAuB,IAAIrD,WAAJ,EAAvB;;AACA,QAAI,OAAQsD,IAAR,KAAkB,WAAlB,IAAiC,OAAQC,MAAR,KAAoB,WAAzD,EAAsE;AAClE,WAAKC,cAAL,GAAsB9D,OAAO,CAACoB,UAA9B;AACH;;AAED,SAAK2C,gBAAL,CAAsBC,MAAtB,CAAoCC,eAAP,IAA0DC;AACnF,UAAID,eAAe,CAACE,IAAhB,KAAyB,uBAA7B,EAAsD;AAClD,cAAMC,qBAAqB,GAAGH,eAA9B;;AACA,YAAIG,qBAAqB,CAACC,UAAtB,KAAqC,IAArC,IACAD,qBAAqB,CAACC,UAAtB,KAAqC,IADrC,IAEAD,qBAAqB,CAACC,UAAtB,KAAqC,IAFrC,IAGAD,qBAAqB,CAACC,UAAtB,KAAqC,IAHrC,IAIA,KAAK3C,kBAAL,CAAwB4C,qBAAxB,GAAgD,KAAK7B,oBAAL,CAA0B8B,aAJ9E,EAKE;AACE,gBAAM,KAAKC,sBAAL,CAA4BtE,kBAAkB,CAACuE,KAA/C,EACFL,qBAAqB,CAACC,UAAtB,KAAqC,IAArC,GAA4CpE,qBAAqB,CAACyE,oBAAlE,GAAyFzE,qBAAqB,CAAC0E,iBAD7G,EAEFP,qBAAqB,CAACQ,MAAtB,GAA+B,yBAA/B,GAA2DR,qBAAqB,CAACC,UAF/E,CAAN;AAGH;AACJ;AACJ,KAdsF,CAAvF;AAeH;;AAEqB,MAAXpD,WAAW;AAClB,WAAO,KAAKkC,eAAZ;AACH;;AAEuB,MAAb3B,aAAa;AACpB,WAAO,KAAKkC,iBAAZ;AACH;;AAEwB,MAAdmB,cAAc;AACrB,WAAO,KAAKpB,kBAAZ;AACH;;AAEqB,MAAXqB,WAAW;AAClB,WAAO,KAAKnB,eAAZ;AACH;;AAEqC,MAA3BoB,2BAA2B,CAACC,KAAD,EAAc;AAChD,SAAKvC,oBAAL,CAA0BC,UAA1B,CAAqCuC,WAArC,CAAiD9E,UAAU,CAAC+E,4BAA5D,EAA0FF,KAA1F;AACH;;AAEwB,MAAdjE,cAAc,CAACoE,IAAD,EAAsB;AAC3C,SAAKlC,kBAAL,GAA0B,KAAKlC,cAA/B;AACH;;AAEMqE,YAAU;AACb,WAAO,KAAKhC,cAAZ;AACH;;AAEYiC,SAAO,CAACT,MAAD,EAAgB;;AAChC,WAAKxB,cAAL,GAAsB,IAAtB;;AACA,UAAI,KAAKkC,kCAAT,EAA6C;AACzC,YAAI;AACA,gBAAMhE,UAAU,GAAgB,MAAM,KAAKgE,kCAA3C;AACA,gBAAMhE,UAAU,CAAC+D,OAAX,CAAmBT,MAAnB,CAAN;AACH,SAHD,CAGE,OAAOW,KAAP,EAAc;AACZ;AACA;AACH;AACJ;AACJ;AAAA;;AAE0B,MAAhBxB,gBAAgB;AACvB,WAAO,KAAKR,oBAAZ;AACH;;AAEuB,MAAbiC,aAAa;AACpB,WAAO,KAAKhC,iBAAZ;AACH;;AAEyB,MAAfiC,eAAe;AACtB,WAAO,KAAKhD,oBAAL,CAA0BgD,eAAjC;AACH;;AAIYC,WAAS,CAClBC,QADkB,EAElBC,eAFkB,EAGlBC,aAHkB,EAGgB;;AAGlC,UAAI,KAAKC,iBAAL,KAA2BzE,SAA/B,EAA0C;AACtC,eAAO,KAAKyE,iBAAL,CAAuBH,QAAvB,EAAiCC,eAAjC,EAAkDC,aAAlD,CAAP;AACH,QACD;;;AACA,WAAKP,kCAAL,GAA0C,IAA1C;AACA,WAAK7C,oBAAL,CAA0BgD,eAA1B,GAA4CE,QAA5C;AAEA,WAAKI,mBAAL,GAA2BH,eAA3B;AACA,WAAKI,iBAAL,GAAyBH,aAAzB;AAEA,WAAKnE,kBAAL,CAAwBuE,mBAAxB;AACA,WAAKvE,kBAAL,CAAwBwE,yBAAxB,CAAkD,KAAK/C,eAAL,CAAqBgD,MAAvE,GAEA;;AACA,YAAMC,UAAU,GAAyB,KAAKC,WAAL,EAAzC;AACA,UAAIC,SAAJ;;AAEA,UAAI;AACA,cAAMC,eAAe,GAAqB,MAAM,KAAKtF,WAAL,CAAiB+C,MAAjB,CAAwB,KAAKtC,kBAAL,CAAwB8E,WAAhD,CAAhD;AACA,cAAMC,MAAM,GAA0B,MAAM,KAAKxF,WAAL,CAAiBwF,MAA7D;AACA,cAAMC,UAAU,GAA6B,MAAM,KAAKzF,WAAL,CAAiByF,UAApE;AACA,aAAKC,eAAL,GAAuBD,UAAU,CAAC/F,IAAX,IAAmB+F,UAAU,CAAC/F,IAAX,KAAoBA,IAAI,CAACiG,WAAnE;AAEAN,iBAAS,GAAG,IAAI7G,mBAAJ,CAAwB8G,eAAxB,EAAyCE,MAAM,CAACI,cAAhD,CAAZ;AACA,cAAM,KAAKnF,kBAAL,CAAwBoF,4BAAxB,CAAqDR,SAArD,EAAgE,KAAhE,CAAN;AACA,aAAK7D,oBAAL,CAA0BsE,mBAA1B,CAA8CC,OAA9C,CAAsDC,KAAtD,GAA8D;AAAEC,gBAAM,EAAER;AAAV,SAA9D;AAEH,OAVD,CAUE,OAAOnB,KAAP,EAAc;AACZ,cAAM,KAAK7D,kBAAL,CAAwByF,iBAAxB,EAAN;AACA,cAAM5B,KAAN;AACH;;AAED,UAAI;AACA,cAAMa,UAAN;AACH,OAFD,CAEE,OAAOb,KAAP,EAAc;AACZ,cAAM,KAAKf,sBAAL,CAA4BtE,kBAAkB,CAACuE,KAA/C,EAAsDxE,qBAAqB,CAAC0E,iBAA5E,EAA+FY,KAA/F,CAAN;AACA;AACH;;AAED,YAAM6B,qBAAqB,GAAqB,IAAI/G,gBAAJ,CAAqB,KAAKqB,kBAAL,CAAwB2F,SAA7C,CAAhD;;AAEA,UAAI,CAAC,CAAC,KAAKhE,cAAL,CAAoBiE,cAA1B,EAA0C;AACtC,aAAKjE,cAAL,CAAoBiE,cAApB,CAAmC,KAAKjE,cAAxC,EAAwD+D,qBAAxD;AACH;;AAED,YAAMG,uBAAuB,GAAG,KAAKC,cAAL,EAAhC;AACA,YAAMC,gBAAgB,GAAG,KAAKC,SAAL,CAAepB,SAAf,CAAzB;AAEAmB,sBAAgB,CAACE,KAAjB,CAA8BpC,KAAP,IAAwBrB;AAC3C,cAAM,KAAKM,sBAAL,CAA4BtE,kBAAkB,CAACuE,KAA/C,EAAsDxE,qBAAqB,CAAC2H,YAA5E,EAA0FrC,KAA1F,CAAN;AACH,OAF8C,CAA/C;AAIA;AACH;AAAA;;AAEYsC,iBAAe;;AACxB,UAAI,KAAKnG,kBAAL,CAAwBoG,aAA5B,EAA2C;AACvC,YAAI;AACA,gBAAM,KAAK7G,WAAL,CAAiB8G,OAAjB,EAAN;AACA,gBAAM,KAAKC,cAAL,EAAN;AACA,gBAAM,KAAKtG,kBAAL,CAAwByF,iBAAxB,EAAN;AACA,gBAAM,KAAKzF,kBAAL,CAAwBuG,qBAA9B;AACH,SALD,SAKU;AACN,gBAAM,KAAKvG,kBAAL,CAAwB2D,OAAxB,EAAN;AACH;AACJ;;AACD;AACH;AAAA;;AAEY6C,SAAO;;AAChB,YAAM,KAAK7B,WAAL,EAAN;AACA,aAAO8B,OAAO,CAACC,OAAR,EAAP;AACH;AAAA;;AAEMC,cAAY,CAACC,EAAD,EAAgBC,GAAhB,EAA8B;AAC7C,SAAKlC,WAAL,GAAmBmC,IAAnB,CAAyBlH,UAAD,IAAkC;AACtD,UAAI;AACA,YAAI,CAAC,CAACgH,EAAN,EAAU;AACNA,YAAE;AACL;AACJ,OAJD,CAIE,OAAOG,CAAP,EAAU;AACR,YAAI,CAAC,CAACF,GAAN,EAAW;AACPA,aAAG,CAACE,CAAD,CAAH;AACH;AACJ;AACJ,KAVD,EAUI7D,MAAD,IAAsB;AACrB,UAAI;AACA,YAAI,CAAC,CAAC2D,GAAN,EAAW;AACPA,aAAG,CAAC3D,MAAD,CAAH;AACH;AACD;;AACH,OALD,CAKE,OAAOW,KAAP,EAAc,CACf;AACJ,KAlBD;AAmBH;;AAIYmD,YAAU;;AACnB,YAAM,KAAKlE,sBAAL,CAA4BtE,kBAAkB,CAACuE,KAA/C,EACFxE,qBAAqB,CAAC0I,OADpB,EAEF,eAFE,CAAN;;AAIA,UAAI,KAAKC,kBAAL,KAA4BvH,SAAhC,EAA2C;AACvC,cAAM,KAAKuH,kBAAL,EAAN;AACH;;AAED,UAAI;AACA,cAAM,CAAC,MAAM,KAAKC,qBAAZ,EAAmCxD,OAAnC,EAAN;AACH,OAFD,CAEE,OAAOE,KAAP,EAAc,CAEf;;AAED,WAAKsD,qBAAL,GAA6B,IAA7B;AACH;AAAA;;AAOMC,aAAW,CAACC,OAAD,EAAgB,CAAW;;AAEhCC,oBAAkB,CAACC,IAAD,EAAeC,OAAf,EAA4C;;AACvE,YAAMvI,IAAI,GAAgB,OAAOuI,OAAP,KAAmB,QAAnB,GAA8BpJ,WAAW,CAAC+B,IAA1C,GAAiD/B,WAAW,CAACqJ,MAAvF;AACA,YAAMC,WAAW,GAAW,OAAOF,OAAP,KAAmB,QAAnB,GAA8B,kBAA9B,GAAmD,EAA/E;AAEA,YAAM5H,UAAU,GAAgB,MAAM,KAAK+H,eAAL,EAAtC;AACA,aAAO/H,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CAA4BD,IAA5B,EAAkCsI,IAAlC,EAAwC,KAAKvH,kBAAL,CAAwBI,SAAhE,EAA2EsH,WAA3E,EAAwFF,OAAxF,CAAhB,CAAP;AACH;AAAA;;AAE0B,MAAhBI,gBAAgB,CAACC,cAAD,EAAuB;AAAI,SAAKC,oBAAL,GAA4BD,cAA5B;AAA6C;;AACxE,MAAhBD,gBAAgB;AAAa,WAAO,KAAKE,oBAAZ;AAAmC;;AAO3DC,mBAAiB;;AAC7B,YAAMC,aAAa,GAAG,KAAKhI,kBAAL,CAAwBiI,YAAxB,EAAtB;;AACA,UAAI9I,qBAAqB,CAACoB,oBAAtB,KAA+C,IAA/C,IACA,KAAKmB,cADL,IAEA,SAASsG,aAFb,EAE4B;AACxB;AACH;;AAED,UAAI,CAAC,CAAC7I,qBAAqB,CAAC6I,aAA5B,EAA2C;AACvC,YAAI;AACA7I,+BAAqB,CAAC6I,aAAtB,CAAoCA,aAApC;AACA;AACH,SAHD,CAGE,WAAM,CAAG;AACd;;AAED,YAAMpI,UAAU,GAAgB,MAAM,KAAK+H,eAAL,EAAtC;AACA,YAAM/H,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CAClBd,WAAW,CAAC+B,IADM,EAElB,WAFkB,EAGlB,KAAKH,kBAAL,CAAwBI,SAHN,EAIlB,kBAJkB,EAKlB4H,aALkB,CAAhB,CAAN;AAMH;AAAA,GAtTsC,CAgUvC;;;AACgBlF,wBAAsB,CAClCoF,kBADkC,EAElCC,SAFkC,EAGlCtE,KAHkC,EAGrB;;AAEb,UAAI,CAAC,CAAC,KAAK7D,kBAAL,CAAwBoG,aAA9B,EAA6C;AACzC,cAAM,KAAKpG,kBAAL,CAAwByF,iBAAxB,EAAN;AAEA,aAAK2C,iBAAL,CACI,KAAKpI,kBAAL,CAAwB2F,SAD5B,EAEI,KAAK3F,kBAAL,CAAwBI,SAF5B,EAGI8H,kBAHJ,EAIIC,SAJJ,EAKItE,KALJ;AAMH;AACJ;AAAA;;AAIeiC,gBAAc;;AAC1B,UAAI;AACA,YAAI,KAAKpE,cAAT,EAAyB;AACrB;AACA;AACH;;AAED,YAAI9B,UAAU,GAAG,MAAM,KAAK+H,eAAL,EAAvB;AACA,cAAMN,OAAO,GAAG,MAAMzH,UAAU,CAACyI,IAAX,EAAtB;;AAEA,YAAI,KAAKC,sBAAL,KAAgC3I,SAApC,EAA+C;AAC3C,iBAAO,KAAK2I,sBAAL,EAAP;AACH,SAXD,CAaA;;;AACA,YAAI,CAACjB,OAAL,EAAc;AACV,cAAI,CAAC,KAAKrH,kBAAL,CAAwBoG,aAA7B,EAA4C;AACxC;AACH,WAFD,MAEO;AACH,mBAAO,KAAKN,cAAL,EAAP;AACH;AACJ;;AAED,aAAKyC,yBAAL,GAAiC,IAAjC;AACA,cAAMC,iBAAiB,GAAGtJ,uBAAuB,CAACuJ,qBAAxB,CAA8CpB,OAA9C,CAA1B;;AAEA,YAAImB,iBAAiB,CAACpI,SAAlB,CAA4Bc,WAA5B,OAA8C,KAAKlB,kBAAL,CAAwBI,SAAxB,CAAkCc,WAAlC,EAAlD,EAAmG;AAC/F,kBAAQsH,iBAAiB,CAACjB,IAAlB,CAAuBrG,WAAvB,EAAR;AACI,iBAAK,YAAL;AACI,mBAAKI,yBAAL,GAAiC,IAAjC;AACA,mBAAKtB,kBAAL,CAAwB0I,0BAAxB;AACA;;AAEJ,iBAAK,sBAAL;AACI,oBAAMC,mBAAmB,GAAmB3J,cAAc,CAAC4J,QAAf,CAAwBJ,iBAAiB,CAACK,QAA1C,CAA5C;AACA,oBAAMC,oBAAoB,GAAG,IAAIpK,oBAAJ,CAAyBiK,mBAAmB,CAACI,MAA7C,EAAqD,KAAK/I,kBAAL,CAAwB2F,SAA7E,CAA7B;;AACA,kBAAI,CAAC,CAAC,KAAKhE,cAAL,CAAoBgH,mBAA1B,EAA+C;AAC3C,qBAAKhH,cAAL,CAAoBgH,mBAApB,CAAwC,KAAKhH,cAA7C,EAA6DmH,oBAA7D;AACH;;AACD;;AAEJ,iBAAK,oBAAL;AACI,kBAAI3H,IAAJ;;AACA,kBAAIqH,iBAAiB,CAACK,QAAlB,CAA2BG,MAA3B,GAAoC,CAAxC,EAA2C;AACvC7H,oBAAI,GAAGqH,iBAAiB,CAACK,QAAzB;AACH,eAFD,MAEO;AACH;AACA1H,oBAAI,GAAG,eAAP;AACH;;AACD,oBAAM8H,kBAAkB,GAAmBjK,cAAc,CAAC4J,QAAf,CAAwBzH,IAAxB,CAA3C,CARJ,CASI;AACA;;AACA,kBAAI,KAAKJ,oBAAL,CAA0BmI,uBAA9B,EAAuD;AACnD,qBAAKlJ,kBAAL,CAAwBmJ,mBAAxB,CAA4CF,kBAAkB,CAACF,MAAnB,GAA4B,KAAK/I,kBAAL,CAAwBoJ,sBAAhG;AACH;;AACD,oBAAMC,mBAAmB,GAAG,IAAI3K,oBAAJ,CAAyBuK,kBAAkB,CAACF,MAAnB,GAA4B,KAAK/I,kBAAL,CAAwBoJ,sBAA7E,EAAqG,KAAKpJ,kBAAL,CAAwB2F,SAA7H,CAA5B;;AACA,kBAAI,CAAC,CAAC,KAAKhE,cAAL,CAAoB2H,iBAA1B,EAA6C;AACzC,qBAAK3H,cAAL,CAAoB2H,iBAApB,CAAsC,KAAK3H,cAA3C,EAA2D0H,mBAA3D;AACH;;AACD;;AAEJ,iBAAK,UAAL;AACI,oBAAM,KAAKtB,iBAAL,EAAN;;AACA,kBAAI,KAAK/H,kBAAL,CAAwBuJ,aAAxB,IAAyC,KAAKjI,yBAAlD,EAA6E;AACzE,qBAAKA,yBAAL,GAAiC,KAAjC;AACA,sBAAM,KAAKwB,sBAAL,CAA4BtE,kBAAkB,CAACgL,WAA/C,EAA4DjL,qBAAqB,CAAC0I,OAAlF,EAA2FtH,SAA3F,CAAN;AACH;;AACD,oBAAM8J,oBAAoB,GAAqB,IAAI9K,gBAAJ,CAAqB,KAAKqB,kBAAL,CAAwB2F,SAA7C,CAA/C;AACA,oBAAM,KAAK3F,kBAAL,CAAwB0J,wBAAxB,CAAiD,KAAK3I,oBAAL,CAA0BmI,uBAA3E,CAAN;;AACA,kBAAI,CAAC,KAAKnI,oBAAL,CAA0BmI,uBAA3B,IAAsD,KAAKlJ,kBAAL,CAAwBuJ,aAA9E,IAA+F,CAAC,KAAKvJ,kBAAL,CAAwBoG,aAA5H,EAA2I;AACvI,oBAAI,CAAC,CAAC,KAAKzE,cAAL,CAAoBgI,cAA1B,EAA0C;AACtC,uBAAKhI,cAAL,CAAoBgI,cAApB,CAAmC,KAAKhI,cAAxC,EAAwD8H,oBAAxD;AACH;;AACD;AACH,eALD,MAKO;AACH7J,0BAAU,GAAG,MAAM,KAAK+H,eAAL,EAAnB;AACA,sBAAM,KAAKiC,kBAAL,CAAwBhK,UAAxB,CAAN;AACH;;AACD;;AAEJ;AACI,kBAAI,EAAC,MAAM,KAAKiK,2BAAL,CAAiCrB,iBAAjC,CAAP,CAAJ,EAAgE;AAC5D;AACA,oBAAI,CAAC,CAAC,KAAK1G,iBAAX,EAA8B;AAC1B,uBAAKgC,aAAL,CAAmBgG,OAAnB,CAA2B,IAAIzL,YAAJ,CAAiBmK,iBAAiB,CAACjB,IAAlB,CAAuBrG,WAAvB,EAAjB,EAAuDsH,iBAAiB,CAACK,QAAzE,CAA3B;AACH;AACJ;;AA3DT;AA6DH;;AACD,eAAO,KAAK/C,cAAL,EAAP;AACH,OAzFD,CAyFE,OAAOjC,KAAP,EAAc;AACZ,eAAO,IAAP;AACH;AACJ;AAAA,GAjbsC,CAocvC;;;AACgB+F,oBAAkB,CAAChK,UAAD,EAAwB;;AACtD,UAAI,KAAKmK,0BAAL,KAAoCpK,SAAxC,EAAmD;AAC/C,eAAO,KAAKoK,0BAAL,CAAgCnK,UAAhC,CAAP;AACH;;AAED,YAAM,KAAKoK,iBAAL,CAAuBpK,UAAvB,CAAN;AACA,YAAM,KAAKqK,cAAL,CAAoBrK,UAApB,CAAN;AACA;AACH;AAAA;;AAEeqK,gBAAc,CAACrK,UAAD,EAAwB;;AAClD,YAAMmF,MAAM,GAA0B,MAAM,KAAKxF,WAAL,CAAiBwF,MAA7D,EACA;;AACA,aAAOnF,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CACnBd,WAAW,CAACqJ,MADO,EAEnB,OAFmB,EAGnB,KAAKzH,kBAAL,CAAwBI,SAHL,EAInB,aAJmB,EAKnB2E,MAAM,CAACmF,MALY,CAAhB,CAAP;AAOH;AAAA,GAzdsC,CA6dvC;;;AACUvF,aAAW;AACjB,QAAI,KAAKwC,qBAAT,EAAgC;AAC5B,aAAO,KAAKA,qBAAL,CAA2BL,IAA3B,CAAiClH,UAAD,IAAkD;AACrF,YAAIA,UAAU,CAACuK,KAAX,OAAuBlM,eAAe,CAACmM,YAA3C,EAAyD;AACrD,eAAKC,gBAAL,GAAwB,IAAxB;AACA,eAAKlD,qBAAL,GAA6B,IAA7B;AACA,eAAKoB,yBAAL,GAAiC,KAAjC;AACA,iBAAO,KAAK5D,WAAL,EAAP;AACH;;AACD,eAAO,KAAKwC,qBAAZ;AACH,OARM,EAQHtD,KAAD,IAAwC;AACvC,aAAKwG,gBAAL,GAAwB,IAAxB;AACA,aAAKlD,qBAAL,GAA6B,IAA7B;AACA,aAAKoB,yBAAL,GAAiC,KAAjC;AACA,eAAO,KAAK5D,WAAL,EAAP;AACH,OAbM,CAAP;AAcH;;AAED,SAAKwC,qBAAL,GAA6B,KAAKmD,gBAAL,EAA7B,CAlBiB,CAoBjB;AACA;;AACA,SAAKnD,qBAAL,CAA2BlB,KAA3B,CAAiC,MAAK,CAAI,CAA1C;;AAEA,QAAI,KAAKsE,uBAAL,KAAiC5K,SAArC,EAAgD;AAC5C,aAAO,KAAK4K,uBAAL,CAA6B,KAAKpD,qBAAlC,CAAP;AACH;;AAED,WAAO,KAAKA,qBAAZ;AACH;;AAqCeQ,iBAAe;;AAC3B,UAAI,KAAK/D,kCAAT,EAA6C;AACzC,eAAO,KAAKA,kCAAL,CAAwCkD,IAAxC,CAA8ClH,UAAD,IAAkD;AAClG,cAAIA,UAAU,CAACuK,KAAX,OAAuBlM,eAAe,CAACmM,YAA3C,EAAyD;AACrD,iBAAKC,gBAAL,GAAwB,IAAxB;AACA,iBAAKzG,kCAAL,GAA0C,IAA1C;AACA,iBAAK2E,yBAAL,GAAiC,KAAjC;AACA,mBAAO,KAAKZ,eAAL,EAAP;AACH;;AACD,iBAAO,KAAK/D,kCAAZ;AACH,SARM,EAQHC,KAAD,IAAwC;AACvC,eAAKwG,gBAAL,GAAwB,IAAxB;AACA,eAAKzG,kCAAL,GAA0C,IAA1C;AACA,eAAK2E,yBAAL,GAAiC,KAAjC;AACA,iBAAO,KAAKZ,eAAL,EAAP;AACH,SAbM,CAAP;AAcH;;AAED,WAAK/D,kCAAL,GAA0C,KAAK4G,mBAAL,EAA1C;AACA,aAAO,MAAM,KAAK5G,kCAAlB;AACH;AAAA;;AAEeoC,WAAS,CAACnB,eAAD,EAAkC;;AACvD,YAAM4F,WAAW,GAA0B,MAAM,KAAKlL,WAAL,CAAiBwF,MAAlE,EAEA;;AACA,UAAI2F,YAAY,GAAWC,IAAI,CAACC,GAAL,EAA3B,EAEA;;AACA,YAAMC,cAAc,GAAW,KAAK9J,oBAAL,CAA0BC,UAA1B,CAAqCC,WAArC,CAAiD,sCAAjD,EAAyF,MAAzF,CAA/B;AACA,YAAM6J,uBAAuB,GAAWL,WAAW,CAACtF,cAAZ,GAA6B,IAA7B,GAAoC4F,QAAQ,CAACF,cAAD,EAAiB,EAAjB,CAApF;AACA,YAAMG,gBAAgB,GAAW,KAAKhL,kBAAL,CAAwBiL,WAAzD;;AAEA,YAAMC,kBAAkB,GAAG,MAA0B1I;AACjD;AACA,YAAI,CAAC,KAAKd,cAAN,IACA,CAAC,KAAK1B,kBAAL,CAAwBuJ,aADzB,IAEA,KAAKvJ,kBAAL,CAAwBoG,aAFxB,IAGA,KAAKpG,kBAAL,CAAwBiL,WAAxB,KAAwCD,gBAH5C,EAG8D;AAE1D,gBAAMpL,UAAU,GAAgB,MAAM,KAAK+H,eAAL,EAAtC;AACA,gBAAMwD,gBAAgB,GAA8B,MAAMtG,eAAe,CAACwD,IAAhB,EAA1D,CAH0D,CAI1D;;AACA,cAAI,KAAKrI,kBAAL,CAAwBuJ,aAA5B,EAA2C;AACvC;AACA;AACH;;AAED,cAAI/B,OAAJ;AACA,cAAI4D,SAAJ;;AAEA,cAAI,CAACD,gBAAD,IAAqBA,gBAAgB,CAACE,KAA1C,EAAiD;AAC7C7D,mBAAO,GAAG,IAAV;AACA4D,qBAAS,GAAG,CAAZ;AACH,WAHD,MAGO;AACH5D,mBAAO,GAAG2D,gBAAgB,CAACG,MAA3B;AAEA,iBAAKtL,kBAAL,CAAwBuL,WAAxB,CAAoC/D,OAAO,CAACgE,UAA5C;;AAEA,gBAAIV,uBAAuB,IAAI,KAAK9K,kBAAL,CAAwByL,SAAvD,EAAkE;AAC9DL,uBAAS,GAAG,CAAZ;AACH,aAFD,MAEO;AACHA,uBAAS,GAAGM,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYjB,YAAY,GAAGC,IAAI,CAACC,GAAL,EAA3B,CAAZ;AACH;AACJ;;AAED,cAAI,MAAMQ,SAAV,EAAqB;AACjB,kBAAM,KAAKQ,KAAL,CAAWR,SAAX,CAAN;AACH;;AAED,cAAI5D,OAAO,KAAK,IAAhB,EAAsB;AAClBkD,wBAAY,GAAGC,IAAI,CAACC,GAAL,KAAcpD,OAAO,CAACgE,UAAR,GAAqB,IAArB,IAA6Bf,WAAW,CAACtF,cAAZ,GAA6B,CAA1D,CAA7B;AACH,WAlCyD,CAoC1D;;;AACA,cAAI,CAAC,KAAKzD,cAAN,IACA,CAAC,KAAK1B,kBAAL,CAAwBuJ,aADzB,IAEA,KAAKvJ,kBAAL,CAAwBoG,aAFxB,IAGA,KAAKpG,kBAAL,CAAwBiL,WAAxB,KAAwCD,gBAH5C,EAG8D;AAC1DpL,sBAAU,CAACM,IAAX,CACI,IAAIhB,uBAAJ,CAA4Bd,WAAW,CAACqJ,MAAxC,EAAgD,OAAhD,EAAyD,KAAKzH,kBAAL,CAAwBI,SAAjF,EAA4F,IAA5F,EAAkGoH,OAAlG,CADJ,EAEEvB,KAFF,CAEQ,MAAK;AACT,mBAAKjG,kBAAL,CAAwB0J,wBAAxB,CAAiD,KAAK3I,oBAAL,CAA0BmI,uBAA3E,EAAoGjD,KAApG,CAA0G,MAAK,CAAI,CAAnH;AACH,aAJD;;AAMA,gBAAI,EAACkF,gBAAgB,SAAhB,oBAAgB,WAAhB,GAAgB,MAAhB,mBAAgB,CAAEE,KAAnB,CAAJ,EAA8B;AAC1B;AACA;AACA;AACA;AACA,qBAAOH,kBAAkB,EAAzB;AACH,aAND,MAMO;AACH;AACA;AACA,kBAAI,CAAC,KAAKjG,eAAV,EAA2B;AACvB,qBAAKjF,kBAAL,CAAwB6L,aAAxB;AACH;AACJ;AACJ;AACJ;AACJ,OAnEoD,CAArD;;AAqEA,aAAOX,kBAAkB,EAAzB;AACH;AAAA;;AAEaZ,kBAAgB;;AAC1B,UAAIwB,cAAc,GAAY,KAA9B;AAEA,WAAKC,oBAAL,GAA4B7N,gBAAgB,EAA5C;AACA,YAAMyH,SAAS,GAAW,KAAK3F,kBAAL,CAAwB2F,SAAlD;AACA,WAAK0E,gBAAL,GAAyB1E,SAAS,KAAKhG,SAAf,GAA4BgG,SAA5B,GAAwCzH,gBAAgB,EAAhF;AAEA,WAAK8B,kBAAL,CAAwBgM,oBAAxB,CAA6C,KAAKD,oBAAlD,EAAwE,KAAK1B,gBAA7E;AACA,UAAI4B,cAAc,GAAW,CAA7B;AACA,UAAIC,UAAU,GAAW,EAAzB;;AAEA,aAAO,KAAKlM,kBAAL,CAAwB4C,qBAAxB,IAAiD,KAAK7B,oBAAL,CAA0B8B,aAAlF,EAAiG;AAE7F;AACA;AACA,cAAMsJ,WAAW,GAAGL,cAAc,GAAG,KAAKvK,kBAAL,CAAwB6K,aAAxB,CAAsC,KAAKL,oBAA3C,CAAH,GAAsE,KAAKxK,kBAAL,CAAwB8K,KAAxB,CAA8B,KAAKN,oBAAnC,CAAxG;AACA,cAAMtI,IAAI,GAAa,MAAM0I,WAA7B;AAEA,cAAM,KAAKnM,kBAAL,CAAwBsM,eAAxB,CAAwC,KAAxC,CAAN,CAP6F,CAS7F;;AACA,cAAM1M,UAAU,GAAgB,KAAK4B,qBAAL,CAA2B+K,MAA3B,CAAkC,KAAKxL,oBAAvC,EAA6D0C,IAA7D,EAAmE,KAAK4G,gBAAxE,CAAhC,CAV6F,CAW7F;;AACA,aAAKrK,kBAAL,CAAwBwE,yBAAxB,CAAkD5E,UAAU,CAAC6E,MAA7D,EAZ6F,CAc7F;AACA;;AACA7E,kBAAU,CAAC6E,MAAX,CAAkBnC,MAAlB,CAA0BkK,KAAD,IAA2B;AAChD,eAAKnK,gBAAL,CAAsByH,OAAtB,CAA8B0C,KAA9B;AACH,SAFD;AAIA,cAAMC,QAAQ,GAA2B,MAAM7M,UAAU,CAAC8M,IAAX,EAA/C,CApB6F,CAqB7F;;AACA,YAAID,QAAQ,CAAC9J,UAAT,KAAwB,GAA5B,EAAiC;AAC7B,gBAAM,KAAK3C,kBAAL,CAAwB2M,8BAAxB,CAAuDF,QAAQ,CAAC9J,UAAhE,CAAN;AACA,iBAAO8D,OAAO,CAACC,OAAR,CAAgB9G,UAAhB,CAAP;AACH,SAHD,MAGO,IAAI6M,QAAQ,CAAC9J,UAAT,KAAwB,IAA5B,EAAkC;AACrCmJ,wBAAc,GAAG,IAAjB;AACH;;AAEDG,sBAAc,GAAGQ,QAAQ,CAAC9J,UAA1B;AACAuJ,kBAAU,GAAGO,QAAQ,CAACvJ,MAAtB;AAEA,aAAKlD,kBAAL,CAAwB4M,iBAAxB;AACH;;AAED,YAAM,KAAK5M,kBAAL,CAAwB2M,8BAAxB,CAAuDV,cAAvD,EAAuEC,UAAvE,CAAN;AACA,aAAOzF,OAAO,CAACoG,MAAR,CAAe,yCAAyCZ,cAAc,KAAK,KAAKlL,oBAAL,CAA0BC,UAA1B,CAAqCC,WAArC,CAAiDxC,UAAU,CAACqO,gCAA5D,CAA6F,YAAYZ,UAAU,EAA9L,CAAP;AACH;AAAA;;AAEON,OAAK,CAACmB,OAAD,EAAgB;AACzB,WAAO,IAAItG,OAAJ,CAAY,CAACC,OAAD,EAAsBmG,MAAtB,KAAyD;AACxE,WAAKzK,cAAL,CAAoBsE,OAApB,EAA6BqG,OAA7B;AACH,KAFM,CAAP;AAGH;;AAEOC,sBAAoB,CAAC1B,MAAD,EAAoB;AAC5C,QAAI2B,GAAG,GAAW,eAAlB;;AACA,QAAI,SAAS3B,MAAb,EAAqB;AACjB2B,SAAG,IAAI,MAAP;AACH,KAFD,MAEO;AACH,YAAMC,QAAQ,GAAe,IAAIC,UAAJ,CAAe7B,MAAf,CAA7B;AACA2B,SAAG,IAAI3B,MAAM,CAACE,UAAP,GAAoB,MAA3B;;AACA,WAAK,IAAI4B,CAAC,GAAW,CAArB,EAAwBA,CAAC,GAAG9B,MAAM,CAACE,UAAnC,EAA+C4B,CAAC,EAAhD,EAAoD;AAChDH,WAAG,IAAIC,QAAQ,CAACE,CAAD,CAAR,CAAYC,QAAZ,CAAqB,EAArB,EAAyBC,QAAzB,CAAkC,CAAlC,EAAqC,GAArC,IAA4C,GAAnD;AACH;AACJ,KAV2C,CAW5C;;;AACAC,WAAO,CAACC,IAAR,CAAaP,GAAb;AACH;;AAEa3G,gBAAc;;AACxB,YAAM1G,UAAU,GAAgB,MAAM,KAAK+H,eAAL,EAAtC;AACA,YAAM/H,UAAU,CAACM,IAAX,CAAgB,IAAIhB,uBAAJ,CAA4Bd,WAAW,CAACqJ,MAAxC,EAAgD,OAAhD,EAAyD,KAAKzH,kBAAL,CAAwBI,SAAjF,EAA4F,IAA5F,EAAkG,IAAlG,CAAhB,CAAN;AACA;AACH;AAAA,GAptBsC,CAstBvC;;;AACcoK,qBAAmB;;AAC7B,YAAM5K,UAAU,GAAgB,MAAM,KAAK+E,WAAL,EAAtC;;AACA,UAAI,KAAK8I,wBAAL,KAAkC9N,SAAtC,EAAiD;AAC7C,eAAO,KAAK8N,wBAAL,CAA8B7N,UAA9B,CAAP;AACH;;AACD,YAAM,KAAK8N,uBAAL,CAA6B9N,UAA7B,EAAyC,KAAKI,kBAA9C,EAAkE,KAAKe,oBAAL,CAA0BsE,mBAA1B,CAA8CsI,SAA9C,EAAlE,CAAN;AACA,YAAM,KAAK/D,kBAAL,CAAwBhK,UAAxB,CAAN;AACA,aAAOA,UAAP;AACH;AAAA;;AA/tBsC;AA4QzBT,6CAAgC,IAAhC","names":["ReplayableAudioNode","ArgumentNullError","ConnectionState","createNoDashGuid","EventSource","MessageType","ServiceEvent","Timeout","CancellationErrorCode","CancellationReason","PropertyId","RecognitionEventArgs","SessionEventArgs","AgentConfig","DynamicGrammarBuilder","RequestSession","SpeechContext","SpeechDetected","type","SpeechConnectionMessage","ServiceRecognizerBase","constructor","authentication","connectionFactory","audioSource","recognizerConfig","recognizer","setTimeout","undefined","connection","speechContextJson","speechContext","toJSON","privRequestSession","onSpeechContext","send","Text","requestId","requestSession","SpeechServiceConfigJson","telemetryDataEnabled","withTelemetry","JSON","parse","replacement","context","system","stringify","privRecognizerConfig","parameters","getProperty","toLowerCase","json","DisableReferenceChannel","MicSpec","privMustReportEndOfStream","privAuthentication","privConnectionFactory","privAudioSource","privIsDisposed","privRecognizer","id","privConnectionEvents","privServiceEvents","privDynamicGrammar","privSpeechContext","privAgentConfig","Blob","Worker","privSetTimeout","connectionEvents","attach","connectionEvent","__awaiter","name","connectionClosedEvent","statusCode","numConnectionAttempts","maxRetryCount","cancelRecognitionLocal","Error","BadRequestParameters","ConnectionFailure","reason","dynamicGrammar","agentConfig","conversationTranslatorToken","token","setProperty","ConversationTranslator_Token","auth","isDisposed","dispose","privConnectionConfigurationPromise","error","serviceEvents","recognitionMode","recognize","recoMode","successCallback","errorCallBack","recognizeOverride","privSuccessCallback","privErrorCallback","startNewRecognition","listenForServiceTelemetry","events","conPromise","connectImpl","audioNode","audioStreamNode","audioNodeId","format","deviceInfo","privIsLiveAudio","Microphones","avgBytesPerSec","onAudioSourceAttachCompleted","SpeechServiceConfig","Context","audio","source","onStopRecognizing","sessionStartEventArgs","sessionId","sessionStarted","messageRetrievalPromise","receiveMessage","audioSendPromise","sendAudio","catch","RuntimeError","stopRecognizing","isRecognizing","turnOff","sendFinalAudio","turnCompletionPromise","connect","Promise","resolve","connectAsync","cb","err","then","e","disconnect","NoError","disconnectOverride","privConnectionPromise","sendMessage","message","sendNetworkMessage","path","payload","Binary","contentType","fetchConnection","activityTemplate","messagePayload","privActivityTemplate","sendTelemetryData","telemetryData","getTelemetry","cancellationReason","errorCode","cancelRecognition","read","receiveMessageOverride","privServiceHasSentMessage","connectionMessage","fromConnectionMessage","onServiceTurnStartResponse","speechStartDetected","fromJSON","textBody","speechStartEventArgs","Offset","length","speechStopDetected","isContinuousRecognition","onServiceRecognized","currentTurnAudioOffset","speechStopEventArgs","speechEndDetected","isSpeechEnded","EndOfStream","sessionStopEventArgs","onServiceTurnEndResponse","sessionStopped","sendPrePayloadJSON","processTypeSpecificMessages","onEvent","sendPrePayloadJSONOverride","sendSpeechContext","sendWaveHeader","header","state","Disconnected","privConnectionId","retryableConnect","postConnectImplOverride","configureConnection","audioFormat","nextSendTime","Date","now","fastLaneSizeMs","maxSendUnthrottledBytes","parseInt","startRecogNumber","recogNumber","readAndUploadCycle","audioStreamChunk","sendDelay","isEnd","buffer","onAudioSent","byteLength","bytesSent","Math","max","delay","onSpeechEnded","isUnAuthorized","privAuthFetchEventId","onPreConnectionStart","lastStatusCode","lastReason","authPromise","fetchOnExpiry","fetch","onAuthCompleted","create","event","response","open","onConnectionEstablishCompleted","onRetryConnection","reject","SpeechServiceConnection_Endpoint","delayMs","writeBufferToConsole","out","readView","Uint8Array","i","toString","padStart","console","info","configConnectionOverride","sendSpeechServiceConfig","serialize"],"sources":["C:\\Users\\olesr\\OneDrive\\Documents\\webapp_educ_2\\educator\\node_modules\\microsoft-cognitiveservices-speech-sdk\\distrib\\es2015\\src\\common.speech\\src\\common.speech\\ServiceRecognizerBase.ts"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { ReplayableAudioNode } from \"../common.browser/Exports\";\r\nimport { ConnectionOpenResponse } from \"../common/ConnectionOpenResponse\";\r\nimport {\r\n    ArgumentNullError,\r\n    ConnectionClosedEvent,\r\n    ConnectionEvent,\r\n    ConnectionState,\r\n    createNoDashGuid,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IConnection,\r\n    IDisposable,\r\n    IStreamChunk,\r\n    MessageType,\r\n    ServiceEvent,\r\n    Timeout\r\n} from \"../common/Exports\";\r\nimport { AudioStreamFormatImpl } from \"../sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    CancellationErrorCode,\r\n    CancellationReason,\r\n    PropertyId,\r\n    RecognitionEventArgs,\r\n    Recognizer,\r\n    SessionEventArgs,\r\n    SpeechRecognitionResult,\r\n} from \"../sdk/Exports\";\r\nimport { Callback } from \"../sdk/Transcription/IConversation\";\r\nimport {\r\n    AgentConfig,\r\n    DynamicGrammarBuilder,\r\n    ISpeechConfigAudioDevice,\r\n    RecognitionMode,\r\n    RequestSession,\r\n    SpeechContext,\r\n    SpeechDetected,\r\n    type\r\n} from \"./Exports\";\r\nimport {\r\n    AuthInfo,\r\n    IAuthentication,\r\n} from \"./IAuthentication\";\r\nimport { IConnectionFactory } from \"./IConnectionFactory\";\r\nimport { RecognizerConfig } from \"./RecognizerConfig\";\r\nimport { SpeechConnectionMessage } from \"./SpeechConnectionMessage.Internal\";\r\n\r\nexport abstract class ServiceRecognizerBase implements IDisposable {\r\n    private privAuthentication: IAuthentication;\r\n    private privConnectionFactory: IConnectionFactory;\r\n\r\n    // A promise for a configured connection.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionConfigurationPromise: Promise<IConnection>;\r\n\r\n    // A promise for a connection, but one that has not had the speech context sent yet.\r\n    // Do not consume directly, call fetchConnection instead.\r\n    private privConnectionPromise: Promise<IConnection>;\r\n    private privAuthFetchEventId: string;\r\n    private privIsDisposed: boolean;\r\n    private privMustReportEndOfStream: boolean;\r\n    private privConnectionEvents: EventSource<ConnectionEvent>;\r\n    private privServiceEvents: EventSource<ServiceEvent>;\r\n    private privDynamicGrammar: DynamicGrammarBuilder;\r\n    private privAgentConfig: AgentConfig;\r\n    private privServiceHasSentMessage: boolean;\r\n    private privActivityTemplate: string;\r\n    private privSetTimeout: (cb: () => void, delay: number) => number = setTimeout;\r\n    private privAudioSource: IAudioSource;\r\n    private privIsLiveAudio: boolean = false;\r\n    protected privSpeechContext: SpeechContext;\r\n    protected privRequestSession: RequestSession;\r\n    protected privConnectionId: string;\r\n    protected privRecognizerConfig: RecognizerConfig;\r\n    protected privRecognizer: Recognizer;\r\n    protected privSuccessCallback: (e: SpeechRecognitionResult) => void;\r\n    protected privErrorCallback: (e: string) => void;\r\n\r\n    public constructor(\r\n        authentication: IAuthentication,\r\n        connectionFactory: IConnectionFactory,\r\n        audioSource: IAudioSource,\r\n        recognizerConfig: RecognizerConfig,\r\n        recognizer: Recognizer) {\r\n\r\n        if (!authentication) {\r\n            throw new ArgumentNullError(\"authentication\");\r\n        }\r\n\r\n        if (!connectionFactory) {\r\n            throw new ArgumentNullError(\"connectionFactory\");\r\n        }\r\n\r\n        if (!audioSource) {\r\n            throw new ArgumentNullError(\"audioSource\");\r\n        }\r\n\r\n        if (!recognizerConfig) {\r\n            throw new ArgumentNullError(\"recognizerConfig\");\r\n        }\r\n\r\n        this.privMustReportEndOfStream = false;\r\n        this.privAuthentication = authentication;\r\n        this.privConnectionFactory = connectionFactory;\r\n        this.privAudioSource = audioSource;\r\n        this.privRecognizerConfig = recognizerConfig;\r\n        this.privIsDisposed = false;\r\n        this.privRecognizer = recognizer;\r\n        this.privRequestSession = new RequestSession(this.privAudioSource.id());\r\n        this.privConnectionEvents = new EventSource<ConnectionEvent>();\r\n        this.privServiceEvents = new EventSource<ServiceEvent>();\r\n        this.privDynamicGrammar = new DynamicGrammarBuilder();\r\n        this.privSpeechContext = new SpeechContext(this.privDynamicGrammar);\r\n        this.privAgentConfig = new AgentConfig();\r\n        if (typeof (Blob) !== \"undefined\" && typeof (Worker) !== \"undefined\") {\r\n            this.privSetTimeout = Timeout.setTimeout;\r\n        }\r\n\r\n        this.connectionEvents.attach(async (connectionEvent: ConnectionEvent): Promise<void> => {\r\n            if (connectionEvent.name === \"ConnectionClosedEvent\") {\r\n                const connectionClosedEvent = connectionEvent as ConnectionClosedEvent;\r\n                if (connectionClosedEvent.statusCode === 1003 ||\r\n                    connectionClosedEvent.statusCode === 1007 ||\r\n                    connectionClosedEvent.statusCode === 1002 ||\r\n                    connectionClosedEvent.statusCode === 4000 ||\r\n                    this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount\r\n                ) {\r\n                    await this.cancelRecognitionLocal(CancellationReason.Error,\r\n                        connectionClosedEvent.statusCode === 1007 ? CancellationErrorCode.BadRequestParameters : CancellationErrorCode.ConnectionFailure,\r\n                        connectionClosedEvent.reason + \" websocket error code: \" + connectionClosedEvent.statusCode);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    public get audioSource(): IAudioSource {\r\n        return this.privAudioSource;\r\n    }\r\n\r\n    public get speechContext(): SpeechContext {\r\n        return this.privSpeechContext;\r\n    }\r\n\r\n    public get dynamicGrammar(): DynamicGrammarBuilder {\r\n        return this.privDynamicGrammar;\r\n    }\r\n\r\n    public get agentConfig(): AgentConfig {\r\n        return this.privAgentConfig;\r\n    }\r\n\r\n    public set conversationTranslatorToken(token: string) {\r\n        this.privRecognizerConfig.parameters.setProperty(PropertyId.ConversationTranslator_Token, token);\r\n    }\r\n\r\n    public set authentication(auth: IAuthentication) {\r\n        this.privAuthentication = this.authentication;\r\n    }\r\n\r\n    public isDisposed(): boolean {\r\n        return this.privIsDisposed;\r\n    }\r\n\r\n    public async dispose(reason?: string): Promise<void> {\r\n        this.privIsDisposed = true;\r\n        if (this.privConnectionConfigurationPromise) {\r\n            try {\r\n                const connection: IConnection = await this.privConnectionConfigurationPromise;\r\n                await connection.dispose(reason);\r\n            } catch (error) {\r\n                // The connection is in a bad state. But we're trying to kill it, so...\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    public get connectionEvents(): EventSource<ConnectionEvent> {\r\n        return this.privConnectionEvents;\r\n    }\r\n\r\n    public get serviceEvents(): EventSource<ServiceEvent> {\r\n        return this.privServiceEvents;\r\n    }\r\n\r\n    public get recognitionMode(): RecognitionMode {\r\n        return this.privRecognizerConfig.recognitionMode;\r\n    }\r\n\r\n    protected recognizeOverride: (recoMode: RecognitionMode, sc: (e: SpeechRecognitionResult) => void, ec: (e: string) => void) => any = undefined;\r\n\r\n    public async recognize(\r\n        recoMode: RecognitionMode,\r\n        successCallback: (e: SpeechRecognitionResult) => void,\r\n        errorCallBack: (e: string) => void,\r\n    ): Promise<void> {\r\n\r\n        if (this.recognizeOverride !== undefined) {\r\n            return this.recognizeOverride(recoMode, successCallback, errorCallBack);\r\n        }\r\n        // Clear the existing configuration promise to force a re-transmission of config and context.\r\n        this.privConnectionConfigurationPromise = null;\r\n        this.privRecognizerConfig.recognitionMode = recoMode;\r\n\r\n        this.privSuccessCallback = successCallback;\r\n        this.privErrorCallback = errorCallBack;\r\n\r\n        this.privRequestSession.startNewRecognition();\r\n        this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);\r\n\r\n        // Start the connection to the service. The promise this will create is stored and will be used by configureConnection().\r\n        const conPromise: Promise<IConnection> = this.connectImpl();\r\n        let audioNode: ReplayableAudioNode;\r\n\r\n        try {\r\n            const audioStreamNode: IAudioStreamNode = await this.audioSource.attach(this.privRequestSession.audioNodeId);\r\n            const format: AudioStreamFormatImpl = await this.audioSource.format;\r\n            const deviceInfo: ISpeechConfigAudioDevice = await this.audioSource.deviceInfo;\r\n            this.privIsLiveAudio = deviceInfo.type && deviceInfo.type === type.Microphones;\r\n\r\n            audioNode = new ReplayableAudioNode(audioStreamNode, format.avgBytesPerSec);\r\n            await this.privRequestSession.onAudioSourceAttachCompleted(audioNode, false);\r\n            this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: deviceInfo };\r\n\r\n        } catch (error) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n            throw error;\r\n        }\r\n\r\n        try {\r\n            await conPromise;\r\n        } catch (error) {\r\n            await this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.ConnectionFailure, error);\r\n            return;\r\n        }\r\n\r\n        const sessionStartEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n\r\n        if (!!this.privRecognizer.sessionStarted) {\r\n            this.privRecognizer.sessionStarted(this.privRecognizer, sessionStartEventArgs);\r\n        }\r\n\r\n        const messageRetrievalPromise = this.receiveMessage();\r\n        const audioSendPromise = this.sendAudio(audioNode);\r\n\r\n        audioSendPromise.catch(async (error: string) => {\r\n            await this.cancelRecognitionLocal(CancellationReason.Error, CancellationErrorCode.RuntimeError, error);\r\n        });\r\n\r\n        return;\r\n    }\r\n\r\n    public async stopRecognizing(): Promise<void> {\r\n        if (this.privRequestSession.isRecognizing) {\r\n            try {\r\n                await this.audioSource.turnOff();\r\n                await this.sendFinalAudio();\r\n                await this.privRequestSession.onStopRecognizing();\r\n                await this.privRequestSession.turnCompletionPromise;\r\n            } finally {\r\n                await this.privRequestSession.dispose();\r\n            }\r\n        }\r\n        return;\r\n    }\r\n\r\n    public async connect(): Promise<void> {\r\n        await this.connectImpl();\r\n        return Promise.resolve();\r\n    }\r\n\r\n    public connectAsync(cb?: Callback, err?: Callback): void {\r\n        this.connectImpl().then((connection: IConnection): void => {\r\n            try {\r\n                if (!!cb) {\r\n                    cb();\r\n                }\r\n            } catch (e) {\r\n                if (!!err) {\r\n                    err(e);\r\n                }\r\n            }\r\n        }, (reason: any): void => {\r\n            try {\r\n                if (!!err) {\r\n                    err(reason);\r\n                }\r\n                /* tslint:disable:no-empty */\r\n            } catch (error) {\r\n            }\r\n        });\r\n    }\r\n\r\n    protected disconnectOverride: () => Promise<void> = undefined;\r\n\r\n    public async disconnect(): Promise<void> {\r\n        await this.cancelRecognitionLocal(CancellationReason.Error,\r\n            CancellationErrorCode.NoError,\r\n            \"Disconnecting\");\r\n\r\n        if (this.disconnectOverride !== undefined) {\r\n            await this.disconnectOverride();\r\n        }\r\n\r\n        try {\r\n            await (await this.privConnectionPromise).dispose();\r\n        } catch (error) {\r\n\r\n        }\r\n\r\n        this.privConnectionPromise = null;\r\n    }\r\n\r\n    // Called when telemetry data is sent to the service.\r\n    // Used for testing Telemetry capture.\r\n    public static telemetryData: (json: string) => void;\r\n    public static telemetryDataEnabled: boolean = true;\r\n\r\n    public sendMessage(message: string): void { }\r\n\r\n    public async sendNetworkMessage(path: string, payload: string | ArrayBuffer): Promise<void> {\r\n        const type: MessageType = typeof payload === \"string\" ? MessageType.Text : MessageType.Binary;\r\n        const contentType: string = typeof payload === \"string\" ? \"application/json\" : \"\";\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        return connection.send(new SpeechConnectionMessage(type, path, this.privRequestSession.requestId, contentType, payload));\r\n    }\r\n\r\n    public set activityTemplate(messagePayload: string) { this.privActivityTemplate = messagePayload; }\r\n    public get activityTemplate(): string { return this.privActivityTemplate; }\r\n\r\n    protected abstract processTypeSpecificMessages(\r\n        connectionMessage: SpeechConnectionMessage,\r\n        successCallback?: (e: SpeechRecognitionResult) => void,\r\n        errorCallBack?: (e: string) => void): Promise<boolean>;\r\n\r\n    protected async sendTelemetryData(): Promise<void> {\r\n        const telemetryData = this.privRequestSession.getTelemetry();\r\n        if (ServiceRecognizerBase.telemetryDataEnabled !== true ||\r\n            this.privIsDisposed ||\r\n            null === telemetryData) {\r\n            return;\r\n        }\r\n\r\n        if (!!ServiceRecognizerBase.telemetryData) {\r\n            try {\r\n                ServiceRecognizerBase.telemetryData(telemetryData);\r\n                /* tslint:disable:no-empty */\r\n            } catch { }\r\n        }\r\n\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(\r\n            MessageType.Text,\r\n            \"telemetry\",\r\n            this.privRequestSession.requestId,\r\n            \"application/json\",\r\n            telemetryData));\r\n    }\r\n\r\n    // Cancels recognition.\r\n    protected abstract cancelRecognition(\r\n        sessionId: string,\r\n        requestId: string,\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): void;\r\n\r\n    // Cancels recognition.\r\n    protected async cancelRecognitionLocal(\r\n        cancellationReason: CancellationReason,\r\n        errorCode: CancellationErrorCode,\r\n        error: string): Promise<void> {\r\n\r\n        if (!!this.privRequestSession.isRecognizing) {\r\n            await this.privRequestSession.onStopRecognizing();\r\n\r\n            this.cancelRecognition(\r\n                this.privRequestSession.sessionId,\r\n                this.privRequestSession.requestId,\r\n                cancellationReason,\r\n                errorCode,\r\n                error);\r\n        }\r\n    }\r\n\r\n    protected receiveMessageOverride: () => Promise<void> = undefined;\r\n\r\n    protected async receiveMessage(): Promise<void> {\r\n        try {\r\n            if (this.privIsDisposed) {\r\n                // We're done.\r\n                return;\r\n            }\r\n\r\n            let connection = await this.fetchConnection();\r\n            const message = await connection.read();\r\n\r\n            if (this.receiveMessageOverride !== undefined) {\r\n                return this.receiveMessageOverride();\r\n            }\r\n\r\n            // indicates we are draining the queue and it came with no message;\r\n            if (!message) {\r\n                if (!this.privRequestSession.isRecognizing) {\r\n                    return;\r\n                } else {\r\n                    return this.receiveMessage();\r\n                }\r\n            }\r\n\r\n            this.privServiceHasSentMessage = true;\r\n            const connectionMessage = SpeechConnectionMessage.fromConnectionMessage(message);\r\n\r\n            if (connectionMessage.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase()) {\r\n                switch (connectionMessage.path.toLowerCase()) {\r\n                    case \"turn.start\":\r\n                        this.privMustReportEndOfStream = true;\r\n                        this.privRequestSession.onServiceTurnStartResponse();\r\n                        break;\r\n\r\n                    case \"speech.startdetected\":\r\n                        const speechStartDetected: SpeechDetected = SpeechDetected.fromJSON(connectionMessage.textBody);\r\n                        const speechStartEventArgs = new RecognitionEventArgs(speechStartDetected.Offset, this.privRequestSession.sessionId);\r\n                        if (!!this.privRecognizer.speechStartDetected) {\r\n                            this.privRecognizer.speechStartDetected(this.privRecognizer, speechStartEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"speech.enddetected\":\r\n                        let json: string;\r\n                        if (connectionMessage.textBody.length > 0) {\r\n                            json = connectionMessage.textBody;\r\n                        } else {\r\n                            // If the request was empty, the JSON returned is empty.\r\n                            json = \"{ Offset: 0 }\";\r\n                        }\r\n                        const speechStopDetected: SpeechDetected = SpeechDetected.fromJSON(json);\r\n                        // Only shrink the buffers for continuous recognition.\r\n                        // For single shot, the speech.phrase message will come after the speech.end and it should own buffer shrink.\r\n                        if (this.privRecognizerConfig.isContinuousRecognition) {\r\n                            this.privRequestSession.onServiceRecognized(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset);\r\n                        }\r\n                        const speechStopEventArgs = new RecognitionEventArgs(speechStopDetected.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);\r\n                        if (!!this.privRecognizer.speechEndDetected) {\r\n                            this.privRecognizer.speechEndDetected(this.privRecognizer, speechStopEventArgs);\r\n                        }\r\n                        break;\r\n\r\n                    case \"turn.end\":\r\n                        await this.sendTelemetryData();\r\n                        if (this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream) {\r\n                            this.privMustReportEndOfStream = false;\r\n                            await this.cancelRecognitionLocal(CancellationReason.EndOfStream, CancellationErrorCode.NoError, undefined);\r\n                        }\r\n                        const sessionStopEventArgs: SessionEventArgs = new SessionEventArgs(this.privRequestSession.sessionId);\r\n                        await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition);\r\n                        if (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {\r\n                            if (!!this.privRecognizer.sessionStopped) {\r\n                                this.privRecognizer.sessionStopped(this.privRecognizer, sessionStopEventArgs);\r\n                            }\r\n                            return;\r\n                        } else {\r\n                            connection = await this.fetchConnection();\r\n                            await this.sendPrePayloadJSON(connection);\r\n                        }\r\n                        break;\r\n\r\n                    default:\r\n                        if (!await this.processTypeSpecificMessages(connectionMessage)) {\r\n                            // here are some messages that the derived class has not processed, dispatch them to connect class\r\n                            if (!!this.privServiceEvents) {\r\n                                this.serviceEvents.onEvent(new ServiceEvent(connectionMessage.path.toLowerCase(), connectionMessage.textBody));\r\n                            }\r\n                        }\r\n                }\r\n            }\r\n            return this.receiveMessage();\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected sendSpeechContext = (connection: IConnection): Promise<void> => {\r\n        const speechContextJson = this.speechContext.toJSON();\r\n        this.privRequestSession.onSpeechContext();\r\n\r\n        if (speechContextJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.context\",\r\n                this.privRequestSession.requestId,\r\n                \"application/json\",\r\n                speechContextJson));\r\n        }\r\n        return;\r\n    }\r\n\r\n    protected sendPrePayloadJSONOverride: (connection: IConnection) => Promise<void> = undefined;\r\n\r\n    // Encapsulated for derived service recognizers that need to send additional JSON\r\n    protected async sendPrePayloadJSON(connection: IConnection): Promise<void> {\r\n        if (this.sendPrePayloadJSONOverride !== undefined) {\r\n            return this.sendPrePayloadJSONOverride(connection);\r\n        }\r\n\r\n        await this.sendSpeechContext(connection);\r\n        await this.sendWaveHeader(connection);\r\n        return;\r\n    }\r\n\r\n    protected async sendWaveHeader(connection: IConnection): Promise<void> {\r\n        const format: AudioStreamFormatImpl = await this.audioSource.format;\r\n        // this.writeBufferToConsole(format.header);\r\n        return connection.send(new SpeechConnectionMessage(\r\n            MessageType.Binary,\r\n            \"audio\",\r\n            this.privRequestSession.requestId,\r\n            \"audio/x-wav\",\r\n            format.header\r\n        ));\r\n    }\r\n\r\n    protected postConnectImplOverride: (connection: Promise<IConnection>) => Promise<IConnection> = undefined;\r\n\r\n    // Establishes a websocket connection to the end point.\r\n    protected connectImpl(): Promise<IConnection> {\r\n        if (this.privConnectionPromise) {\r\n            return this.privConnectionPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.connectImpl();\r\n                }\r\n                return this.privConnectionPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.connectImpl();\r\n            });\r\n        }\r\n\r\n        this.privConnectionPromise = this.retryableConnect();\r\n\r\n        // Attach an empty handler to allow the promise to run in the background while\r\n        // other startup events happen. It'll eventually be awaited on.\r\n        this.privConnectionPromise.catch(() => { });\r\n\r\n        if (this.postConnectImplOverride !== undefined) {\r\n            return this.postConnectImplOverride(this.privConnectionPromise);\r\n        }\r\n\r\n        return this.privConnectionPromise;\r\n    }\r\n\r\n    protected configConnectionOverride: (connection: IConnection) => Promise<IConnection> = undefined;\r\n\r\n    protected sendSpeechServiceConfig = (connection: IConnection, requestSession: RequestSession, SpeechServiceConfigJson: string): Promise<void> => {\r\n        // filter out anything that is not required for the service to work.\r\n        if (ServiceRecognizerBase.telemetryDataEnabled !== true) {\r\n            const withTelemetry = JSON.parse(SpeechServiceConfigJson);\r\n\r\n            const replacement: any = {\r\n                context: {\r\n                    system: withTelemetry.context.system,\r\n                },\r\n            };\r\n\r\n            SpeechServiceConfigJson = JSON.stringify(replacement);\r\n        }\r\n\r\n        if (this.privRecognizerConfig.parameters.getProperty(\"TranscriptionService_SingleChannel\", \"false\").toLowerCase() === \"true\") {\r\n            const json: { context: any } = JSON.parse(SpeechServiceConfigJson);\r\n            json.context.DisableReferenceChannel = \"True\";\r\n            json.context.MicSpec = \"1_0_0\";\r\n            SpeechServiceConfigJson = JSON.stringify(json);\r\n        }\r\n\r\n        if (SpeechServiceConfigJson) {\r\n            return connection.send(new SpeechConnectionMessage(\r\n                MessageType.Text,\r\n                \"speech.config\",\r\n                requestSession.requestId,\r\n                \"application/json\",\r\n                SpeechServiceConfigJson));\r\n        }\r\n\r\n        return;\r\n    }\r\n\r\n    protected async fetchConnection(): Promise<IConnection> {\r\n        if (this.privConnectionConfigurationPromise) {\r\n            return this.privConnectionConfigurationPromise.then((connection: IConnection): Promise<IConnection> => {\r\n                if (connection.state() === ConnectionState.Disconnected) {\r\n                    this.privConnectionId = null;\r\n                    this.privConnectionConfigurationPromise = null;\r\n                    this.privServiceHasSentMessage = false;\r\n                    return this.fetchConnection();\r\n                }\r\n                return this.privConnectionConfigurationPromise;\r\n            }, (error: string): Promise<IConnection> => {\r\n                this.privConnectionId = null;\r\n                this.privConnectionConfigurationPromise = null;\r\n                this.privServiceHasSentMessage = false;\r\n                return this.fetchConnection();\r\n            });\r\n        }\r\n\r\n        this.privConnectionConfigurationPromise = this.configureConnection();\r\n        return await this.privConnectionConfigurationPromise;\r\n    }\r\n\r\n    protected async sendAudio(audioStreamNode: IAudioStreamNode): Promise<void> {\r\n        const audioFormat: AudioStreamFormatImpl = await this.audioSource.format;\r\n\r\n        // The time we last sent data to the service.\r\n        let nextSendTime: number = Date.now();\r\n\r\n        // Max amount to send before we start to throttle\r\n        const fastLaneSizeMs: string = this.privRecognizerConfig.parameters.getProperty(\"SPEECH-TransmitLengthBeforThrottleMs\", \"5000\");\r\n        const maxSendUnthrottledBytes: number = audioFormat.avgBytesPerSec / 1000 * parseInt(fastLaneSizeMs, 10);\r\n        const startRecogNumber: number = this.privRequestSession.recogNumber;\r\n\r\n        const readAndUploadCycle = async (): Promise<void> => {\r\n            // If speech is done, stop sending audio.\r\n            if (!this.privIsDisposed &&\r\n                !this.privRequestSession.isSpeechEnded &&\r\n                this.privRequestSession.isRecognizing &&\r\n                this.privRequestSession.recogNumber === startRecogNumber) {\r\n\r\n                const connection: IConnection = await this.fetchConnection();\r\n                const audioStreamChunk: IStreamChunk<ArrayBuffer> = await audioStreamNode.read();\r\n                // we have a new audio chunk to upload.\r\n                if (this.privRequestSession.isSpeechEnded) {\r\n                    // If service already recognized audio end then don't send any more audio\r\n                    return;\r\n                }\r\n\r\n                let payload: ArrayBuffer;\r\n                let sendDelay: number;\r\n\r\n                if (!audioStreamChunk || audioStreamChunk.isEnd) {\r\n                    payload = null;\r\n                    sendDelay = 0;\r\n                } else {\r\n                    payload = audioStreamChunk.buffer;\r\n\r\n                    this.privRequestSession.onAudioSent(payload.byteLength);\r\n\r\n                    if (maxSendUnthrottledBytes >= this.privRequestSession.bytesSent) {\r\n                        sendDelay = 0;\r\n                    } else {\r\n                        sendDelay = Math.max(0, nextSendTime - Date.now());\r\n                    }\r\n                }\r\n\r\n                if (0 !== sendDelay) {\r\n                    await this.delay(sendDelay);\r\n                }\r\n\r\n                if (payload !== null) {\r\n                    nextSendTime = Date.now() + (payload.byteLength * 1000 / (audioFormat.avgBytesPerSec * 2));\r\n                }\r\n\r\n                // Are we still alive?\r\n                if (!this.privIsDisposed &&\r\n                    !this.privRequestSession.isSpeechEnded &&\r\n                    this.privRequestSession.isRecognizing &&\r\n                    this.privRequestSession.recogNumber === startRecogNumber) {\r\n                    connection.send(\r\n                        new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, payload)\r\n                    ).catch(() => {\r\n                        this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => { });\r\n                    });\r\n\r\n                    if (!audioStreamChunk?.isEnd) {\r\n                        // this.writeBufferToConsole(payload);\r\n                        // Regardless of success or failure, schedule the next upload.\r\n                        // If the underlying connection was broken, the next cycle will\r\n                        // get a new connection and re-transmit missing audio automatically.\r\n                        return readAndUploadCycle();\r\n                    } else {\r\n                        // the audio stream has been closed, no need to schedule next\r\n                        // read-upload cycle.\r\n                        if (!this.privIsLiveAudio) {\r\n                            this.privRequestSession.onSpeechEnded();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n\r\n        return readAndUploadCycle();\r\n    }\r\n\r\n    private async retryableConnect(): Promise<IConnection> {\r\n        let isUnAuthorized: boolean = false;\r\n\r\n        this.privAuthFetchEventId = createNoDashGuid();\r\n        const sessionId: string = this.privRequestSession.sessionId;\r\n        this.privConnectionId = (sessionId !== undefined) ? sessionId : createNoDashGuid();\r\n\r\n        this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);\r\n        let lastStatusCode: number = 0;\r\n        let lastReason: string = \"\";\r\n\r\n        while (this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount) {\r\n\r\n            // Get the auth information for the connection. This is a bit of overkill for the current API surface, but leaving the plumbing in place to be able to raise a developer-customer\r\n            // facing event when a connection fails to let them try and provide new auth information.\r\n            const authPromise = isUnAuthorized ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);\r\n            const auth: AuthInfo = await authPromise;\r\n\r\n            await this.privRequestSession.onAuthCompleted(false);\r\n\r\n            // Create the connection\r\n            const connection: IConnection = this.privConnectionFactory.create(this.privRecognizerConfig, auth, this.privConnectionId);\r\n            // Attach the telemetry handlers.\r\n            this.privRequestSession.listenForServiceTelemetry(connection.events);\r\n\r\n            // Attach to the underlying event. No need to hold onto the detach pointers as in the event the connection goes away,\r\n            // it'll stop sending events.\r\n            connection.events.attach((event: ConnectionEvent) => {\r\n                this.connectionEvents.onEvent(event);\r\n            });\r\n\r\n            const response: ConnectionOpenResponse = await connection.open();\r\n            // 200 == everything is fine.\r\n            if (response.statusCode === 200) {\r\n                await this.privRequestSession.onConnectionEstablishCompleted(response.statusCode);\r\n                return Promise.resolve(connection);\r\n            } else if (response.statusCode === 1006) {\r\n                isUnAuthorized = true;\r\n            }\r\n\r\n            lastStatusCode = response.statusCode;\r\n            lastReason = response.reason;\r\n\r\n            this.privRequestSession.onRetryConnection();\r\n        }\r\n\r\n        await this.privRequestSession.onConnectionEstablishCompleted(lastStatusCode, lastReason);\r\n        return Promise.reject(`Unable to contact server. StatusCode: ${lastStatusCode}, ${this.privRecognizerConfig.parameters.getProperty(PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${lastReason}`);\r\n    }\r\n\r\n    private delay(delayMs: number): Promise<void> {\r\n        return new Promise((resolve: () => void, reject: (error: string) => void) => {\r\n            this.privSetTimeout(resolve, delayMs);\r\n        });\r\n    }\r\n\r\n    private writeBufferToConsole(buffer: ArrayBuffer): void {\r\n        let out: string = \"Buffer Size: \";\r\n        if (null === buffer) {\r\n            out += \"null\";\r\n        } else {\r\n            const readView: Uint8Array = new Uint8Array(buffer);\r\n            out += buffer.byteLength + \"\\r\\n\";\r\n            for (let i: number = 0; i < buffer.byteLength; i++) {\r\n                out += readView[i].toString(16).padStart(2, \"0\") + \" \";\r\n            }\r\n        }\r\n        // tslint:disable-next-line:no-console\r\n        console.info(out);\r\n    }\r\n\r\n    private async sendFinalAudio(): Promise<void> {\r\n        const connection: IConnection = await this.fetchConnection();\r\n        await connection.send(new SpeechConnectionMessage(MessageType.Binary, \"audio\", this.privRequestSession.requestId, null, null));\r\n        return;\r\n    }\r\n\r\n    // Takes an established websocket connection to the endpoint and sends speech configuration information.\r\n    private async configureConnection(): Promise<IConnection> {\r\n        const connection: IConnection = await this.connectImpl();\r\n        if (this.configConnectionOverride !== undefined) {\r\n            return this.configConnectionOverride(connection);\r\n        }\r\n        await this.sendSpeechServiceConfig(connection, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize());\r\n        await this.sendPrePayloadJSON(connection);\r\n        return connection;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}